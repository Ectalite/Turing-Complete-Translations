=== trans/manual_text_negative_numbers ===

$85226853816564
La représentation des nombres négatifs que tu as trouvée est appelée "complément à 2". C'est la représentation standardisée des nombres négatifs dans les ordinateurs modernes. Son avantage principal est que cette représentation des négatifs fonctionne sans problème avec le même additionneur que nous avons utilisé pour la représentation non signée.

Aux débuts de l'informatique, le principal concurrent du "complément à 2" était le "complément à 1". Son avantage était que l'inversion de signe était simple, et nécessitait d'inverser tous les bits du nombre. Par contre, il y avait 2 représentations de 0, une positive et une négative, ce qui compliquait les comparaisons.

La base -2 est aussi une représentation potentiellement intéressante, à chaque bit correspond une valeur alternativement positive et négative.


=== trans/options_console ===

$96601731563408 Ouvrir le terminal


=== components/DivMod64 ===

$80284847781948 Diviser
$71663353206665 Diviser et calculer le modulo de deux nombres


=== trans/ide_add_assembly_header ===

$94462268558066 [center]Ajoute le code assembleur[/center]


=== main_scripts/leg_level ===

$11144256835662 XORi
$20104629254326 ARGUMENT 2
$65642901654732 {component} devrait être désactivé
$89011349770597 NOT
$98778676892898 {component} devrait être actif avec la valeur {value}
$40520283279584 XOR
$71204580217527 NOTi
$14186606871089 Au prochain cycke la valeur du compteur sera {wrong_value} alors qu'on attend {value}
$27868897434461 Composant compteur introuvable
$38681417496680 ARGUMENT 1
$24003300271049 {component} devrait avoir la valeur {value} et non {wrong_value}
$50231510806554 Composant programme introuvable


=== trans/level_complete_delay ===

$73470840319057
[b]Délai[/b]
[color=#cccccc][i]Tu peux désormais voir le délai de tes circuits et des composants.[/i][/color]


=== trans/manual_text_hard_disk ===

$82372297690518
Les disques durs sont constitués d'un disque rotatif et d'un bras mécanique qui se déplace physiquement pour lire ou écrire les données. Evidemment les mouvements physiques sont extrêmement lents par rapport à l'électronique. Les systèmes d'exploitation réordonnent normalement les lectures et écritures de façon à limiter autant que possinle les déplacements du bras. 

Le composant disque dur a une patte "positionner", qui te permet de modifier l'adresse observée d'une certaine quantité. Les adresses "bouclent" de telle sorte que descendre de 1 à partir de 0 nous ramène à l'adresse la plus grande, et remonter de 1 nous fait ensuite revenir à 0.


=== trans/manual_text_instructions ===

$24791538034329
Ce que ce jeu appelle une "instruction" s'appelle également opération ou opcode (raccourci anglais de code opération. Quelquesoit le système d'exploitation, le langage de programmation et tous les couches logicielles utilisées, tous les logiciels doivent finir par être ramenés à des instructions que le CPU peut exécuter.

A l'intérieur des processeurs modernes, les instructions sont converties en "microcodes" qui correspondent à des étapes encore plus élémentaires et sont inaccessibles au programmeur.


=== trans/manual_text_circular_dependency ===

$29050562435902
Une dépendance circulaire apparaît quand l'entrée d'un composant dépend de sa propre sortie.

[center][img]res://dialogue/circular_dependency.png[/img][/center]

Ce simulateur n'autorise pas les dépendances circulaires et génère alors une erreur.

Les pattes carrées sont une exception, elles influencent la sortie mais lors d'un autre cycle. Elles ne peuvent donc pas causer de dépendance circulaire.

[center][img]res://dialogue/delay_buffer.png[/img][/center]


=== trans/level_complete_tooltip ===

$33922330743421*
[b]Wire color[/b]
[color=#cccccc][i]Keep your wires organized with colors.[/i][/color]


=== trans/ide_memory_address ===

$94594171568769* [center]Linked components[/center]


=== trans/manual_text_top_the_robot ===

$50801318216470* The screen shows the robot and his surroundings.


=== trans/level_complete_stat_sum ===

$99546064626994* Score


=== levels/delay_level ===

$17854168097855* Check


=== misc/specification_dialogue ===

$54909668901048* Immediate
$92046368194170* Condition
$39935096343723* Never
$52961346176405* {condition} copy [color=#dd6576]REG 0[/color] to counter
$18833529038946* When [color=#2b8738]result[/color] {condition}
$10141348037745* Immediate: {nr}
$98983752580592* Copy
$25145891843959* Always
$53665446068319* UNUSED
$26521666422399* Calculate
$93899425142858* Copy from {from} to {to}


=== trans/level_complete_robot ===

$73150174144736*
[b]Robotron 9000+[/b]
[color=#cccccc][i]Control [color=#e49f44]Robotron 9000+[/color] using your computer[/i][/color]


=== levels/The Product of Nibbles ===

$13549246864135* Bit 0
$10274387271390* Bit 0


=== trans/level_complete_stat_gate ===

$95192766583497* Gate


=== trans/manual_text_assembly ===

$54465324391961*
You can use a mix of assembly codes and numbers to set the bytes. Assembly codes are just synonyms for a bit pattern. For example, instead of typing 196 for "add", this code can be named "add" directly, simplifying reading and writing code. 

Comments can be added using "#". 
[img]dialogue/comment.png[/img]

Additionally, the [color=#c54d5e]CONST[/color] keyword can be used to name a value within a specific program. 
[img]dialogue/const.png[/img]

[color=#c54d5e]LABEL[/color] assigns a name to the byte offset of the line it was inserted on. This is especially useful for naming jump destinations.
[img]dialogue/label.png[/img]

You can add, subtract, multiply, integer divide, modulo, OR, AND or XOR values together using +, -, *, /, %, |, & or ^ respectively.

Breakpoints can be added by clicking to the left of a line number. The program will automatically pause at breakpoints when running.
[img]dialogue/breakpoint.png[/img]

Breakpoints can also be added to any of the linked components, pausing the program when that state is changed. Click on the state and you will see the red dot.
[img]dialogue/breakpoint_state.png[/img]

Finally, values can be specified in binary with the prefix 0b (so 5 could be 0b0101) and hex with the prefix 0x (so 15 would be 0x0f)


=== trans/wire_comment ===

$41481492318983* Wire comment
$87836369268219* Save
$34083666001769* Wire comment


=== ui/global_translations ===

$91472284749011* DELAY
$21803034737442* ick
$86260137015175* TICK
$44906330481241* Delay
$30602804398798* Gate
$22213999385406* delay
$39343770421034* gate
$76763908762578* Tick
$15265492169229* GATE


=== main_scripts/functions ===

$73560327420927* This save is from an obsolete version of this level.\nCreate and load a new schematic in the schematic menu.
$10098517717617* Test: {nr} / {total}


=== trans/manual_delay_text ===

$52013630755752*
In real hardware all components have delay. This is important since the delay in a circuit determines the maximum speed at which you can run it.

Following wires from input to output and adding the delay of components in the path will give you the delay that path. The delay of a circuit is the delay of the slowest path.

Besides inputs, paths can also start from components with no reliance on early phase inputs (like Counter and On) and they can end at late phase inputs (see page).

Further, custom components don't have a delay score for the costliest path of the whole component, but rather the delay cost is calculated per pin. This is so as to not penalize using custom components by making faster pins cost the same as the slower ones.


=== misc/add_assembly_64bit ===

$33233688912123* [center]Add assembly code[/center]


=== misc/files_preview ===

$15827374884671* To parent folder
$14135691870941* Last edit\nSchematics
$32645745463577* Used in components
$19184997172542* Used in architectures
$36200352866864* Last edit


=== trans/manual_text_binary ===

$69488982380310*
The numbers you are used to are base 10, here when we add a 0 to the right hand side of a number, it's value increases 10 fold.

Binary is base 2, so doing the same will instead just double it. In other words, each digit represents a power of 2. For example with [color=#c54d5e]base 2[/color] and [color=#e49f44]base 10[/color] color coded:
[color=#c54d5e]    1[/color] = [color=#e49f44]1[/color]
[color=#c54d5e]  10[/color] = [color=#e49f44]2[/color]
[color=#c54d5e]100[/color] = [color=#e49f44]4[/color]

To represent 6 we can simply add 4 and 2:
[color=#c54d5e]110[/color] = [color=#e49f44]6[/color]

Addition, multiplication and everything else works the same as base 10, except you carry when you reach 2 instead of 10.


=== trans/level_complete_wire_comments ===

$92673421413755*
[b]Wire comments[/b]
[color=#cccccc][i]Add comments to your wires.[/i][/color]


=== trans/binary_racer_count_down2 ===

$23959994711260* Ready to race?


=== nim/backend_lib/level_list ===

$15420972347773* RAM
$26705128002562* Conditions
$70993791338383* XOR


=== trans/schematic_new_folder_name ===

$86236104278688* New folder


=== trans/schematics_menu_visible_label ===

$34084132835354* Visible in menu


=== trans/level_complete_stats ===

$65428404547905* Stats


=== trans/manual_text_bytes ===

$73333514253412*
This game asks you to build an 8 bit computer.  Practically this would normally require the player to put down 8 parallel wire lines in many places.
To alleviate tedious busywork, you are given the notion of a byte, which is just a virtual bundle of 8 bits.

The state of either a byte input / output or wire line is represented by a number, instead of the red or green color.


=== trans/manual_robot_controls ===

$94513149242653* Robot controls


=== main_scripts/input ===

$10186190492148* ALT click to move wire head


=== trans/not_gate_RichTextLabel2 ===

$10340875578771*
[right][color=#e49f44]Input[/color]
Desired output
Current output[/right]


=== trans/manual_text_program ===

$25326551844839*
The program component is a read only memory component, that can have its data programmed in assembly. To edit the assembly, click on the yellow edit icon in the corner of the component.

[center][img]dialogue/manual/program_edit.png[/img][/center]

In the middle of the screen you will see the code area, read more about the assembly [color=#4d82c5][url=Assembly]here[/url][/color].

On the left hand side of the assembly editor interface, you can add assembly codes (mnemonics). Assembly codes act as a replacement for numbers, so instead of remembering what number represents the AND instruction in your architecture, you can add "AND" to your assembly codes, making code easier to read and write.

[center][img]dialogue/manual/assembly_codes.png[/img][/center]

On the program component you will also find the "Watch state" button. 

[center][img]dialogue/manual/watch_state.png[/img][/center]

This can be used to connect the assembly editor to registers, counters or probes. This way, the state of your architecture can be inspected as you write code, without closing the editor.


=== trans/instructions_header ===

$15089281203426* [center]Instructions[/center]


=== trans/manual_text_matrix ===

$75170402412137*
[b]Showing letters[/b]
It just so happens that a pixel space of 5x7 while small is still able to render letters nicely. By adding an extra row and column, these letters will also look nice when put next to each other. 

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]Small tileable screen[/b]
Rotating the component, you get 8x6 pixels, which has a nice 4:3 aspect ratio and tiling these, you can get most resolutions you might want. The way the pins are set up on this component was specifically designed to allow tiling. Imagine the naive pin design where each component is enabled by a single bit. This would require you to connect 1 wire for each component. In this situation, the number of wires needed for a tiled screen would scale with the area, while the gap needed to fit wires between components, would scale with the circumference. 

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

Instead, by having 2 enable pins, one wire can enable a whole row and another a whole column. This way, a single component can be selected by its unique row and column combination. Further, fitting the rest of the data on the same wires, means that the horizontal and vertical gaps only need to be 1 square wide. This component visually takes up half a square extra on all sides, such that these components can be tiled up pixel perfectly, with 1 square hidden between them for running wires.


=== trans/levels_counting_signals_RichTextLabel2 ===

$34604121212779*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== trans/manual_text_top_truth ===

$83283949590490* AND gate


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]Code
Input[/color][/right]


=== ui/schematic_ui/confirm_delete ===

$46014905606975* Yes


=== trans/levels_saving_bytes_text ===

$36838510526259*
[right]Action
Desired state
Desired output
[/right]


=== trans/level_complete_stat_time ===

$39203727515285* Time


=== trans/and_gate_RichTextLabel2 ===

$98472849629373*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_byte_equal_description ===

$38686097566531* [center]Check if the bytes are equal[/center]


=== trans/manual_text_ram ===

$10969790213397*
This simulator has several types of RAM different trade-offs, similar to real life RAM options.

[b]RAM[/b]
The RAM component can store a lot of data, but adds a very high delay to the circuit.

[b]Fast RAM[/b]
The fast RAM has a low delay, but a very high gate cost per byte.

[b]Latency RAM[/b]
The normal RAM has very high delay, however instead of waiting for this delay each tick, we can treat the RAM as if load and save takes multiple ticks. The number of ticks save and load will take depends on the length of each tick. Say for example that our circuit has a delay of 100 units, a load would take 10 ticks, since we have to wait about 1000 units of delay. 

A common approach for pipelined architectures is to use Latency RAM as for main memory, but use a small amount of Fast RAM for caching. Since memory access is often adjacent or close (for example when looping over an array), fetching adjacent values when loading from Latency RAM and caching them in Fast RAM can significantly speed up certain kinds of programs.

The simplest way to integrate the Latency RAM is simply to stall the whole architecture while waiting for a save or load. An easy optimization on this comes from realizing that you don't have to wait for saves, except if you want to load.

[b]Dual Load RAM[/b]
Sometimes it is beneficial to separate parts of the logic into a separate processing unit, that operates more or less independently. This could be for handling a display device or a network connection. In these cases, the independent unit will often need to continuously load and save to memory, while the outside logic only needs to occasionally load. Use Dual Laod RAM to avoid having to schedule who gets access to the RAM at what time.


=== trans/manual_side_the_robot ===

$56547245144983*
[color=#e49f44][b][/b][/color] The robot sees one 
  tile ahead. The name
  and ID are shown up 
  here. This ID number
  is also the computer's 
  input.


=== components/Xnor ===

$94079327237795* XNOR


=== trans/level_decoder_1_RichTextLabel2 ===

$50454539040073*
[right][color=#e49f44]Input[/color]
Output 1
Output 2[/right]


=== trans/levels_double_the_number ===

$41609125516676* [center]Double the number[/center]


=== components/XOR ===

$54832952840086* XOR


=== trans/level_delay_level_description ===

$24326379952614* Create a circuit that costs 5 GATEs and 6 DELAY


=== trans/manual_text_ascii_encoding ===

$57727768059917* This simulator uses (extended) ASCII in a few places. Below are the characters with their corresponding number. The console supports different versions of extended ASCII.


=== trans/level_tick_tock_keys ===

$11700778730606*
[right][color=#e49f44]Action
Desired output
Current output[/color][/right]


=== misc/restore_overture ===

$52008982212566* Reset


=== trans/level_complete_manual_page ===

$39011561067359*
[b]Manual Entry[/b]
[color=#cccccc][i]RTFM[/i][/color]

Entry: [color=#68d277]Architectural complexity[/color]


=== trans/credit_header ===

$21717110565858* Credits


=== trans/level_spacial_invasion_description ===

$44980627299841* [center]Shoot the space rats![/center]


=== trans/_second_tick_RichTextLabel2 ===

$11680718497014*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_complete_level_map ===

$20801641140962*
[b]Level map mode[/b]
[color=#cccccc][i]Click "[color=#e49f44]Onwards[/color]" and you will see[/i][/color]


=== trans/nand_values ===

$38006065064488*
[right][color=#e49f44]Input 1
Input 2[/color]
[b]Output[/b][/right]


=== trans/level_complete_stat_level ===

$92313038380926* Level


=== trans/manual_text_short_circuit ===

$31105471890701*
In electronics, two components outputting different values on the same wire causes a short circuit.

[center][img=100]res://dialogue/short_circuit.png[/img][/center]

However, by disconnecting output pins from a wire, it is possible for multiple pins to share the same wire (called a bus). Importantly, at most 1 component output should remain connected each tick, otherwise you risk a short circuit.

[center][img]res://dialogue/switch.png[/img][/center]

In this simulator, pins that can be disconnected are grey.


=== misc/opcode_name ===

$15090156481094* Name


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== levels/ram_block ===

$16196915566111* 0
$14259545926196* A
$12933801309767* A


=== components/ON ===

$95896157427528* ON


=== trans/level_compute_xor_description ===

$61886892927185* [center]Pairwise AND together each bit[/center]


=== trans/level_signed_negator_description ===

$87777776285772* [center]Invert the sign of the number[/center]


=== trans/xor_gate_RichTextLabel2 ===

$21417732641222*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== main_scripts/overture_level ===

$11338791453100* Dynamic

#  "cond" is for condition, this label has to be short as it has to fit on a component
$94982725578534* COND
$16914143080303* Copy
$59042824277105* Immediate
$82949244692745* Calculate


=== levels/negative_numbers ===

$62744038163781* OK


=== trans/nand_Label2 ===

$60885816586685* Output


=== trans/levels_negative_header ===

$82195103144851* [center]Requirements[/center]


=== trans/always_on_RichTextLabel2 ===

$86547293707045*
[right][color=#ffa502]Input[/color]
Desired output
Current output[/right]


=== trans/tooltip_tooltip ===

$48829429502039*
[b]Run fast[/b]
[color=#cccccc][i]Run your computer without updating the UI at each tick[/i][/color]


=== trans/delete_confirm ===

$57294448765637*
Are you sure you want 
to delete this schematic?
$74657548486940* Yes


=== components/Off ===

$61860786587357* OFF


=== trans/level_constants_description ===

$34641396464207* [center]Add constant loading to your architecture[/center]


=== levels/circular_dependency ===

$16336401898647* Test 1/2


=== trans/levels_bytw_or_text ===

$21877344150481*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== misc/overture_add_assembly ===

$10565133223872* Never
$62421757655527* Name a code and click save.
$24281479096246* When [color=#2b8738]result[/color] {condition}
$63525237058165* Copy from {source} to {destination}
$32873193471770* UNUSED
$88446594314360* Immediate: {number}
$94278717238239* Always
$79398554520691* {opcode} {reg_1} and {reg_2}
$72740868980397* {condition} copy {register} to counter


=== trans/level_unseen_fruit_description ===

$96313037592447* [center]Use the robot to scan the fruit[/center]


=== components/NOR ===

$83375115196253* NOR


=== trans/manual_Cyclic recipes ===

$45682345144408* Circular recipes


=== levels/hex_racer ===

$33474352861351* Level {x}
$40775762006843* Wrong answer


=== trans/manual_send_otuput_robot ===

$65542429897149* [center]Send output to control the robot[/center]


=== trans/level_full_adder_RichTextLabel2 ===

$25766177620842*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== trans/instructions_the_robot ===

$26621808961883*
[color=#e49f44]0[/color] Move right
[color=#e49f44]1[/color] Move down
[color=#e49f44]2[/color] Move left
[color=#e49f44]3[/color] Move up
[color=#e49f44]4[/color] Enjoy the moment
[color=#e49f44]5[/color] Use action [color=#a9a9a9](enter)[/color]
[color=#e49f44]6[/color] Shoot laser [color=#a9a9a9](tab)[/color]


=== trans/nor_gate_RichTextLabel2 ===

$52955821161579*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== components/NAND ===

$71130919681688* NAND


=== trans/level_binary_search_description ===

$11976224688780* [center]Recover the passcode[/center]


=== trans/level_complete_level_complete ===

$49647690443210* [center]Level Complete[/center]


=== trans/or_gate_RichTextLabel2 ===

$56663370211115*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== levels/delay_level_check ===

$59355217078543* Correct!
$68999077595244* Check
$90847326020954* Nope!


=== trans/odd_number_error ===

$61530231182650* Too many components used


=== trans/level_binary_programming_description ===

$66247694103179* [center]Add 5 to the input[/center]


=== misc/program_edit ===

$57861256694537* Bytes {bytes_from} - {bytes_to}


=== trans/level_component_factory_Label2 ===

$37347658035959* Component preview


=== trans/or_gate_3_RichTextLabel2 ===

$56903547636751*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== trans/manual_text_edit_instructions ===

$75786562031150*
After you complete the level "Turing Complete" the instruction panel allows you to manually edit instructions. This is useful if you wish to build your own computers.

If you just finished the OVERTURE computer and see something weird, odds are you may have changed the definitions.

Each row has a label and 8 bits you can set to either[img]dialogue/on.png[/img], [img]dialogue/off.png[/img] or [img]dialogue/any.png[/img] (wildcard). When using the instruction panel, if the bitpattern matches a row, the label will be shown.


=== trans/not_gate_click_next2 ===

$20820887361993* Click "Next tick" to see


=== main_scripts/levels ===


#  Level type for the level complete menu
$58769207148712* Component

#  Level type for the level complete menu
$90134890578411* Misc

#  Level type for the level complete menu
$69219742310717* Architecture


=== levels/binary_count_down ===

$56999237564848* {x} seconds left


=== trans/level_wide_instructions_description ===

$60538893544456* [center]Build a wide instruction program component[/center]


=== trans/ide_assembly_codes ===

$62016169253008*
[center]Assembly
codes[/center]


=== trans/manual_text_turing_complete ===

$54897112350567*
Certain computers, like simple calculators are limited in the algorithms they can perform.

They cannot perform any calculation that requires looping or recursing an arbitrary amount of times. Technically machines without looping or recursion can only deal with combinational logic.

Turing complete machines on the other hand are as powerful as it is possible to be. A Turing complete machine may have a slow CPU, but it is powerful in the sense that there is no (computable) algorithm it can't perform.


=== misc/specifications ===

$56390619785555* View instructions definitions
$68054407020318* Instructions


=== trans/manual_component_factory_text ===

$42847481618884*
Open the component factory by clicking on this button [img]dialogue/manual/component_factory_icon.png[/img] in the upper left bar.

The component factory allows you to create your own components. The logic you place determine the behavior of the custom component and the layout determines the shape. 

The input and output components you place become pins on the component. Like with other components, a component output leading back to its input causes a circular dependency. Outputs having a path back to inputs causes a circular dependency for custom components, even if the insides of the component would suggest there shouldn't be one. Not having to worry about the inside of components reduces the complexity of larger builds, however this strict abstraction can be inconvenient under certain circumstances. In that case, use the unbuffered pins. They allow bidirectional flow and use the insides of the component to check for circular dependencies.

Probes placed in custom components will show on their layout and can display values inside. Probes can be connected to other custom components, so that deeply nested values can be displayed. Values probed in this way can also be connected to the program component.

For the component factory, the file manager also manages the custom components. The file names decide the component name and the folder structure decides the components placement in the menu.


=== trans/level_decodre_RichTextLabel2 ===

$40723962298647*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired bit
Current bit[/right]


=== trans/manual_bytes ===

$46223559629673* Bytes


=== trans/level_complete_stat_delay ===

$43118901497406* Delay


=== levels/binary_start ===

$19099025738142* Start


=== trans/level_byte_adder_you_carry_text2 ===

$87943759248740* Carry


=== levels/negative_numbers/test ===

$64427417171037* Test


=== trans/manual_edit_instructions ===

$86365051641280* Edit instructions


=== trans/level_byte_xor_text ===

$15756501406553*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== trans/level_byte_constant_description ===

$84789919073603* [center]Always output the number 164[/center]


=== trans/manual_text_network ===

$70445160410129*
[b]Overview[/b]
The "Network" component gives you low level access to networking. In general you manipulate your network by sending the component [color=#e49f44]Requests[/color] and when update [color=#39aa49]Events[/color] return from the network they get queued up and you process them one at a time. To keep track of different simultaneous connections [color=#dd6576]Connection ID[/color]s are used.

These are the request types you can send to the component and their arguments:
[code]0[/code] No request
[code]1[/code] [color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])
[code]2[/code] [color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])
[code]3[/code] [color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])
[code]5[/code] [color=#e49f44]Read next event[/color]
[i]See component panel for which pin correspond to which argument.[/i]

Request types [color=#e49f44]Listen[/color] and [color=#e49f44]Connect[/color] outputs the [color=#dd6576]Connection ID[/color] of the new connection.

For 2 programs to [color=#e49f44]Send data[/color] to each other, one program must first [color=#e49f44]Listen[/color] (called a server) on a [color=#dd6576]Port[/color] and the other must then [color=#e49f44]Connect[/color] (called a client), using the [color=#dd6576]IP[/color] of the listening program and the [color=#dd6576]Port[/color] it selected. Once the connection is established, the server and client function exactly the same.

Notice an [color=#dd6576]IP[/color] is a 32 bit number, normally written as 4 bytes with dots in between (example: 127.0.0.1). In this simulator you reverse the order of the bytes, so 127.0.0.1 becomes 0x0100007F. 0x0100007F is always your computers loopback address and you can use this to connect programs running on the same computer.

You can detect when events happen on the network, by checking the "Next event type" pin. These are the event types:
[code]0[/code] No event
[code]1[/code] [color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])
[code]2[/code] [color=#39aa49]Connect complete[/color]
[code]3[/code] [color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])

[color=#39aa49]Incoming connection[/color] only happens after a [color=#e49f44]Listen[/color]. Use the [color=#dd6576]Port[/color] to distinguish between listeners (it is not possible to listen to the same port twice at the same time).

[color=#39aa49]Connect complete[/color] only happens after a [color=#e49f44]Connect[/color], wait for this before you start sending data.

You may send or receive between 1 and 8 bytes of data at a time, use the [color=#dd6576]Data length[/color] to decide.

A connection may be either "possibly open" or "closed". There is no way to know if a connection is actually open other than sending data. The underlying network protocols were designed like this for reliability and speed, it is not a limitation of the simulator.

If you get a [color=#dd6576]Connection ID[/color] of -1, this means there was an error connecting.


=== misc/binary_submit ===

$95509904060545* Submit


=== trans/level_alu2_code ===

$93157894815498* [center]OR[/center]


=== trans/and_gate_3_RichTextLabel2 ===

$52008707927408*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== trans/level_complete_ide ===

$56719825235196*
[b]CODE IDE[/b]
[color=#cccccc][i]Name codes and edit them in a convenient editor[/i][/color]


=== trans/level_bit_switch_RichTextLabel2 ===

$57920867194992*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/levels_negative_descriptions ===

$87964635915702*
-127 to 127 representable:
0 to 127 same as before:
Works with adder:


=== trans/level_decoder_description ===

$10169248860836* [center]Decode the instruction[/center]


=== nim/backend ===

$98703677236827* 1 minute ago
$86244493049244* {hours} hours ago
$95018143828198* 1 year ago
$21685594109067* Just now
$98363990684104* 1 hour ago
$84076931764831* 1 day ago
$18300496139706* 1 month ago
$17901039729248* {months} months ago
$42553566189409* {minutes} minutes ago
$70945526841433* {years} years ago
$14036822471924* {days} days ago


=== trans/instructions_hint ===

$65105856275770* [center][color=#c5c5c5]Click to toggle the bits[/color][/center]


=== trans/schematics_description ===

$39347262933523* Description


=== trans/level_component_factory_error ===

$49014901714855* Map squares can only contain one input or output node.


=== trans/level_complete_stat_type ===

$69511102367948* Type


=== components/NOT ===

$34453052824732* NOT


=== trans/nand_Label ===

$11482037025960*
Input 1


Input 2


=== trans/level_ram_component_RichTextLabel2 ===

$92123299522120* [center]Expected states[/center]


=== trans/level_double_buffer_RichTextLabel3 ===

$27208335953837*
[right]Input
Desired output
Current output[/right]


=== components/DivMod32 ===

$61314390474120* Divide and mod 2 numbers
$84309999871615* Divide


=== trans/level_registers_code ===

$40063003736243* [center]OR[/center]


=== trans/manual_text_truth ===

$16559670174521*
The tables of input and output which are used everywhere throughout the game are commonly known as truth tables.








"Input" and "Output" will often be represented with variable names, like in algebra. And instead of using colors, you will often see the values represented as 0 / 1 or False / True.


=== trans/manual_text_rgb ===

$52915933943906*
This simulator uses 3 byte RGB colors for some components. Color are 1 byte each, the byte value determining the intensity of each color: 
[color=#e3243f]RRRRRRRR[/color][color=#55ff55]GGGGGGGG[/color][color=#3333ff]BBBBBBBB[/color]


=== trans/manual_text_terminology ===

$99266452352883*
[b]Instruction[/b]
A byte or a few bytes that together make the computer perform a specific action.

[b]Opcode[/b]
The part of the instruction that determines which operation (like ADD or AND) is to be done.

[b]Memory address[/b]
A number used as a name for memory locations (often for registers). These are used to specify where an instruction is supposed to load data from or save data to.

[b]Jump[/b]
Changing the value of the program counter, changing which instruction is loaded next.


=== trans/level_complete_hex ===

$94261690850981*
[b]Hexadecimal[/b]
[color=#cccccc][i]Toggle between signed, unsigned and hex numbers[/i][/color]


=== misc/instruciton_rule_label ===

$70464083627337* Label


=== trans/complete_unlocks ===

$45250062735373* Unlocks


=== components/DivMod8 ===

$37666366877853* Divide and mod 2 numbers
$44959426271423* Divide


=== trans/level_byte_mux_description ===

$20538476756633* [center]Output the correct input byte[/center]


=== trans/level_byte_less_i_description ===

$21195810950441* [center]Determine if the first input is less than the second.[/center]


=== trans/level_the_bus_description ===

$20464862486158* [center]Copy the value from the correct input, to the correct output[/center]


=== trans/level_complete_gate ===

$99373213759665*
[b]Gate score[/b]
[color=#cccccc][i]You can now view the gate score of  wires and components.[/i][/color]


=== components/ByteEqual ===

$35668435514829* Checks if the two inputs are equal
$39369982838671* Equal


=== trans/level_RichTextLabel2 ===

$12683441099336*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== trans/level_program_description ===

$44017405175202* [center]Replace the input code with the program component.[/center]


=== levels/binary_racer ===

$29718660090112* Wrong answer
$37093663674348* Level {x}


=== trans/level_byte_or_text ===

$99465606386164*
[right]
[color=#e49f44]Input[/color]
Desired output
Current output
[/right]


=== trans/level_odd_ticks_RichTextLabel3 ===

$89508766742523*
[right]Input
Desired output
Current output[/right]


=== trans/level_complete_profile ===

$78783902500954*
[b]Online profile[/b]
[color=#cccccc][i]Find it in the main menu.[/i][/color]


=== components/SRLatch ===

$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== trans/manual_text_universal_gates ===

$37735744928195*
It turns out that you can build all the logic for a computer out of either NAND or NOR gates. The Apollo guidance computers, were built entirely of NOR gates. Designed in the sixties, they had only 4KB of RAM and 32KB of disk space, but guided astronauts to the moon nonetheless.

Modern computers are not built entirely of just one of the universal gates, but when applicable NAND gates are preferred over NOR, because they have less delay and occupy less area.


=== trans/instrucitons_header ===

$14831276667273* [center]Instructions[/center]


=== trans/levels_byte_or_description ===

$68379799788575* [center]Pairwise OR together each bit[/center]


=== trans/manual_instructions ===

$90323246286028* Instructions


=== trans/level_dependency_description ===

$81238724438578* Make a wire where the input of a component depends on its own output


=== trans/schematic_new_file_name ===

$24424463568668* New schematic


=== trans/level_alu1_code ===

$20619700446604* [center]OR[/center]


=== levels/the_bus ===

$96958133516462* FROM
$91318587712792* TO


=== misc/skipped_custom ===

$38174137226538* Select component

#  This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728* Go to location


=== trans/level_bit_adder_RichTextLabel2 ===

$79624864981341*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== misc/add_code_name ===

$57358078712675* Save


=== components/DivMod16 ===

$42657221816637* Divide and mod 2 numbers
$22319923069746* Divide


