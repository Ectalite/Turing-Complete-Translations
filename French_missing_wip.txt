=== trans/level_wide_instructions_description ===

$60538893544456 [center]Construis un composant programme pour les instructions larges[/center]


=== schematics_hub/accept_license ===

$72317516399185 Accepte d'utiliser la licence [color=#dd6576][url=cc0]CC0[/url][/color]


=== trans/panel_hdd_input ===

$99603056559749
[right]Rechercher
Lire
Ecrire
Ecrire valeur[/right]


=== misc/network_update ===

$40010486743721 [center][color=#dd6576]Echec du transfert[/color][/center]
$70619187943439 Createur\Transmis
$83560387278127 Dérivé de : 
$76023068123024 Erreur
$81675147704214 Utilise le composant réseau
$98151734218561 [center][color=#60a96b]Téléchargement terminé.[/color][/center]
$47639082058046 Rien ici pour l'instant


=== trans/manual_component_factory_text ===

$42847481618884*

Open the component factory by clicking on this button [img]dialogue/manual/component_factory_icon.png[/img] in the upper left bar.

The component factory allows you to create your own components. The logic you place determine the behavior of the custom component and the layout determines the shape. 

The input and output components you place become pins on the component. Like with other components, a component output leading back to its input causes a circular dependency. Outputs having a path back to inputs causes a circular dependency for custom components, even if the insides of the component would suggest there shouldn't be one. Not having to worry about the inside of components reduces the complexity of larger builds, however this strict abstraction can be inconvenient under certain circumstances. In that case, use the unbuffered pins. They allow bidirectional flow and use the insides of the component to check for circular dependencies.

Probes placed in custom components will show on their layout and can display values inside. Probes can be connected to other custom components, so that deeply nested values can be displayed. Values probed in this way can also be connected to the program component.

For the component factory, the file manager also manages the custom components. The file names decide the component name and the folder structure decides the components placement in the menu.


=== trans/level_complete_ide ===

$56719825235196
[b]IDE CODE[/b]
[color=#cccccc][i]Nomme les instructions et édite les programmes dans un éditeur pratique[/i][/color]


=== levels/byte_mux ===

$15428393549821 CHOISIR


=== trans/level_byte_constant_description ===

$84789919073603 [center]Envoie toujours en sortie le nombre 164[/center]


=== trans/manual_text_network ===

$70445160410129*
[b]Overview[/b]
The "Network" component gives you low level access to networking. In general you manipulate your network by sending the component [color=#e49f44]Commands[/color] and when update [color=#39aa49]Events[/color] return from the network they get queued up and you process them one at a time. To keep track of different simultaneous connections [color=#dd6576]Connection ID[/color]s are used.

These are the command types you can send to the component and their arguments:
[code]0[/code] No command
[code]1[/code] [color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])
[code]2[/code] [color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])
[code]3[/code] [color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])
[code]5[/code] [color=#e49f44]Read next event[/color]
[i]See component panel for which pin correspond to which argument.[/i]

Command types [color=#e49f44]Listen[/color] and [color=#e49f44]Connect[/color] outputs the [color=#dd6576]Connection ID[/color] of the new connection.

For 2 programs to [color=#e49f44]Send data[/color] to each other, one program must first [color=#e49f44]Listen[/color] (called a server) on a [color=#dd6576]Port[/color] and the other must then [color=#e49f44]Connect[/color] (called a client), using the [color=#dd6576]IP[/color] of the listening program and the [color=#dd6576]Port[/color] it selected. Once the connection is established, the server and client function exactly the same.

Notice an [color=#dd6576]IP[/color] is a 32 bit number, normally written as 4 bytes with dots in between (example: 127.0.0.1). In this simulator you reverse the order of the bytes, so 127.0.0.1 becomes 0x0100007F. 0x0100007F is always your computers loopback address and you can use this to connect programs running on the same computer.

You can detect when events happen on the network, by checking the "Next event type" pin. These are the event types:
[code]0[/code] No event
[code]1[/code] [color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])
[code]2[/code] [color=#39aa49]Connect complete[/color]
[code]3[/code] [color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])

[color=#39aa49]Incoming connection[/color] only happens after a [color=#e49f44]Listen[/color]. Use the [color=#dd6576]Port[/color] to distinguish between listeners (it is not possible to listen to the same port twice at the same time).

[color=#39aa49]Connect complete[/color] only happens after a [color=#e49f44]Connect[/color], wait for this before you start sending data.

You may send or receive between 1 and 8 bytes of data at a time, use the [color=#dd6576]Data length[/color] to decide.

A connection may be either "possibly open" or "closed". There is no way to know if a connection is actually open other than sending data. The underlying network protocols were designed like this for reliability and speed, it is not a limitation of the simulator.

If you get a [color=#dd6576]Connection ID[/color] of -1, this means there was an error connecting.


=== trans/panel_keyboard_left ===

$44556588975494 [right]Lire la suite[/right]


=== trans/panel_decoder2_description ===

$29468245669811 [center]Active 1 des sorties en fonction de l'entrée[/center]


=== trans/program_data_width ===

$72687692653533
[right]Largeur de Données :
[/right]


=== trans/manual_sprite_display ===

$28358052747011*
The sprite screen is a 640x480 pixel sprite display. Before using the sprite screen, you first need to attach a sprite map, which is a PNG image that contains all your sprites. Click on the component and set the sprite map in the component panel.

The first input pin is the [color=#e49f44]Command type[/color], the meaning of the next 3 pins depends on the command type as shown below. The sprite ID is always a 8 bit number and all other values (position and size) are always pairs of 16 bit values.

[table=2]
[cell]0[/cell] [cell]No command[/cell]
[cell]1[/cell] [cell][color=#e49f44]Load sprite[/color] (Sprite ID, Position, Size)[/cell]
[cell][/cell][cell][i]Sets the sprite of this ID. The position is the upper left corner of the sprite map.[/i][/cell]
[cell]2[/cell] [cell][color=#e49f44]Set position[/color] (Sprite ID, Position)[/cell]
[cell][/cell][cell][i]This sets the X and Y coordinate of the loaded sprite.[/i][/cell]
[/table]

[center][img=300]dialogue/manual/sprite_screen.png[/img][/center]

Note that sprites are layered in the order of their ID and to remove a layer, simply load a sprite with a width and height of 0.


=== trans/level_robot_racing_description ===

$67533273328897
Déplace le robot le long de la piste
Utilise le programme le plus court possible


=== nim/backend ===

$64492620873138 Sortie toujours activée
$98703677236827 il y a 1 minute
$86244493049244 il y a {hours} heures
$95018143828198 il y a un an
$21685594109067 a la minute
$91048993146856 Enregistrer
$98363990684104 il y a une heure
$84076931764831 il y a un jour
$58374689721038 OCTETS
$88592386859564 (Plus mauvais test : {worst_trial})
$18300496139706 il y a 1 mois
$17901039729248 il y a {months} mois

#  This is a file name
$96230605270081 nouveau_programme
$82336838435736 Charger
$42553566189409 il y a {minutes} minutes
$70945526841433 il y a {years} ans
$81432548841957 (First test scored)
$14036822471924 il y a {days} jours
$18816732910302 Enregistrer la valeur


=== rpg/maps/prison/rat ===

$68894472933139 Squeak squeak
$86305699756314 Sang
$30670667527598 Rat


=== trans/instructions_hint ===

$65105856275770 [center][color=#c5c5c5]Clique pour changer les bits[/color][/center]


=== misc/tests_run_all ===

$55533125021199 Lancer tout


=== trans/assembly_editor_header ===

$14116831487331 Editeur Assembleur


=== misc/menu_schematic_hub ===

$13921098180953 Ecran des schémas


=== components/DivMod32 ===

$61314390474120 Divise et calcule le modulo 2 des nombres
$84309999871615 Divise


=== trans/manual_text_truth ===

$16559670174521
Les tables des entrées et sorties qui sont utilisées partout dans le jeu sont appelées des tables de vérité.








L'"Entrée" et la "Sortie" seront souvent représentées avec des noms de variable, comme en algèbre. Et au lieu d'utiliser des couleurs, tu verras souvent les valeurs représentées sous forme de 0 / 1 ou Faux / Vrai.


=== trans/hub_stats ===

$30942143953871 Utilisateur


=== trans/panel_equal_description ===

$66334667083051 [center]Vérifie que les Entrées 1 et 2 sont identiques[/center]


=== trans/level_the_bus_description ===

$20464862486158 [center]Copie la valeur de la bonne entrée vers la bonne sortie[/center]


=== dialogue/schematic_hub ===

$22639280459994 Téléchargement de la liste...


=== trans/level_complete_hex ===

$94261690850981
[b]Hexadecimal[/b]
[color=#cccccc][i]Bascule les nombres entre les formats signés, non signés et hexa[/i][/color]


=== trans/manual_text_terminology ===


# DateCustoms
$99266452352883*
[b]Instruction[/b]
A byte or a few bytes that together make the computer perform a specific action.

[b]Opcode[/b]
The part of the instruction that determines which operation (like ADD or AND) is to be done.

[b]Memory address[/b]
A number used as a name for memory locations (often for registers). These are used to specify where an instruction is supposed to load data from or save data to.

[b]Jump[/b]
Changing the value of the program counter, changing which instruction is loaded next.


=== trans/hub_order_by ===

$83319579232915 Trié par


=== dialogue/schematic_hub/delete_confirm ===

$71921976503347 Oui
$46660924781254
Es tu sûr de vouloir
supprimer le schéma nommé '{name}' ?


=== trans/manual_text_matrix ===

$75170402412137*
[b]Showing letters[/b]
It just so happens that a pixel space of 5x7 while small is still able to render letters nicely. By adding an extra row and column, these letters will also look nice when put next to each other. 

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]Small tileable screen[/b]
Rotating the component, you get 8x6 pixels, which has a nice 4:3 aspect ratio and tiling these, you can get most resolutions you might want. The way the pins are set up on this component was specifically designed to allow tiling. Imagine the naive pin design where each component is enabled by a single bit. This would require you to connect 1 wire for each component. In this situation, the number of wires needed for a tiled screen would scale with the area, while the gap needed to fit wires between components, would scale with the circumference. 

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

Instead, by having 2 enable pins, one wire can enable a whole row and another a whole column. This way, a single component can be selected by its unique row and column combination. Further, fitting the rest of the data on the same wires, means that the horizontal and vertical gaps only need to be 1 square wide. This component visually takes up half a square extra on all sides, such that these components can be tiled up pixel perfectly, with 1 square hidden between them for running wires.


=== rpg/maps/overworld/blankidork ===

$19291766514049 Nous combattons la rébellion


=== rpg/maps/overworld/gruliette ===

$83120363112787 Oh salut beau gosse
$61022705156373
Oh mon dieu non, j'ai fini
cette quête
$84856635901648 IHHHhhhh mon cœur fond !
$16008092188500 Gruliette
$58406047748371
Seulement s'il peut m'apporter
une fleur rose
$18919563572338
Veux-tu aller
à un rendez-vous avec Dumio ?
$68101445990611 Voici la fleur rose
$68725679456014
*schmuck* apporte ce baiser
à Dumio pour mo
$73977053028689 Oh salut beau gosse
$50949692384224 Mes oreilles me font mal
$35813418867082 C'est au hasard


=== trans/manual_text_universal_gates ===

$37735744928195*
It turns out that you can build all the logic for a computer out of either NAND or NOR gates. The Apollo guidance computers, were built entirely of NOR gates. Designed in the sixties, they had only 4KB of RAM and 32KB of disk space, but guided astronauts to the moon nonetheless.

Modern computers are not built entirely of just one of the universal gates, but when applicable NAND gates are preferred over NOR, because they have less delay and occupy less area.


=== trans/panel_fileloader_description ===

$72892007399429*
The file rom outputs the content of a file 8 bytes at a time.

The highest 64 bit address (0xFFFFFFFFFFFFFFFF) is special and outputs the length of the file in bytes.


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]Code
Input[/color][/right]


=== trans/level_negative_Label ===

$11951041502381* Change what each bit means by changing the numbers.


=== misc/component_button ===

$20148770258379* No component area
$53184531022842* Sandbox only
$40492377880609* Pins overlap


=== trans/level_byte_equal_description ===

$38686097566531 [center]Vérifie si les octets sont égaux[/center]


=== rpg/maps/prison/sign_1 ===

$88221977354540 Panneau
$74189085130186
Ca dit : Le bouton ouvre
les portes de la prison



=== levels/byte_nand ===

$76462832199594* Create a circuit that NANDs two bytes bitwise.


=== trans/panel_index_bit_index ===

$96885367697181 [right]Index[/right]


=== components/Clock ===

$29674337035619* Placing the clock will divide ticks into 2 phases. The clock is [OFF] in the early phase and [ON] in the late phase. All memory components load in the early phase and save in the late phase.
$73207565196164 Horloge


=== trans/panel_output_output_3 ===

$94657695889458 Sortie 4


=== trans/levels_byte_or_description ===

$68379799788575* [center]Pairwise OR together each bit[/center]


=== dialogue/dotMatrixtext_link ===

$82486902873499*
The color pin uses byte 2, 3 and 4 for [color=#dd6576][url=RGB color]RGB color[/url][/color] (byte 1 is unused)
The pixel pin uses byte 2, 3, 4, 5, 6 and 7 for selecting pixels to be colored, where each bit corresponds to a pixel. Updates are only visible once byte 8 is set to 1, this "flushes" the changes and updates the display visually.

Both "Enable X" and "Enable Y" have to be on to update the display.


=== trans/panel_divmod_input ===

$48801764966719
[right]Enumérateur
Diviseur[/right]


=== rpg/maps/overworld/reactor_entry ===

$81583424078503 Orifice d'échappement


=== trans/panel_sound_command ===

$66510191984141 Commande


=== trans/panel_network_input_description ===

$36399689035136*
[b][color=#e49f44]Request type[/color] (arguments)[/b]
[code]0[/code] No request
[code]1[/code] [color=#e49f44]Listen[/color] (Port)
[code]2[/code] [color=#e49f44]Connect[/color] (IP, Port)
[code]3[/code] [color=#e49f44]Send data[/color] (Connection ID, Data, Data length)
[code]4[/code] [color=#e49f44]Close[/color] (Connection ID)
[code]5[/code] [color=#e49f44]Read next event[/color]


=== trans/level_spacial_invasion_description ===

$44980627299841 [center]Tire sur les rats de l'espace ![/center]


=== misc/add_code_name ===

$57358078712675 Enregistrer


=== misc/skipped_custom ===

$38174137226538 Choisir le composant

#  This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728 Voir l'emplacement


=== misc/save_schematic ===

$36331525379247 Enregistrer ce schéma


