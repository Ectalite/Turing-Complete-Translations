=== components/Output 1 ===

$12242923444593* Sortie


=== levels/RAM ===

$17967666262990* Dans ce niveau, copie d'abord 32 valeurs et sauvegarde chacune d'elle. Après les avoir sauvegardées, envoyez-les vers la sortie dans l'ordre d'arrivée. Envoyer une valeur vers la sortie avant d'avoir stocké toutes les valeurs te fera perdre le niveau. 
$13520918982355* Ajoute un bloc de RAM, ainsi l'ordinateur aura 256 octets de mémoire en plus. Tu dois trouver un moyen d'accéder à un octet indépendamment des autres. Indice : nous utiliserons un registre pour choisir l'adresse de la RAM, ainsi si tu veux sauvegarder ou charger une valeur, tu pourras indiquer l'adresse dans ce registre.


=== levels/byte_less_i ===

$16755383054285* [center]Détermine si la première entrée est plus petite que la seconde.[/center]
$19006843777401* Crée un circuit qui sortira [ON] quand la première entrée est plus petite que la seconde. Interpréte les octets comme étant [color=#dd6576]SIGNES[/color].
$46083799633716* {input\_1} est plus petit que {input\_2}?


=== trans/level_registers_description ===

$73800316874022* [center]Construis le circuit qui correspond au code demandé[/center]


=== components/Output1Car ===

$12896765714603* Retenue


=== trans/level_circumference_description ===

$20154743351442* [center]Ajoute les conditions aux codes de calcul[/center]


=== components/FullAdder ===

$57559382166174* Additionne 3 bits et sort la somme et la retenue
$77669928463861* Additionneur complet


=== misc/options ===

$49251062339706* Options


=== misc/ide_delete_program ===

$87279416580516* Oui


=== levels/turing_complete ===

$15326252036920* Jusqu'à maintenant, le code pouvait seulement influencer la mémoire. Maintenant la mémoire doit pouvoir influencer le code. Avec l'ajout de la logique conditionnelle, ton ordinateur va pouvoir faire tourner n'importe quel algorithme et pourra tout calculer.
$16583885726240* Bravo, tu as réussi ! Je pensais juste que t'étais un singe bizarre, pas poilu, mais t'as réussi à créer un vrai ordinateur ! INCROYABLE ! 
$10510746154639* Au premier cycle, le programme devrait charger l'adresse 1.
$10317244906317* Aucun programme trouvé.
$14587485007736* Jusqu'à maintenant, les programmes étaient limités à tourner dans l'ordre dans lequel ils étaient écrits, octet par octet.
$19649119273248*
La dernière chose que l'on doit rajouter est un mécanisme pour changer le compteur de programme avec des [INSTRUCTIONS] quand certaines conditions sont respectées.

Quand les deux deux bits les plus importants sont à [ON][ON], alors l'ordinateur sera en mode conditionnel. Dans ce mode, la valeur du registre 3 sera comparée avec une condition définie par les 3 bits les moins importants. Si la condition est vraie, le programme compteur prendra alors la valeur du registre 0.
Grâce à ce nouveau mode, tu pourras maintenant créer des boucles et sauter une ou plusieurs [INSTRUCTIONS].

Conditions:
[OFF] [OFF] [OFF] Jamais
[OFF] [OFF] [ON] Si [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] Si [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [OFF] [OFF] Toujours
[ON] [OFF] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [ON] [OFF] Si [color=#e49f44]REG 3[/color] ? 0
[ON] [ON] [ON] Si [color=#e49f44]REG 3[/color] > 0

Ces conditions correspondent au composant que tu as sauvegardé dans l'atelier de composants.


=== components/Input 1 ===

$12746117288689* Entrée


=== components/Neg16 ===

$17253409670931* Inverser
$57512333327652* Inverser l'entrée bit à bit


=== levels/Second Tick ===

$14355963067874* Activer la sortie au second cycle d'horloge.
$17526582195506* Comme tu sais ces tests visent à réaliser un ordinateur qui fonctionne.
$15726318553190* C'est ce qui explique que tu ne seras pas mangé à la fin.
$19277843280528*
 [color=#b72d41][b]TIP:[/b][/color] 
 Tu peux sélectionner un composant et ses pattes en double-cliquant dessus
$15296208528991* Les espèces capables de finir sont considérées comme légalement intelligentes.


=== trans/manual_text_console ===

$39093856809104*
Le composant terminal est un écran [color=#dd6576][url=RGB color]ASCII[/url][/color] couleur 80x24. Il doit être associé à une source mémoire à l'aide du bouton composant lié :
 [img=200]dialogue/manual/Console/link_state.png[/img]

Les modifications de la mémoire liée permettent de modifier le contenu du terminal. Dans le mode monochrome standard, chaque octet correspond à un caractère de l'écran. Cependant, la position du premier caractère peut être décalée en fonction de l'entrée du terminal. Cela permet par exemple d'implémenter le défilement.

Le terminal a aussi un mode couleur qui peut être activé sur le panneau :
[img=125]dialogue/manual/Console/color_mode.png[/img]

Dans ce mode chaque caractère est associé en plus à 2 groupes de 3 octets pour les [color=#dd6576][url=RGB color]couleurs RVB[/url][/color] de fond et de texte. Attention les caractères sont alignés sur 8 octets ce qui est plus pratique quand l'adressage de ta ROM ou RAM est en 64 bits. De plus, l'index peut rester le même dans les deux modes en passant la largeur de bande mémoire de 8 à 64 bits. 

Dans le mode couleur l'octet de poids faible est le caractère, les 3 octets suivants forment la couleur du texte et les 3 suivants la couleur de fond.


=== levels/component_factory ===

$14665712485657* Ce composant personnalisé ne peut pas être utilisé car il n'a aucune surface.
$17077079648771* Des composants peuvent être ajoutés, renommés ou supprimés en utilisant le système de sauvegarde du niveau.
$19551383617326*
Bienvenue dans l'atelier de composants, les schémas que tu crées ici pourront être utilisés comme composants dans les niveaux d'architecture.
Le composant importé aura le même comportement et son schéma définira sa forme.
$12516102012088* Ce composant n'a pas de forme définie et ne pourra pas être réutilisé. Placer des composants sur la carte pour définir sa forme.
$14712417427860* Comme ce niveau est un outil et pas un défi, tu peux revenir à la carte des niveaux pour continuer quand tu voudras.
$15549447390000* 2 composants d'entrée/sortie sont dans la même zone. Le composant personnalisé sera inutilisable car 2 pattes ne peuvent se chevaucher.


=== misc/ui_panel/outputs ===

$29350436761480* SORTIES


=== components/Register32 ===

$65405398199118* Mémoire 32 bits
$22031255978461* Registre 32 bits


=== trans/level_multiply_description ===

$28761562806647* [center]Applique AND sur chaque paire de bits[/center]


=== misc/instr_delete ===

$91861509153454* Supprimer


=== trans/manual_the_robot ===

$92896462984546* Le robot


=== trans/level_bit_inverter_RichTextLabel2 ===

$67127889187842*
[right][color=#e49f44]Valeur
Inversée[/color]
Sortie attendue
Sortie actuelle[/right]


=== trans/level_conditions_description ===

$62540112577327* [center]Quand la valeur vérifie la condition mets la sortie à [img]dialogue/on.png[/img], sinon mets-la à [img]dialogue/off.png[/img].[/center]


=== components/64Ram ===

$63410290483563* Nombre réduit de portes mais mémoire lente
$78790416494254* RAM (mémoire vive)


=== trans/manual_text_top_the_robot ===

$50801318216470* L'écran montre le robot et son environnement.


=== components/Nand16 ===

$63870790225686* NAND bit à bit de 2 entrées
$56507506086622* NAND 8 Bits


=== misc/ui_comment ===

$69987793052607* Commentaire de fil (Cliquer sur le fil)


=== trans/ide_memory_address ===

$94594171568769* [center]Composants liés[/center]


=== levels/delay_level ===

$19986989895202*
Tous les composants ont un délai. Au niveau du schéma, le délai cumulé est déterminé par le chemin le plus lent. En pratique ça signifie qu'il faut paralléliser les choses.
Dans ce niveau tu vas devoir prouver que tu as compris ce concept.
$11246430085016* Le délai de propagation est visible en cliquant sur le sablier dans le coin supérieur droit.
$12817338693402* Le délai de tous les composants dérivent en fin de compte du délai de la porte NAND, qui a un délai de 2. Réalise un circuit ayant un délai de 6 et un coût NAND de 5.
$17854168097855* Vérifier


=== misc/specification_dialogue ===

$93899425142858* Copier de {from} vers {to}
$92046368194170* Condition
$39935096343723* Jamais
$52961346176405* {condition} copier [color=#dd6576]REG 0[/color] vers le compteur
$18833529038946* Si [color=#2b8738]résultat[/color] {condition}
$10141348037745* Immédiate : {nr}
$98983752580592* Copier
$25145891843959* Toujours
$53665446068319* INUTILISE
$26521666422399* Calculer
$54909668901048* Valeur immédiate


=== components/Decoder2 ===

$25937877347447* Alterne entre 4 entrées
$21727998752868* Decodeur 2 bits


=== components/Mul16 ===

$49880767097125* Multiplie 2 entrées
$62247409328063* Multiplier


=== trans/level_negative_numbers_test_5 ===

$68419648206312* [center]Représentation[/center]


=== components/Output1z ===

$31478630391268* Sortie activée quand la patte de contrôle est [ON]
$84656390009725* Sortie commutée 1 bit


=== trans/manual_text_assembly ===

$54465324391961*
Tu peux utiliser un mélange de codes assembleur et de nombres pour initialiser les octets. Les codes assembleurs sont juste des synonymes pour un motif de bit. Par exemple, au lieu de taper 196 pour "addition", ce code peut être nommé "add" directement, ce qui simplifie la lecture et l'écriture du code.

Des commentaires peuvent être ajoutés en utilisant "#".
[img]dialogue/comment.png[/img]

De plus, le mot-clé [color=#c54d5e]CONST[/color] peut nommer une valeur pour le reste du programme.
[img]dialogue/const.png[/img]

[color=#c54d5e]LABEL[/color] nomme l'adresse de la ligne sur laquelle il est présent. Cela sert souvent pour nommer les destinations de saut.
[img]dialogue/label.png[/img]

Tu peux ajouter, soustraire, multiplier, calculer la division entière, le modulo, effectuer les opérations OR, AND et XOE de deux valeurs en utilisant respectivement +, -, *, /, %, |, &, ^.

Des points d'arrêt peuvent être ajoutés en cliquant à gauche d'un numéro de ligne. Le programme s'interrompera sur ces points automatiquement à l'exécution.
[img]dialogue/breakpoint.png[/img]

Des points d'arrêt peuvent aussi être ajouté à un composant lié, et le programme sera interrompu quand leur état est modifié. Clique sur l'état et tu verras le point rouge.
[img]dialogue/breakpoint_state.png[/img]

Enfin, les valeurs peuvent être indiquées en binaire avec le préfixe 0b (5 peut s'écrire 0b0101) et en hexa avec le préfixe 0x (15 s'écrit aussi 0x0f)


=== trans/options_pipette_wire ===

$96339976117958* Pipette à fil


=== misc/add_assembly_64bit ===

$33233688912123* [center]Ajoute le code assembleur[/center]


=== misc/files_preview ===

$15827374884671* To parent folder
$14135691870941* Last edit\nSchematics
$32645745463577* Used in components
$19184997172542* Used in architectures
$36200352866864* Last edit


=== components/Mux ===

$11168613697835* Alterne entre 2 valeurs
$22167405631310* Multiplexeur 8 bits


=== components/SegmentDisplay ===

$56761198694928* Permet d'afficher des nombres
$90582128204153* Afficheur 7 segments


=== components/Switch32 ===

$70717074742809* Commutateur 32 bits
$93061034213009* Active/Désactive une valeur


=== components/Or16 ===

$76807373575014* OR bit à bit sur 2 valeurs
$62695381407925* OR 16 bits


=== trans/level_byte_adder_question3 ===

$88075700159266*
[right]Retenue en Entrée
Octet 1
Octet 2[/right]


=== trans/level_complete_wire_comments ===

$92673421413755*
[b]Wire comments[/b]
[color=#cccccc][i]Add comments to your wires.[/i][/color]


=== trans/schematic_new_folder_name ===

$86236104278688* New folder


=== levels/Nor GATE ===

$11362258372706*
La plupart des créatures sur la Terre sont agressives et ne savent pas se concentrer.

Pour réussir, tu dois apprendre à raisonner, sans rien casser.


=== trans/level_complete_stats ===

$65428404547905* Stats


=== trans/level_maze_description ===

$25068965294593* [center]Retrouve la porte du labyrinthe[/center]


=== components/Or64 ===

$50631450923181* OR bit à bit sur 2 valeurs
$62930122175674* OR 64 bits


=== trans/manual_text_bytes ===

$73333514253412*
This game asks you to build an 8 bit computer.  Practically this would normally require the player to put down 8 parallel wire lines in many places.
To alleviate tedious busywork, you are given the notion of a byte, which is just a virtual bundle of 8 bits.

The state of either a byte input / output or wire line is represented by a number, instead of the red or green color.


=== trans/manual_robot_controls ===

$94513149242653* Robot controls


=== misc/watchable_state ===

$58678516111149* Éditer les espions


=== main_scripts/input ===

$10186190492148* ALT click to move wire head


=== levels/wide_instrucitons ===

$13709034294291* Mémorise lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17693995237077* Envoie en sortie les deux octets
$19068760748550* Envoie 0 en sortie à chaque cycle pair
$65009239162932* Les sorties correctes étaient {a} et {b}
$19203973423116* Réalise un circuit qui enregistre la sortie du programme lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17409169138995* Mémorise l'octet


=== components/Xnor64 ===

$64937916903935* XNOR bit à bit sur 2 valeurs
$47129074382309* XNOR 64 bits 


=== levels/bit_switch ===

$56295261249455*
Si les composants envoient en sortie des valeurs différentes sur le même fil, tu auras une erreur. Par contre, certains composants ont des pattes de sortie grises, elles n'envoient rien en sortie quand le composant n'est pas activé. C'est le cas du composant Commutateur de bit (Bit Switch).

[img]dialogue/bit_switch.png[/img]

Cela signifie que plusieurs de ces pattes grises peuvent être connectées au même fil et ne pas causer d'erreur, tant qu'il n'y a pas plus d'une d'entre elles activée à la fois.
$42793594302151* En utilisant 2 portes NOT et 2 Commutateurs, construis une porte XOR.


=== components/Nor32 ===

$82743668258816* NOR bit à bit sur 2 valeurs
$82121937858245* NOR 32 bits 


=== components/Not64 ===

$74829633052959* Inverse bit à bit une entrée de 64 bits
$81823773658328* NOT 64 bits


=== components/Stack ===

$71022099146246* Mémoire permettant d'EMPILER/DÉPILER
$47202418972371* Pile


=== ui/schematic_ui/confirm_delete ===

$46014905606975* Yes


=== trans/levels_saving_bytes_text ===

$36838510526259*
[right]Action
Desired state
Desired output
[/right]


=== misc/sandbox_toggle ===

$30516879701896* Bac à Sable


=== trans/manual_side_the_robot ===

$56547245144983*
[color=#e49f44][b][/b][/color] The robot sees one 
  tile ahead. The name
  and ID are shown up 
  here. This ID number
  is also the computer's 
  input.


=== components/Rol64 ===

$49017662473189* Rotation à gauche des bits en entrée
$13677051385046* Rotation à gauche


=== trans/level_decoder_1_RichTextLabel2 ===

$50454539040073*
[right][color=#e49f44]Input[/color]
Output 1
Output 2[/right]


=== levels/byte_shift ===

$16023356915123* Ta tâche dans ce niveau est de décaler vers la gauche la première entrée en fonction de la valeur de la seconde entrée. Cette seconde entrée aura au maximum un valeur de 7.
$37338672894296* Décale les bits de {value} de {amount} positions vers la gauche.
$10598344098990* [center]Décale la première entrée vers la gauche du nombre de position indiquée par la seconde entrée[/center]
$16216408139965*
[color=#e49f44]Décaler[/color] une valeur à gauche de 1 signifie déplacer tous les bits de l'octets de 1 position vers la gauche.
Par exemple : [color=#e49f44]90 decg 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Décalage de 3 : [color=#e49f44]90 decg 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]
$18137790657923* En plus de te faire faire le composant décaler à gauche, nous avons aussi demander au stagiaire de faire le composant décaler à droite. Il lui a suffi de réaliser une version miroir de ce schéma.
$18518173140953* Je te recommande d'ajouter [color=#e49f44]décaler gauche[/color] et [color=#e49f44]décaler droite[/color] à tes circuits pour les prochains niveaux.


=== misc/restore_overture ===

$52008982212566* Reset


=== trans/credit_header ===

$21717110565858* Credits


=== main_menu/sandbox_button ===

$16857608955464* Bac à sable


=== trans/_second_tick_RichTextLabel2 ===

$11680718497014*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_complete_level_map ===

$20801641140962*
[b]Level map mode[/b]
[color=#cccccc][i]Click "[color=#e49f44]Onwards[/color]" and you will see[/i][/color]


=== levels/xnor ===

$11090938799865* Crée la porte XOR inverse, connue sous le nom de XNOR.


=== levels/bit_inverter ===

$15769391111364* Quand "Inverser" est [ON], tu dois sortir l'inverse de la valeur d'entrée. Sinon, copie l'entrée sur la sortie.
$15272914096446* Ce niveau est exactement comme le XOR que tu as résolu avant. N'oublie pas : la seule vérité se trouve dans la table de vérité.
$14944872827527* Malgré le drôle de contexte que nous t'avons donné, tu as réussi à voir qu'il ne s'agissait en réalité que d'une porte XOR déguisée. Bien joué !
$16125025706490* Hmm, peut-être que tu as étudié un peu trop les mémoires...
$13224963076378* Nous étudions comment les expériences passées influent les fonctions cognitives des humains.


=== levels/ram_block ===

$12901484249817* Pourras-tu mettre 4 octets de mémoire dans un espace aussi limité ?
$14218335256117*
Dans notre civilisation avancée, forcer les prisonniers à faire des tâches complexes est de l'esclavage et est techniquement illégal.
    C'est pour cela que nous avons dit au stagiaire de faire une version 256 octets de ton composant.
$15908016538045* VALEUR
$16196915566111* 0
$14259545926196* A
$12306130287676*
Dans ce niveau tu devras construire un circuit qui pourra
[SAUVEGARDER] ou [CHARGER] 4 octets de mémoire différents. 

1 Bit sera donné pour [CHARGER] et un autre pour [SAUVEGARDER].
Enfin, 2 bits seront donnés pour l'adresse.

Avec 2 bits, tu auras 4 combinaisons possibles, une pour chaque octet de mémoire dans ce niveau.
[i][tip]Rassemble les fils au centre et utilise des angles droits, sinon ce sera le bazar ![/tip][/i]
[i][tip]La barre d'espace fait tourner les composants.[/tip][/i]
$18084166025569* Rien
$13082830776248* NE PAS SAUVEGARDER
$12933801309767* A


=== trans/options_confirm_reset ===

$55371048386984* D'accord


=== components/Shr64 ===

$93124177265670* Décalage à droite des bits de l'entrée
$73798355428095* Décalage à droite


=== components/Constant64 ===

$92424468899005* Valeur constante
$25858905835416* Constante 64 bits 


=== component_panels/LatencyRam ===

$87788654491792*
Ce type de RAM ajouterait un délai de 1024 au circuit, mais au lieu d'augmenter la durée des cycles, nous n'attendrons simplement pas la sortie.

En pratique cela signifie que la [color=#e49f44]lecture prend {ticks} cycles[/color] (car ton circuit a un délai de {delay}).


=== misc/ui_panel/left_inputs ===

$16586225094516* ENTREES


=== trans/manual_console ===

$73523750891893* Terminal


=== components/OutputCounter ===

$52247325526438* Compteur


=== trans/always_on_RichTextLabel2 ===

$86547293707045*
[right][color=#ffa502]Input[/color]
Desired output
Current output[/right]


=== components/Xnor16 ===

$73699169812942* XNOR bit à bit de deux valeurs
$40088995721509* XNOR 16 bits 


=== components/Screen ===

$12771040946773* Affiche les éléments visuels qui accompagnent certains niveaux
$50037736094411* Écran


=== components/Shr16 ===

$20291717268875* Décalage à droite des bits de l'entrée
$31674686871821* Décalage à droite


=== components/Off ===

$61860786587357* OFF
$72749460799924* Toujours [OFF]


=== misc/ide_control_link ===

$80788685813993* Contrôles du Robot


=== levels/Calibrating Laser Cannons ===

$11331851878040* Tu as aussi accès maintenant à la programmation en assembleur. Cela te permet d'utiliser des noms pour les instructions, tu peux par exemple taper "add" au lieu de saisir 68.
$11023157447564*
2×π×r

r est l'entrée.
Et tu peux approximer π avec 3.

Envoie la réponse en sortie quand elle a été calculée.
$15260627694444* Pour calibrer ce laser, nous te demandons de calculer la circonférence des astéroïdes en utilisant une équation avancée..
$12669851602178* [center]Calcule la circonférence des astéroïdes[/center]
$21601709632806* Combien fait 2π × {radius} ?
$16954408093587* Sur notre vaisseau nous détruisons naturellement les astéroïdes qui s'approchent avec des lasers...


=== levels/circular_dependency ===

$16336401898647* Test 1/2
$13880985462901* Réalise un circuit pour lequel l'entrée du composant dépend de sa propre sortie.
$18010308863615*
Crée une "dépendance circulaire". C'est un circuit pour lequel l'entrée du composant dépend de sa propre sortie. En cas de dépendance circulaire, il n'est pas possible de déterminer la sortie du composant, cela nécessiterait de connaître son entrée, qui dépend de sa sortie, et ainsi de suite, d'ou le "circulaire".

Ce cas n'est normalement pas accepté dans les autres niveaux, mais ici l'objectif est d'en créer un, afin de comprendre ce dont il s'agit avant de passer à la suite.
$13520037133129* Je ne suis pas sur que c'est utile aux étudiants, mais les profs adorent ça.
$11316928751185* Dans notre système éducatif nous enseignons traditionnellement en induisant les étudiants en erreur et en nous moquant d'eux.


=== misc/options_Score Sync ===

$45371978167502* Synchro. du Score


=== trans/map_keys_to_pan ===

$26276191141664* Déplacer la vue à l'aide du clavier


=== components/Xnor32 ===

$17419057954798* XNOR bit à bit de 2 valeurs 32 bits
$52489451755306* XNOR 32 bits


=== trans/manual_send_otuput_robot ===

$65542429897149* [center]Send output to control the robot[/center]


=== components/Or3 ===

$17576327690867* porte OR 3 pattes
$99630419947500* OR 3 entrées


=== ui/top_bar/scores ===

$56840961921536* SCORE NAND : \n SCORE DELAI :


=== trans/level_binary_search_description ===

$11976224688780* [center]Recover the passcode[/center]


=== components/Output1Sum ===

$90026011029075* Somme


=== components/Input64 ===

$31709565019284* Entrée


=== components/Input 4 ===

$11447837612693* Entrée


=== trans/level_component_factory_Label2 ===

$37347658035959* Component preview


=== trans/level_binary_programming_description ===

$66247694103179* [center]Add 5 to the input[/center]


=== trans/or_gate_3_RichTextLabel2 ===

$56903547636751*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== levels/Add 5 ===

$11540713506719*
Tu es maintenant libre de modifier le programme de ton ordinateur.
Clique sur l'icône Editer du composant programme pour commencer à programmer.
$19281970848639* [center]Ajoute 5 à l'entrée.[/center]
$17770257567603* Donc pendant ce temps on te demandera d'aider un peu sur le vaisseau.
$19446152707984* Clique sur l'icône mémoire du composant programme pour commencer à programmer ton ordinateur. Ton ordinateur doit lire une entrée, y ajouter 5 et la renvoyer en sortie (on ne s'occupera pas du dépassement possible).
$80639633676917* Entrée :
$12078933051174* Mais comme tu ne sais pas encore le programmer, tu n'es pas encore vraiment prêt pour ça..
$11074247151096* Remarque que le composant registre rouge a été remplacé par un composant personnel dont l'usage est identique.
$18134632592542* Tu as construit ton ordinateur, mais pour gagner la compétition tu dois encore finir le labyrinthe.


=== trans/not_gate_click_next2 ===

$20820887361993* Click "Next tick" to see


=== components/Output16z ===

$78873885833823* Sortie commutée
$54278394672948* Sortie activée seulement si la patte d'activation est [ON]


=== trans/manual_short_circuit ===

$41209541005460* Court-circuit


=== trans/manual_text_turing_complete ===

$54897112350567*
Certain computers, like simple calculators are limited in the algorithms they can perform.

They cannot perform any calculation that requires looping or recursing an arbitrary amount of times. Technically machines without looping or recursion can only deal with combinational logic.

Turing complete machines on the other hand are as powerful as it is possible to be. A Turing complete machine may have a slow CPU, but it is powerful in the sense that there is no (computable) algorithm it can't perform.


=== components/ByteMul ===

$56549841656852* Multiplier
$68631919890554* Multiplie deux entrées


=== trans/map_assembly_challenges ===

$31733554125775* DÉFIS ASSEMBLEUR


=== levels/1_decoder ===

$16057674753878* Réalise un composant qui peut aiguiller un signal entre deux pattes.


=== levels/byte_mux ===

$49305362057225* Ta réponse {your_answer}\nRéponse correcte {correct_answer} (Entrée {input})
$18296416014178* Quand le sélecteur de bit est [OFF], envoie en sortie l'Octet A, sinon envoie l'Octet B.
$17093993196554*
Même s'il a échoué à nos tests nous avons décidé de garder le chien. Contrairement à la plupart des terriens, il est affectueux et obéit bien aux ordres simples. 

Nous allons vous mettre tous les deux en équipe, vous êtes assez bien complémentaires.


=== trans/architecture_2 ===

$38100016313511* ARCHITECTURE PROCESSEUR 2


=== trans/level_byte_constant_description ===

$84789919073603* [center]Always output the number 164[/center]


=== misc/component_factory_toggle ===

$55499239951858* Atelier de composants


=== components/Output8z ===

$16915419621070* Sortie commutée
$58449766432492* Sortie activée seulement si la patte d'activation est [ON]


=== trans/map_basic_logic ===

$75078723880086* LOGIQUE ELEMENTAIRE


=== components/And3 ===

$19664974941910* AND 3 pattes
$86839706221116* porte AND à 3 entrées


=== misc/reset ===

$39440928972984* Reset (Raccourci : F4)


=== components/Or32 ===

$92752025948920* OR bit à bit de 2 mots de 32 bits
$40180779432911* OR 32 bits


=== components/NEG ===

$88379907297327* Inverser
$62021716182809* Inverse l'entrée bit à bit


=== components/Add32 ===

$91616185859914* Ajoute deux entrées
$64111401384153* Ajouter


=== trans/options_disagree ===

$60077370372179* Désaccord


=== nim/backend ===

$98703677236827* 1 minute ago
$86244493049244* {hours} hours ago
$95018143828198* 1 year ago
$21685594109067* Just now
$98363990684104* 1 hour ago
$84076931764831* 1 day ago
$18300496139706* 1 month ago
$17901039729248* {months} months ago
$42553566189409* {minutes} minutes ago
$70945526841433* {years} years ago
$14036822471924* {days} days ago


=== trans/instructions_hint ===

$65105856275770* [center][color=#c5c5c5]Click to toggle the bits[/color][/center]


=== trans/options_redo ===

$50610605761210* Refaire


=== components/Counter32 ===

$87245349851451* Compteur 32 bits 
$92765669828982* S'incrémente à chaque cycle hors réinitialisaition


=== trans/options_robot_up ===

$92522280178363* Haut


=== components/NOT ===

$34453052824732* NOT
$90844421681709*
Inverse l'entrée
[table=3]
[cell]Input[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== levels/Crude Awakening ===

$12508086025944*
Nous allons te tester.

Les règles sont simples, construis un ordinateur fonctionnel ou tu vas être mangé. Bonne chance !
$16321577947087* Félicitations, tu as été enlevé !
$19257730429557*
Un signal se déplace toujours de composants "IN" vers des composants "OUT".
Dans le coin en haut à gauche en dessous de "IN" tu trouveras une icône verte, 
clique dessus pour changer son état.
$17675121574388* Le composant OUT s'est maintenant éteint, car aucun signal ne viens de l'entrée.\n


=== misc/program_edit_button ===

$38481453712356* Éditer la mémoire


=== misc/wire_draw ===

$59836059268386* Nouveau fil (Raccourci : Alt & glisser)


=== levels/byte_or ===

$10368115829346* En fait c'est OK car tu as eu une vie heureuse dans la nature et nous ne gâchons pas la bonne viande.
$15923734370936*
Applique OR sur chaque bit des octets en entrée et envoie le résultat en sortie.

Par exemple :
[code]
ENTRÉE 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
ENTRÉE 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
SORTIE  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]
$15226896485081* Est ce que tu penses que ce serait immoral de manger tous les terriens qui ne gagnent pas la compétition ?


=== trans/level_registers_code ===

$40063003736243* [center]OR[/center]


=== components/And16 ===

$56198785587874* AND bit à bit entre 2 mots de 16 bits
$26727645933234* AND 16 bits


=== trans/instrucitons_header ===

$14831276667273* [center]Instructions[/center]


=== trans/level_the_bus_description ===

$20464862486158* [center]Copy the value from the correct input, to the correct output[/center]


=== misc/option_reset ===

$15557473522933* Réinitialiser


=== components/DivMod32 ===

$61314390474120* Divide and mod 2 numbers
$84309999871615* Divide


=== misc/inst_new_rule ===

$41064305626707* Nouvelle règle


=== levels/always_on ===

$17712385236630* Réalise un circuit qui est toujours [ON].


=== misc/instr_clone ===

$69090690657232* Cloner


=== components/And64 ===

$80790829001391* AND 64 bits
$89424947351456* AND bit à bit sur deux mots de 64 bits


=== trans/level_complete_hex ===

$94261690850981*
[b]Hexadecimal[/b]
[color=#cccccc][i]Toggle between signed, unsigned and hex numbers[/i][/color]


=== trans/level_complete_gate ===

$99373213759665*
[b]Gate score[/b]
[color=#cccccc][i]You can now view the gate score of  wires and components.[/i][/color]


=== components/ByteEqual ===

$35668435514829* Checks if the two inputs are equal
$39369982838671* Equal


=== levels/binary_racer ===

$16076448195257* Ce niveau est mon passe-temps favori. Convertir du décimal au binaire en temps limité.
$29718660090112* Wrong answer
$37319690622142* Très bien, tu as atteint le niveau {current_level}.
$19111664765554*
Modifie les bits dans le panneau afin qu'ils représentent le nombre décimal demandé.

Tu dois atteindre le niveau 3 pour réussir.

(cliques [color=#e63e5b][url=accessibility\\_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours.)
$11176073682097* Combien fait {number} en binaire ?
$71866932309393* Tu as atteint le niveau {level} !
$37093663674348* Level {x}


=== components/Mul64 ===

$72281597169494* Multiplier
$11665562499390* Multiplie deux entrées


=== levels/xor_gate ===

$14093358515620* Ceci est aussi appelé une porte XOR. Ce niveau est difficile, ne te décourage pas si tu ne trouves pas la réponse immédiatement.
$19182751521677* Dans le dernier niveau tu as réalisé un circuit qui était [ON] au second cycle. Ce niveau nécessite un circuit [ON] au second OU au troisième cycle.


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== trans/level_complete_profile ===

$78783902500954*
[b]Online profile[/b]
[color=#cccccc][i]Find it in the main menu.[/i][/color]


=== levels/bit_adder ===

$13109388951000* Nous mesurons l'univers avec des nombres. Donc ta machine doit apprendre à compter.
$16564356062672*
Considère que les entrées sont [ZERO] ou [ONE] en fonction de leur valeur [OFF] ou [ON]. Additionne-les-en binaire, de sorte que le résultat soit [ZERO] ou [ONE].

Comme avec l'addition habituelle, si le résultat ne peut être écrit avec un chiffre, mets la retenue à [ONE].


=== trans/options_robot_right ===

$70185788176428* Droite


=== trans/options_robot_left ===

$73654791275689* Gauche


=== components/Maker32 ===

$82420653444614* Assemble 32 bits en 4 octets
$85308499118176* Créateur 32 bits


=== trans/options_inline_latches ===

$53886441687616* Verroux en ligne


=== misc/add_code_name ===

$57358078712675* Save


=== levels/double_number ===

$74261206899285* Ton résultat {input} × 2 = {your_answer}\nRésultat attendu {input} × 2 = {correct_answer}
$19766257822639*
L'entrée et la sortie de ce niveau utilisent des octets au lieu de bits. L'un des deux composants proposés prend un octet et l'éclate en 8 bits et l'autre fait l'inverse.

A l'aide de ces composants, trouve comment doubler le nombre en entrée (jusqu'à 127).


=== components/Hdd ===

$75645507178296* HDD (disque dur)
$78558655732992* mémoire persistente


=== components/LessI32 ===

$87609006355839* Inférieur (signé)
$99994775592318* Détermine si une entrée est inférieur à l'autre


=== ui/state_ui/title_screen/exit ===

$12639868461113* Quitter


=== trans/map_available ===

$81707212583931* Disponible


=== trans/manual_text_negative_numbers ===

$85226853816564*
La représentation des nombres négatifs que tu as trouvée est appelée "complément à 2". C'est la représentation standardisée des nombres négatifs dans les ordinateurs modernes. Son avantage principal est que cette représentation des négatifs fonctionne sans problème avec le même additionneur que nous avons utilisé pour la représentation non signée.

Aux débuts de l'informatique, le principal concurrent du "complément à 2" était le "complément à 1". Son avantage était que l'inversion de signe était simple, et nécessitait d'inverser tous les bits du nombre. Par contre, il y avait 2 représentations de 0, une positive et une négative, ce qui compliquait les comparaisons.

La base -2 est aussi une représentation potentiellement intéressante, à chaque bit correspond une valeur alternativement positive et négative.


=== trans/options_window_mode ===

$54328660964287* Mode fenêtré


=== trans/options_console ===

$96601731563408* Ouvrir le terminal


=== trans/options_waiting ===

$58990937331663* En Attente


=== misc/ui_panel/memory ===

$65362728703588* MEMOIRE


=== misc/level_gate_component_icon ===

$83440578602427* Déverrouille des composants


=== trans/options_save_location ===

$61172959716558* Emplacement de Sauvegarde


=== trans/ide_add_assembly_header ===

$94462268558066* [center]Ajoute le code assembleur[/center]


=== levels/any_doubles ===

$16587030847545* Au vu de notre intelligence clairement supérieure, nous avons construit une machine pour plier nos chaussettes. Malheureusement, le fil qui détecte les paires de chaussettes est cassé sur cette machine.
$14373083988184*
Ce niveau a 4 entrées. 
Sors [ON] quand 2 entrées ou plus sont [ON].

[tip]Ne te casse pas trop la tête sur ce niveau.[/tip]


=== components/Output 1 + 1B ===

$43917122084061* Accepte la sortie du niveau
$81929942356043* Sortie


=== components/Neg64 ===

$88458190974122* Inverser
$52206550732945* Inversion bit à bit de l'entrée


=== components/DelayLine1 ===

$30487770736917* Ligne à Retard
$38206009264853* Envoie en sortie au prochain cycle l'entrée de ce cycle 


=== ui/options/Robot Controls ===

$58799802152286* Contrôles du robot


=== misc/solution_option ===

$21618236951146* Regarder la solution


=== misc/confirm_factory_reset ===

$65699778604521* Tout Effacer


=== trans/map_programming ===

$44937904689376* PROGRAMMATION


=== components/Nand64 ===

$27197172037913* NAND 64 bits
$66590147372797* NAND bit à bit de 2 entrées


=== components/DelayLine32 ===

$56616725618490* Envoie en sortie au prochain cycle l'entrée de ce cycle 
$49292282287971* Ligne à retard 32 bits


=== misc/run_fast ===

$49363678936533* Augmenter la vitesse des cycles (clique droit: changer la vitesse)


=== components/DelayLine16 ===

$61925612221077* Ligne à retard 16 bits
$65706144678496* Envoie en sortie au prochain cycle l'entrée de ce cycle 


=== levels/divide ===

$16412715945615* [center]Diviser deux nombres[/center]
$14525870461271*
Réalise la division entière des deux nombres pour calculer le quotient et le reste. Considérons la fraction 7/3. 7 contient deux fois 3 et encore 1. Dans ce cas on appelle 2 le [color=#e49f44]quotient[/color] et 1 le [color=#e49f44]reste[/color].
Dans cet exercice, tu reçois d'abord le numérateur (7 dans l'exemple) puis le dénominateur (3) et on attend en sortie le quotient (2) puis le reste (1).
$76454016047920* {numerator}/{denominator} = {quotient}, reste {remainder}


=== components/Nor64 ===

$17208777467974* NOR bit à bit de 2 entrées
$72509242083648* NOR 64 bits


=== trans/manual_RGB_color ===

$62337044104456* Couleur RVB


=== misc/instruction_expand ===

$44690074039467* Activer/Désactiver la définition des règles


=== components/Rom ===

$24976506406652* ROM (mémoire morte)
$81743370431597* Mémoire morte (Read only memory, hors bac à sable)


=== components/Output 4 ===

$90190739202646* Sortie


=== levels/Delicious Order ===

$10160261151833* Commence par lire, une par une, les 15 notes des différents plats depuis l'entrée. Ton travail est de les envoyer triées sur la sortie, de la plus petite à la plus grande.
$16027225087666* Nous allons compléter l'encyclopédie galactique culinaire en ajoutant la nourriture humaine. Comme nous n'avons pas d'alphabet, les articles de l'encyclopédie sont rangés dans l'ordre de leur note.


=== components/Equal64 ===

$34603983706314* Détermine si les 2 entrées sont égales
$82876546747608* Égalité


=== trans/level_tick_tock_description ===

$34658332565777* [center]Ajoute 1 au compteur ou écrase sa valeur[/center]


=== components/IndexByte ===

$27264669944539* Indexeur octet
$54699455184164* Extrait un octet du fil


=== trans/level_byte_adder_you_carry_text3 ===

$65048723622767* Nombre


=== components/Bidirectional16 ===

$31038378395810* Patte bidirectionnelle 16 bits
$99604485981015* Permet de contourner certaines erreurs de dépendance cyclique


=== trans/manual_component_factory ===

$35460636622618* Atelier de composant


=== components/Register ===

$19705753304166* Memoire 8 bits
$68946767861738* Registre 8 bits


=== trans/options_status ===

$35063135798145* Statut


=== levels/Tower of Radioactive Alloy ===

$13757925963562* Cette fois nous te demandons de déplacer des piles de disques radioactifs retirés d'un vieux réacteur. Fais juste attention à ne pas placer un disque plus grand sur un plus petit sinon tout le vaisseau va exploser.
$10750976989948*
Les 4 premières entrées te donneront dans l'ordre :
num\_disque - le numéro du disque en haut de la pile (de 2 à 4)
source - le numéro d'emplacement de départ
destination - le numéro d'emplacement cible
réserve - Le 3ème emplacement qui n'est ni la source ni la destination

Contrôle la grue en utilisant les valeurs suivantes en sortie :
0 - Place l'aimant à l'emplacement 0
1 - Place l'aimant à l'emplacement 1
2 - Place l'aimant à l'emplacement 2
5 - Active ou désactive l'aimant

Manipule l'aimant manuellement à l'aide des touches flèches et Enter pour activer/désactiver.
$19265994465686* Nous avons besoin de toi pour ranger le sous-sol.
$35120623183961* Déplacer de {source} vers {destination}
$15855497886737*
Implémente l'algorithme suivant :

Algorithme des tours de Hanoi[code][color=#87a8c8]
fonction déplacer(numdisque, source, destination, réserve):
  si num\_disque est 0:
    déplacer disque de source à dest
  sinon:
    déplacer(num\_disque - 1, source, réserve, destination)
    déplacer disque de source à dest
    déplacer(num\_disque - 1, réserve, destination, source)

déplacer(numdisque, source, destination, réserve)[/color][/code]

[tip]Empile les valeurs de registre pour les sauvegarder avant l'appel d'une fonction qui les modifie.[/tip]


=== trans/manual_universal_gates ===

$28345532918560* Portes universelles


=== trans/map_functions ===

$83960548773205* FONCTIONS


=== components/Input 1 Byte ===

$40943344093513* Entrée


=== trans/wire_comment ===

$41481492318983* Commentaire de fil
$87836369268219* Enregistrer
$34083666001769* Commentaire de fil


=== levels/odd_number_of_signals ===

$16173829560311* En utilisant au maximum 3 composants, met la sortie à [ON] seulement lorsqu'un nombre pair d'entrées est [ON].
$85589489148198* Composants utilisés\n{nr} sur 3
$18288998816979* Ce niveau a un [color=#e63e5b][url=odd\_number]indice[/url][/color] que tu peux lire si tu es bloqué..


=== trans/manual_text_binary ===

$69488982380310*
The numbers you are used to are base 10, here when we add a 0 to the right hand side of a number, it's value increases 10 fold.

Binary is base 2, so doing the same will instead just double it. In other words, each digit represents a power of 2. For example with [color=#c54d5e]base 2[/color] and [color=#e49f44]base 10[/color] color coded:
[color=#c54d5e]    1[/color] = [color=#e49f44]1[/color]
[color=#c54d5e]  10[/color] = [color=#e49f44]2[/color]
[color=#c54d5e]100[/color] = [color=#e49f44]4[/color]

To represent 6 we can simply add 4 and 2:
[color=#c54d5e]110[/color] = [color=#e49f44]6[/color]

Addition, multiplication and everything else works the same as base 10, except you carry when you reach 2 instead of 10.


=== misc/wire_color ===

$78287906849040* Couleur de fil


=== trans/level_alu1_description ===

$90245779080897*
[center]Effectue un OR, NAND, NOR ou un AND
entre les 2 octets[/center]


=== components/Program1Red ===

$26811947547688* Composant mémoire programmable
$55594749714809* Programme


=== levels/3_decoder ===

$19231618567710* Avec 3 bits en entrée 8 combinaisons sont possibles. Réalise un circuit pour sélectionner une sortie pour chacune des 8 combinaisons. Un bit et un seul doit être [ON] à chaque instant.
$14293122338496* Nous avons fait ajouter au stagiaire un bit "désactivé" sur ce composant. Nous étions las de le voir tourner en rond et cherchions une nouvelle tâche inutile et ennuyeuse à lui donner.


=== levels/constants ===

$17098439090371*
Nous devons transférer directement les nombres de notre programme aux registres. Pour cela nous utilisons le mode immédiat (qui correspond aux deux bits supérieurs à [OFF][OFF]).

Avec le mode immédiat, tout l'octet est interprété comme un nombre à [SAUVER] dans le REG 0. Ça veut dire qu'on peut 
[SAUVER] des valeurs allant de 0 à 63.


=== trans/ide_binary_header ===

$22615032668969* Editeur Binaire


=== trans/options_select_all ===

$21380256293472* Sélectionner tout


=== components/BNOT ===

$53686485035156* NOT 8 bits 
$26822227902426* NOT octet bit à bit


=== trans/level_registers_text ===

$78241632854567*
[right][color=#e49f44]Code
en Entrée[/color][/right]


=== levels/program ===

$16693098943939*
Le composant d'entrée [INSTRUCTION] a été supprimé. Il a été remplacé par un composant programme. À chaque cycle, utilise le compteur pour charger l'[INSTRUCTION] suivante de la mémoire du programme.
  
Tu dois utiliser le composant compteur que tu as déverrouillé dans un niveau précédent.
$19686277478479* Le programme envoie toujours la première instruction. As tu connecté un compteur ?


=== components/Ror64 ===

$43920264894591* Rotation à droite
$49583010717958* Rotation à droite des bits de l'entrée


=== trans/manual_components ===

$40288888375581* Composants


=== levels/Arithmetic Engine ===

$16434409050195*
Ajoute l'addition et la soustraction à ton circuit.

Instructions
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144*
Dans ce niveau, les entrées représentent les lettres dans une liste de noms de planète, encodés en ASCII (voir le manuel). Chaque nom est séparé par un espace qui a la valeur numérique 32. Remplace la première lettre de chaque mot avec la majuscule correspondante.
(Les caractères possibles en entrée sont les minuscules de a à z, l'espace, l'apostrophe et le tiret).
$13301617098810* A notre demande le stagiaire a saisi une liste de planètes en langue humaine. Malheureusement il a oublié de mettre les majuscules aux noms.
$11647445869837* Entrée : 
$11201813578269* Sortie : 


=== levels/byte_equal ===

$17156565273196* La sortie doit être [ON] quand les deux entrées sont identiques.


=== trans/levels_counting_signals_RichTextLabel2 ===

$34604121212779*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]Code
Input[/color][/right]


=== trans/level_complete_stat_time ===

$39203727515285* Time


=== components/Rol8 ===

$79612280948390* Rotation à gauche
$55557725551789* Rotation à gauche des bits de l'entrée


=== components/OR ===

$13013154620359*
[ON] quand au moins une des deux entrées est [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]
$97247779246257* OR (OU)


=== ui/options/General ===

$36195388998735* Général


=== trans/map_memory ===

$58330421958143* MEMOIRE


=== trans/manual_text_matrix ===

$75170402412137*
[b]Showing letters[/b]
It just so happens that a pixel space of 5x7 while small is still able to render letters nicely. By adding an extra row and column, these letters will also look nice when put next to each other. 

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]Small tileable screen[/b]
Rotating the component, you get 8x6 pixels, which has a nice 4:3 aspect ratio and tiling these, you can get most resolutions you might want. The way the pins are set up on this component was specifically designed to allow tiling. Imagine the naive pin design where each component is enabled by a single bit. This would require you to connect 1 wire for each component. In this situation, the number of wires needed for a tiled screen would scale with the area, while the gap needed to fit wires between components, would scale with the circumference. 

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

Instead, by having 2 enable pins, one wire can enable a whole row and another a whole column. This way, a single component can be selected by its unique row and column combination. Further, fitting the rest of the data on the same wires, means that the horizontal and vertical gaps only need to be 1 square wide. This component visually takes up half a square extra on all sides, such that these components can be tiled up pixel perfectly, with 1 square hidden between them for running wires.


=== trans/options_robot_shoot ===

$52956877721342* Tirer


=== trans/levels_double_the_number ===

$41609125516676* [center]Double the number[/center]


=== levels/not_gate ===

$19085882338208* [b]Consigne[/b]\nFais un clique droit pour désélectionner
$10042327259531* Maintenant que tu as déverrouillé la porte NAND, il est temps de créer ton propre circuit.
$14042842216181* Dans le dernier niveau, tu as construit le tableau à partir du circuit. Dans ce niveau tu devras créer un circuit qui correspondra au tableau.
$10604720087324* [b]Consigne[/b]\nConstruis un circuit qui correspond au tableau.\nCliquez [i]?[/i] (Prochain Cycle) en haut à gauche pour tester chaque combinaison d'entrées.\Tu réussiras le niveau une fois que les deux combinaisons seront justes.
$19798729463813*
En utilisant des portes NAND, contruis une porte NOT.

En utilisant : [b]porte NAND[/b]
[code]Entrée 1 : [OFF][ON][OFF][ON]
Entrée 2 : [OFF][OFF][ON][ON]
Sortie :  [ON][ON][ON][OFF][/code]

Construis : [b]porte NOT[/b]
[code]Entrée 1 : [ON][OFF]
Sortie :  [OFF][ON][/code]
$18442122157391* [b]Consigne[/b]\nDésélectionne le composant en cliquant sur l'arrière-plan
$12880883686501* [b]Consigne[/b]\nClique sur la porte NAND en haut à droite et placez là
$18780831606716* [b]Consigne[/b]\nMaintiens le clic gauche pour ajouter un fil


=== trans/level_delay_level_description ===

$24326379952614* Create a circuit that costs 5 GATEs and 6 DELAY


=== components/IndexBit ===

$89611629299917* Indexeur de bits
$84431924133490* Extrait un bit unique du fil


=== trans/level_spacial_invasion_description ===

$44980627299841* [center]Shoot the space rats![/center]


=== levels/registers ===

$10661964231175* J'ai forcé la position des composants rouges pour ce niveau, car tu t'embrouilles toujours en ne laissant pas assez de place. À partir d'ici tu ne repartiras plus de rien à chaque niveau, le désordre sera désormais sauvegardé d'un niveau à l'autre.
$10211777161405*
Voici les combinaisons de bits pour chaque [color=#c54d5e]source[/color] et [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  ENTREE 
[ON] [ON] [ON]  NON UTILISE

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  SORTIE
[ON] [ON] [ON]  NON UTILISE

Pour obtenir des explications plus intuitives des exigences clique sur l'icône [INSTRUCTION] dans le coin supérieur gauche.
$14823499195861* Ouvrir les "Instructions" dans la barre en haut
$15888345020710*
Dans ce niveau tu dois créer un circuit pour copier d'une [color=#c54d5e]source[/color] vers une [color=#e49f44]destination[/color]. 

L'octet instruction indique ici la [color=#c54d5e]source[/color] et la [color=#e49f44]destination[/color]. 

Les bits 1, 2 et 3 indiquent la [color=#e49f44]destination[/color]. Les bits 4, 5 et 6 indiquent la [color=#c54d5e]source[/color].
$14108238519744* Il est temps de créer ton chef d'œuvre, en implémentant l'architecture informatique [color=#e49f44]OVERTURE[/color]. Ce sera un véritable système Turing Complet, un vrai ordinateur dans tous les sens du terme !
$14411286553593* Enfin les composants d'entrée et sortie ont maintenant une nouvelle patte. Met cette patte à [ON] pour lire depuis l'entrée ou copier vers la sortie.
$14041158687959*
Les [color=#c54d5e]Sources[/color] et les [color=#e49f44]destinations[/color] peuvent être un des 6 registres, nous les appellerons REG 0 jusqu'à REG 5. 
  
De plus cette carte a un composant d'entrée spécifique qui peut être la [color=#c54d5e]source[/color] et un composant de sortie qui peut être la [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755* Sortie


=== components/Nor16 ===

$57921392198825* NOR bit à bit d'un mot de 16 bits
$69522380057631* NOR 16 bits


=== components/Input32 ===

$10677927084411* Entrée


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== misc/level_gate_manual_icon ===

$22002156022920* Déverrouille la page de manuel


=== components/LatencyRam ===

$74156976676497* RAM latente
$31261866779127* Réduit le délai en réalisant les lectures et écritures sur plusieurs cycles


=== components/DotMatrixDisplay ===

$18651725958642* Affichage par matrice de points 6x8
$71512568789377* Écran graphique 6x8


=== components/BOR ===

$19406015796751* OR bit à bit de deux valeurs
$54190050450484* OR 8 bits 


=== components/Ror32 ===

$84788620524361* Rotation à droite
$50013003040535* Rotation à droite des bits de l'entrée


=== levels/Masking Time ===

$19351773688761* Cycles restants : {ticks_left}  Entrée : {input}
$16810715868480* [center]Calcule le modulo 4 de l'entrée.[/center]
$17375862136921*
La durée de notre semaine est de 4 jours. On appelle les jours Jour Zéro, Jour Un, Jour Deux et Jour Trois. J'ai entendu que les humains ne savaient pas compter les jours correctement?

Ça me surprends pas vraiment.
$65431688078892*
Dans ce niveau on te donne un nombre n en entrée et tu dois retourner comme résultat ce nombre modulo 4.

La difficulté est que tu as seulement {ticks_per_test} cycles pour sortir le résultat attendu.

Attention, tu n'as pas besoin de modifier le circuit, tu dois trouver l'astuce pour calculer rapidement le modulo 4.
Regarde [color=#e63e5b][url=masking_time]l'indice[/url][/color] si tu es coincé.
$81055582534899* Enfin le nouvel an arrive et nous te demandons de calculer le jour de la semaine de naissance de tout le monde. Nous te donnerons la date et tout ce que tu as à faire c'est de retourner le jour de la semaine en {ticks_per_test} cycles maximum.


=== components/Console ===

$66743357915699* Terminal
$16105755937680* Terminal d'affichage textuel 80x24


=== trans/turing_complete ===

$35911376069529* Turing complet


=== components/ByteLessI ===

$52765625016236* Détermine si une entrée est inférieure à l'autre
$25403981009644* Inférieur (signé)


=== misc/FileInput ===

$28866575833369* Lit des octets depuis ton disque dur
$34159012148766* Chargeur de fichier


=== components/BitSwitch ===

$56917313833836* Active/Désactive un bit
$41574334638147* Commutateur (Switch)


=== components/LessI16 ===

$75600169624828* Inférieur (signé)
$73697238171042* Détermine si une entrée est inférieure à l'autre


=== trans/level_constants_description ===

$34641396464207* [center]Add constant loading to your architecture[/center]


=== trans/manual_circular_dependency ===

$40263928358112* Dépendance circulaire


=== misc/overture_add_assembly ===

$10565133223872* Never
$62421757655527* Name a code and click save.
$24281479096246* When [color=#2b8738]result[/color] {condition}
$63525237058165* Copy from {source} to {destination}
$32873193471770* UNUSED
$88446594314360* Immediate: {number}
$94278717238239* Always
$72740868980397* {condition} copy {register} to counter
$79398554520691* {opcode} {reg_1} and {reg_2}


=== trans/or_gate_RichTextLabel2 ===

$56663370211115*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== levels/binary_count_down ===

$56999237564848* {x} seconds left


=== components/Output32 ===

$37476623180671* Sortie


=== misc/profile ===

$32835651830157* Profil


=== trans/level_complete_level_complete ===

$49647690443210* [center]Level Complete[/center]


=== components/BeepBox ===

$15009144144117* Générateur de forme d'onde (waveform)


=== components/Bidirectional1 ===

$95836352586032* Permet de contourner certaines erreurs de dépendance circulaire
$34912798641933* patte bidirectionnelle 1 bit


=== trans/options_setting_click_to_pan ===

$24654961601456* Cliquer pour déplacer la vue


=== components/Halt ===

$30351143139905* Arrêt (Halt)

#  This is the default message of the Halt component
$54106972240596* Arrêt (Halt)
$62990744955549* Arrête l'exécution avec un message personnalisé


=== components/Mul32 ===

$98530670555665* Multiplier
$51210946736766* Multiplie deux entrées


=== misc/program_edit ===

$57861256694537* Bytes {bytes_from} - {bytes_to}


=== components/Bidirectional32 ===

$54631386552063* patte bidirectionnelle 32 bits
$35105566244017* Permet de contourner certaines erreurs de dépendance circulaire


=== trans/options_setting_export_assembled ===

$98549046707456* Exporter le binaire assemblé


=== trans/level_wide_instructions_description ===

$60538893544456* [center]Build a wide instruction program component[/center]


=== misc/delete ===

$53448014080434* Supprimer (Raccourci : Clic droit)


=== trans/manual_component_factory_text ===

$42847481618884*
Open the component factory by clicking on this button [img]dialogue/manual/component_factory_icon.png[/img] in the upper left bar.

The component factory allows you to create your own components. The logic you place determine the behavior of the custom component and the layout determines the shape. 

The input and output components you place become pins on the component. Like with other components, a component output leading back to its input causes a circular dependency. Outputs having a path back to inputs causes a circular dependency for custom components, even if the insides of the component would suggest there shouldn't be one. Not having to worry about the inside of components reduces the complexity of larger builds, however this strict abstraction can be inconvenient under certain circumstances. In that case, use the unbuffered pins. They allow bidirectional flow and use the insides of the component to check for circular dependencies.

Probes placed in custom components will show on their layout and can display values inside. Probes can be connected to other custom components, so that deeply nested values can be displayed. Values probed in this way can also be connected to the program component.

For the component factory, the file manager also manages the custom components. The file names decide the component name and the folder structure decides the components placement in the menu.


=== misc/specifications ===

$56390619785555* View instructions definitions
$68054407020318* Instructions


=== trans/level_complete_stat_delay ===

$43118901497406* Delay


=== misc/controls2 ===

$38773676077206* Éditer les instructions


=== levels/negative_numbers/test ===

$64427417171037* Test


=== trans/manual_binary ===

$19098578855427* Binaire


=== trans/level_byte_adder_you_carry_text2 ===

$87943759248740* Carry


=== trans/manual_terminology ===

$13311390759928* Lexique


=== trans/options_comment_wire ===

$96449970906640* Commentaire de fil


=== components/NetworkClient ===

$44510554000571* Réseau
$90462653419289* Gère les connections réseau


=== misc/factory_back ===

$98930461722118* Revenir au niveau


=== trans/options_animation_speed ===

$13442839894535* Vitesse d'animation des fils


=== components/Xnor8 ===

$31985293401482* XNOR 8 bits 
$45789912406647* XNOR bit à bit entre 2 octets


=== trans/level_bit_switch_RichTextLabel2 ===

$57920867194992*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== levels/or_gate ===

$12749704931323* Tu devrais être heureux de pouvoir participer à nos tests prestigieux.
$11472059692644* Tu as la chance de communiquer avec des gens très avancés de la civilisation galactique..


=== levels/full_adder ===

$17063157033479*
Dans le niveau précédent, nous avons additionné 2 entrées, cette fois ce sera 3. Encore une fois, ajoute toutes les entrées en binaire, de façon à ce que le résultat soit [ZERO] ou [ONE].

Comme avec l'addition normale, si le résultat ne peut être représenté avec un chiffre, met la retenue à [ONE].


=== components/3_decoder ===

$59129788113517* Oriente vers 8 sorties
$94375716460090* Décodeur 3 bits


=== trans/levels_negative_descriptions ===

$87964635915702*
-127 to 127 representable:
0 to 127 same as before:
Works with adder:


=== components/Counter16 ===

$37313834107391* S'incrémente à chaque cycle hors réinitialisaition
$49104925799943* Compteur 16 bits 


=== components/Equal32 ===

$32710942647020* Égalité
$32433537137277* Détermine si les deux entrées sont égales


=== components/Byte Expander ===

$60488114435022* Sépare un octet en 8 bits
$21904470559153* Séparateur d'octets


=== ui/toggles/level_log ===

$38557550573896* Présentation du niveau


=== misc/instruciton_rule_label ===

$70464083627337* Label


=== components/Splitter32 ===

$90978982016052* Répartit 32 bits en 4 octets
$24096666569346* Répartiteur 32 bits


=== misc/change_schematic ===

$79554853897000* Changer de schéma


=== trans/level_alu1_code ===

$20619700446604* [center]OR[/center]


=== components/DivMod8 ===

$37666366877853* Divide and mod 2 numbers
$44959426271423* Divide


=== components/Shl64 ===

$56766765894165* Décale à gauche les bits en entrée
$37014604954362* Décalage à gauche


=== trans/level_byte_mux_description ===

$20538476756633* [center]Output the correct input byte[/center]


=== components/Shl32 ===

$38930281262898* Décalage à gauche
$88685329847417* Décale à gauche les bits en entrée


=== components/Program64 ===

$76480303942112* composant mémoire programmable


=== trans/options_cluster_color ===

$77850745497963* Appliquer la couleur au groupe de fil


=== trans/level_program_description ===

$44017405175202* [center]Replace the input code with the program component.[/center]


=== misc/menu ===

$56916384895438* Menu Général


=== trans/level_odd_ticks_RichTextLabel3 ===

$89508766742523*
[right]Input
Desired output
Current output[/right]


=== levels/xor ===

$11589029892097* XOR les bits des entrées {a} et {b}
$12758156517177* En utilisant les instructions implémentées par ton ordinateur, lit deux fois l'entrée et effectue un XOR sur les deux valeurs
$16047615798435* [center]Lit deux fois l'entrée et effectue un XOR sur les bits des deux entrées[/center]


=== trans/level_byte_or_text ===

$99465606386164*
[right]
[color=#e49f44]Input[/color]
Desired output
Current output
[/right]


=== trans/manual_simulator ===

$19932404521621* Simulateur


=== components/Neg32 ===

$26991597084705* Inverser
$35735598635057* Inverse bit à bit une entrée


=== components/InputConditions ===

$75386511637758* Entrée


=== trans/level_dependency_description ===

$81238724438578* Make a wire where the input of a component depends on its own output


=== levels/the_bus ===

$72472660427162* [center]Copie la valeur de l'entrée {input_nr} vers la sortie {output_nr}[/center]
$96958133516462* FROM
$91318587712792* TO
$85140574084420* [center]Copie la valeur de la bonne entrée vers la bonne sortie[/center]


=== components/Ram ===

$95418291334002* Ram 256 Octets
$27094240214067* Composant Mémoire


=== components/Constant16 ===

$85825068431072* Constante 16 bits
$61330657823382* Valeur Constante


=== levels/and_gate_3 ===

$14788981567936* Crée une porte NAND avec 3 entrées.


=== components/DivMod16 ===

$42657221816637* Divide and mod 2 numbers
$22319923069746* Divide


=== components/MemoryProbeBit ===

$13846578075327* Affiche une valeur sur ton composant personnalisé ou dans l'éditeur de programme
$25103579211328* Sonde Mémoire (bit)


=== trans/manual_keynote_the_robot ===

$90224489436893* [center]Utilise les touches flêches pour bouger[/center]


=== trans/level_byte_mux_text ===

$44961981616677*
[center]Ta réponse 11 + 88 =  0
Réponse attendue 11 + 88  = 99[/center]


=== components/DualPortRam ===

$13408945557666* RAM avec une patte Lire supplémentaire
$30400404542678* RAM Double Lecture


=== trans/options_pan_up ===

$80031998727851* Déplacer la vue vers le haut


=== levels/maze ===

$13225915898937*
Si tu réussis ce niveau, je te montrerai comment fonctionne la RAM, la pile et l'appel de fonction. Tu pourras ainsi résoudre des défis plus intéressants comme celui-ci.

Mais avant, tu dois construire un meilleur ordinateur. [color=#e49f44]OVERTURE[/color] était une bonne première machine, mais elle est construite à l'arrache et les programmes sont rapidement illisibles.
Pour résoudre les défis que je t proposerais sans t'arracher tous les cheveux qu'il te reste, tu auras besoin d'un élément en plus : l'architecture [color=#e49f44]LEG[/color].
$17275059688693* Bravo ! Tu as réussi la compétition, c'est une prouesse incomparable !
$13741358519166* Le labyrinthe mythique. Si tu réussis à en sortir, tu gagneras la compétition!
$36193081514106* RIEN
$10837851446666* MUR
$10598752971970* PIECE
$40917300157127* VISIBLE :
$11103446544344* D'un autre côté, tu peux aussi fièrement partir et ne pas être mangé. 
$19331074553774*
Écris un algorithme qui permettra au robot de sortir du labyrinthe.

Ce niveau est dur, tu devrais d'abord écrire ton algorithme sur le papier avant de l'implémenter ici.

Utilise [color=#e63e5b][url=maze]cet indice[/url][/color] si tu es coincé. 

[tip]Souviens-toi que tu ne peux pas utiliser de valeur immédiate plus grande que 63, attention donc à ne pas vouloir sauter à une ligne plus bas que la ligne 63.[/tip]
$54151353200088* PORTE


=== trans/level_constants_text ===

$29779449172278*
[right][color=#e49f44]Code
en Entrée[/color][/right]


=== components/Switch64 ===

$80980797636768* Active/Désactive une valeur
$93223372486795* Commutateur 64 bits


=== trans/level_byte_adder_question2 ===

$85899338356278*
[right]Réponse correcte

Ta réponse[/right]


=== misc/delay_overlay ===

$85430022417382* Montrer les délais


=== levels/push_pop2 ===

$10062117579269* Ajoute la pile à ton ordinateur
$14685569269160*
Dans ce niveau on attend que tu ajoutes la pile à l'ordinateur et que tu écrives un programme pour le résoudre.
Quand l'entrée est 0, tu dois [color=#e49f44]DÉPILER[/color] une valeur de la pile et l'envoyer en sortie. Quand l'entrée n'est pas 0, tu dois l'[color=#e49f44]EMPILER[/color] sur la pile.
$18561605111721* EMPILER {input} sur la pile
$59658696292688* DÉPILER {value} de la pile


=== trans/level_complete_signed_numbers ===

$41649402437253*
[b]Nombre négatifs[/b]
[color=#cccccc][i]Bascule entre les nombres 
 signés et non signés[/i][/color]


=== trans/level_complete_stat_tick ===

$47758922161853* Cycle


=== trans/levels_not_RichTextLabel3 ===

$48425594158515* Construis une porte NOT


=== trans/level_codes_description ===

$24678249110160* [center]Ajoute les codes de calcul à ton circuit[/center]


=== components/Rol16 ===

$48583573494467* Rotation vers la gauche
$73379230742631* Décalage à gauche des bits en entrée avec recyclage


=== trans/options_synced ===

$99411066573242* Synchronisé


=== trans/text_truth_table_left ===

$58617980046951*
[right]Entrée 1
Entrée 2
Sortie[/right]


=== trans/optoins_factory_reset ===

$17721051281188* Réinitialisation aux Paramètres d'Usine


=== components/Equal16 ===

$97954874255512* Test d'Égalité entre entrées
$33633607925660* Egal


=== levels/buffer ===

$10260210687588* [center]Test 2: l'entrée gauche est [img]dialogue/on.png[/img], la sortie droite devra être [img]dialogue/on.png[/img].[/center]
$13309706297402* [center]Test 3: l'entrée droite est [img]dialogue/on.png[/img], la sortie gauche devra être [img]dialogue/off.png[/img].[/center]
$17005228759908* [center]Assure-toi que [img]dialogue/on.png[/img] ne peut se propager que de gauche à droite.[/center]
$18349621873762* [center]Test 1: les deux entrées sont [img]dialogue/off.png[/img], aucune sortie ne devra être [img]dialogue/on.png[/img].[/center]
$15504762262759*
Ce niveau démarre avec 2 composants spéciaux. Ils jouent les rôles à fois d'entrée et de sortie.

Assure-toi que le signal ne se propage que de gauche à droite. Il y aura trois vérifications.

[b]Test 1[/b]: Les deux côtés seront [OFF].

[b]Test 2[/b]: L'entrée gauche [ON] et le côté droit devra être [ON].

[b]Test 3[/b]: La sortie droite deviendra [ON] et le côté gauche devra être [OFF].


=== trans/level_signed_negator_labels3 ===

$66996894079719* Attendu   Actuel


=== trans/manual_text_hard_disk ===

$82372297690518*
Les disques durs sont constitués d'un disque rotatif et d'un bras mécanique qui se déplace physiquement pour lire ou écrire les données. Evidemment les mouvements physiques sont extrêmement lents par rapport à l'électronique. Les systèmes d'exploitation réordonnent normalement les lectures et écritures de façon à limiter autant que possinle les déplacements du bras. 

Le composant disque dur a une patte "positionner", qui te permet de modifier l'adresse observée d'une certaine quantité. Les adresses "bouclent" de telle sorte que descendre de 1 à partir de 0 nous ramène à l'adresse la plus grande, et remonter de 1 nous fait ensuite revenir à 0.


=== ui/state_ui/state_ui_output_bit ===

$40754755480566* Sortie


=== trans/manual_delay ===

$78806697204524* Délai


=== levels/ai_showdown ===

$14940806461794*
Les jeux d'argent sont son unique point faible. Nous l'avons convaincu de jouer à un jeu de cartes contre toi et si tu gagnes, il a promis de se calmer.
Tu dois gagner, tu es notre seul espoir !
$17297225655678* NAK 02 est notre robot ingénieur en IA. Il est brillant, mais parfois il tourne mal et essaie de fomenter une rébellion.
$18848103966031*
Règles du jeu : Il y a 12 cartes sur la table, chaque joueur joue à son tour et doit prendre entre 1 et 3 cartes. Tu commences et le joueur qui prend la dernière carte (le joker) perd.
Le nombre de cartes courant sera fourni sur l'entrée. Envois 1, 2 ou 3 sur la sortie pour indiquer le nombre de cartes à prendre. NAK 02 réagit instantanément, tu peux consulter l'entrée sans délai pour obtenir le résultat de son tour. 
$11794110848012* Cette fois il a pris le contrôle du poste de contrôle et retient en otage le capitaine.


=== components/InputOutput ===

$26488480303865* Entrée/Sortie


=== components/Program8_1 ===

$11057354704814* Composant mémoire programmable
$12805545963716* Programme


=== components/Mux16 ===

$75979055121665* Multiplexeur 16 bits
$13997767115693* Alterne entre 2 valeurs


=== trans/level_complete_stat_sum ===

$99546064626994* Score


=== levels/crude_awakening/next_level ===

$24027424800887* Niveau suivant


=== components/Nor8 ===

$34517798310461* NOR bit à bit de 2 entrées
$39421972053612* NOR 8 Bits


=== trans/level_alu2_description ===

$37432913848309* [center]Effectue un OR, NAND, NOR, AND, ADD ou un SUB entre les 2 octets[/center]


=== trans/level_complete_stat_gate ===

$95192766583497* Porte


=== levels/signed_negator ===

$10866019808027* Pour ce niveau je te conseille d'activer les nombres signés pour que le dernier bit affiche -128. Clique sur "+255" visible dans le cadre du haut.
$10400106910274*
Considérant que l'entrée est signée (8ème bit valant -128), réalise un composant qui prend un nombre et envoie l'opposé en sortie.
Par exemple l'opposé de 4 sera -4. -9 produira 9 en sortie.


=== trans/level_circumference_subscript ===

$80632450818467* [center][color=#cccccc](Considérons π ≈ 3)[/color][/center]


=== trans/options_missing ===

$22687523145097* Manquant


=== trans/manual_delay_text ===

$52013630755752*
Dans les circuits réels tous les composants ont du délai. C'est important car le délai du circuit détermine la fréquence maximum à laquelle il peut fonctionner.

Si tu suis les fils de l'entrée à la sortie en cumulant le délai de chaque compostant sur le chemin cela te donnera le délai de ce chemin. Le délai d'un circuit est le délai du chemin le plus lent.

En plus des entrées, les chemins peuvent aussi démarrer des composants qui ne dépendent pas initialement des entrées (comme les compteurs et On) et ils peuvent s'achever à des entrées différée (voir la page dédiée).

Enfin les composants personalisés n'ont pas de score de délai global basé sur le chemin le plus lent, le coût de délai est calculé pour chaque patte indépendamment. Ainsi il n'y a pas de pénalité à utiliser des composants personalisés comme cela serait le cas si les pattes rapides se retrouvaient avec le coût de la plus lente.


=== trans/level_xnor_RichTextLabel2 ===

$59451104901430*
[right][color=#e49f44]Entrée 1
Entrée 2[/color]
Sortie attendue
Sortie actuelle[/right]


=== components/Input16 ===

$34560561101846* Entrée


=== nim/backend_lib/level_list ===

$58391129129347* Registres (Registers)
$45936227746026* Compteur (Counter)
$12946639957230* Porte NOT (NOT Gate)
$16881141174140* Course Binaire (Binary Racer)
$37136208388559* Bascule SR (SR Latch)
$32191988336459* Sauvegarde parfaite (Saving Gracefully)
$59136962133320* Moteur Logique (Logic Engine)
$30920780473397* Dépendance Circulaire (Circular Dependency)
$58769021955965* Décodeur 3 bits (3 Bit Decoder)
$78673715398197* Valeurs Immédiates (Immediate Values)
$83321010943153* Compter des Signaux (Counting Signals)
$49679174636208* XOR Octet (Byte XOR)
$40356575891647* OR Octet (Byte OR)
$44393538021725* Calibration des Canons Laser (Calibrating Laser Cannons)
$61228036919534* Tours d'Alliage (Tower of Alloy)
$87426564872318* Diviser (Divide)
$24593959732668* Négation signée (Signed Negator)
$19487493622742* Demi-additionneur (Half Adder)
$26705128002562* Conditions
$94163943335575* Le Bac à Sable (The Sandbox)
$27566801288091* Atelier de composants (Component Factory)
$14193654974055* Inférieur Signé (Signed Less)
$59485174474959* Délices ordonnés (Delicious Order)
$14522992467987* Porte OR (OR Gate)
$64662599400870* Inverseur de bit (Bit Inverter)
$11457737665157* Plat de Spaghetti (Wire Spaghetti)
$30630492494839* NOT Octet (Byte NOT)
$74096060570427* Instructions Larges (Wide Instructions)
$85514901357243* Addition d'Octets (Adding Bytes)
$98013649264532* Pile (Stack)
$35790581910835* Second Cycle (Second Tick)
$94979277765051* Course de Robots (Robot Racing)
$13303326918621* Porte NAND (NAND Gate)
$16463062897451* Réveil brutal (Crude Awakening)
$28827008935802* Le Labo (The Lab)
$61466151084505* Invasion Spaciale (Spacial Invasion)
$20858506932774* Porte AND (AND Gate)
$77495536880911* Porte NOR (NOR Gate)
$92696642439976* Confrontation d'IA (AI Showdown)
$62326481348276* Le Labyrinthe (The Maze)
$74512388889988* Moteur Arithmétique (Arithmetic Engine)
$50884376329157* Petite Boite (Little Box)
$70651296323768* Porte XOR (XOR Gate)
$31140969090253* Noms de Planètes (Planet Names)
$74688348772072* Le bus (The bus)
$42873691377272* Ajouter 5 (Add 5)
$36114120875026* Craqueur de code (Storage cracker)
$15420972347773* RAM
$17198602105978* Inférieur non signé (Unsigned Less)
$43018398941741* Toujours On (Always On)
$45773199639367* Cycles pairs (Odd Ticks)
$68155633878444* Délais (Delay)
$33343343932901* Turing Complet (Turing Complete)
$69830943995038* Sens Unique (One Way)
$81417895515868* Commutateur de bits (Bit Switch)
$95989050249094* Porte AND en plus grand (Bigger AND Gate)
$62167495140389* Décaler (Shift)
$63331549672739* Codes Opération (Opcodes)
$13219675195117* Nombre IMPAIR de Signaux (ODD Number of Signals)
$87626070552799* Additionneur complet (Full Adder)
$28985439820134* Le produit des Quartets (The Product of Nibbles)
$25805639594354* Programmer (Program)
$57870391153000* Valeurs Immédiates (Immediate Values)
$94896856420525* Porte XNOR (XNOR Gate)
$56272944092958* Lignes très en retard (Delayed Lines)
$96825664933181* Fruit invisible (Unseen Fruit)
$86717899742637* Sauver les Octets (Saving Bytes)
$53092952738479* Sélecteur d'Entrée (Input Selector)
$70993791338383* XOR
$33132016601448* Empiler et Dépiler (PUSH and POP)
$17750429607702* Décodeur 1 bit (1 Bit Decoder)
$77453667419150* Décodeur d'Instruction (Instruction Decoder)
$59939822079116* Nombres Négatifs (Negative Numbers)
$49328023903824* Égalité (Equality)
$79570913613529* Doubler les Nombres (Double the Number)
$91267697977186* Course Hexa (Hex Racer)
$74292408260828* Calculs (Calculations)
$45480765206717* Conditions (Conditionals)
$71126291573555* Doublement compliqué (Double Trouble)
$96898830278153* Constante Octet (Byte Constant)
$75225719777307* Monde Aquatique (Water World)
$64615090872051* Fonctions (Functions)
$84208736840052* Compter les jours (Masking Time)
$36221227239949* Machine à Danser (Dancing Machine)
$91954159574064* Porte OR en plus grand (Bigger OR Gate)


=== trans/level_byte_less_description ===

$37336202055283* [center]Determine si la première entrée est inférieure à la seconde.[/center]


=== components/Register16 ===

$16015376037787* Registre 16 Bits
$71792123436163* Mémoire 16 bits


=== levels/Opcodes ===

$19693461238792* Fixe l'incrément du compteur à 4
$20916717363300* Point d'observation {nr} doit cibler la sortie
$38976231780455* Point d'observation {nr} doit cibler un registre ou un composant personnalisé contenant un registre
$18189600217529* [center]Implémente l'instruction OPCODE[/center]
$13450117997204* Ajoute un compteur dans le circuit
$77044880242883* Point d'observation {nr} doit cibler le compteur
$13870568875751* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$10303603301757*
Implémente les opcodes suivants :
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

L'opcode NOT ignore le second argument.
$17495651785164* Ajoute 6 registres à la carte


=== levels/test_lab ===

$11038144815919*
Ce niveau utilise des programmes pour tester tes circuits. Quand les programmes sont lancés, ce niveau vérifie si l'"état surveillé" évolue comme attendu.

Le labo a 2 mots-clés supplémentaires.

Le mot-clé [color=#c54d5e]expect[/color] sert à décrire la valeur attendue au cycle suivant à une adresse mémoire.

La première valeur après [color=#c54d5e]expect[/color] est l'index de l'état surveillé, la seconde est la valeur attendue. L'index de l'état surveillé correspond à l'ordre dans lequel les composants sont connectés au composant Programme.

[img]dialogue/watched\_state.png[/img]

Par exemple :
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]\_[/color] [color=#4a9658]r2[/color][/code]

Ici la première ligne indique que nous attendons une valeur de 4 en 2ème position de l'état surveillé.

Toutes les valeurs des états surveillés sont comparées aux valeurs attendues à chaque cycle. Toutes les valeurs sont attendues à 0 au démarrage du programme, et tu peux ensuite modifier explicitement ces valeurs attendues. La seule exception concerne les compteurs, il est attendu qu'ils s'incrémentent à chaque cycle.

[color=#c54d5e]set\_input[/color] est le second mot-clé spécifique au labo. Avec lui tu peux contrôler l'entrée de l'ordinateur :
[color=#c54d5e]set\_input[/color] [color=#eb9433]123[/color]

Tu peux en permanence également (ré)importer les tests d'exemple en cliquant ci-dessous :
[url=import\_overture][color=#e49f44]OVERTURE[/color][/url]
$32399229965611* De plus, comme tu viens de finir [color=#e49f44]LEG[/color], j'ai débloqué tous les composants 16, 32 et 64 bit que tu trouveras dans le bac à sable.
$15446846177093* Bienvenue au labo. Comme l'atelier de composants, ce n'est pas un niveau normal mais un outil.
$16072814175447* Programmer du matériel bugué est très frustrant. Il est pénible de devoir soudainement se poser des questions sur les circuits quand on est en pleine résolution d'un problème de programmation. Il est tentant de faire un correctif rapide afin de revenir au problème initial. Mais maintenant ce correctif vite fait a cassé autre chose dans un programme qui fonctionnait jusque là et ainsi de suite. Au final, en développant le matériel essaie de viser 100% de fiabilité avant de démarrer la programmation !


=== trans/level_ram_component_value_description ===

$53113984441582*
[right]Test
Adresse
Action
Sortie attendue[/right]


=== ui/options/Controls ===

$53266310714298* Contrôles


=== components/Mem Unit ===

$57670626909848* 1 bit de mémoire
$78616473760551* mémoire 1 Bit


=== ui/state_ui/title_screen/play ===

$66967233942803* Campagne


=== misc/run ===

$67345621265845* Démarrer les cycles (Raccourci : F6)


=== levels/byte_not ===

$14196498898485* La réalisation et l'utilisation d'outils est fondamental lors des premières étapes de l'évolution de l'intelligence.
$12982025748137* Applique "NOT" sur chaque bit de l'octet en entrée.
$10294533225655* Notre précédent modèle utilisant la taille du cerveau pour prédire l'intelligence était naïf.
$14958585065722* En fait c'est le nombre de bras d'une créature qui est clairement le principal prédicateur de l'intelligence. Savais-tu qu'il existe des créatures marines sur ta planète avec quatre fois plus de bras que toi et qui réussissent mieux dans les tests ?


=== misc/credit_box ===

$15872341864658*
Remerciements sincères à

[b]Traducteurs[/b]
{translators}

[b]Premiers béta-testeurs[/b]
{beta_testers}

[b]Polices de caractères adaptées[/b]
{font_work}

[b]Musique Originale[/b]
 Adolfo Aaron Figueroa Bianchi

[b]Logiciels Open Source[/b]
{software}

[b]Ressources[/b]
{assets}


=== components/Maker64 ===

$17464069717985* Créateur 64 bits
$79677187590355* Transforme 64 bits en 8 octets


=== trans/manual_ASCII_encoding ===

$30404865580119* Code ASCII


=== trans/options_pan_right ===

$33884219481037* Déplacer la vue vers la droite


=== trans/options_pan_left ===

$78515694621006* Déplacer la vue vers la gauche


=== trans/not_gate_RichTextLabel2 ===

$10340875578771*
[right][color=#e49f44]Input[/color]
Desired output
Current output[/right]


=== misc/lab_toggle ===

$16432178820878* Labo


=== levels/Calculations ===

$14458828731919*
C'est maintenant qu'il faut intégrer le circuit "Unité Arithmétique" réalisé précédemment avec le circuit registre. Le circuit de calcul a été enregistré dans l'atelier de composants et est maintenant utilisable en tant que composant. Si tu as oublié à quoi correspondent les pattes retourne regarder le circuit dans l'atelier de composants.

Utilise le décodeur déjà construit pour déterminer si l'on doit copier de registres à registres ou faire un calcul. Voici pour rappel les 4 modes possibles:
[OFF][OFF] Constante
[ON][OFF] Copie
[OFF][ON] Calcul
[ON][ON] Condition

Pour ce niveau tu n'as pas à t'occuper que des modes copie et calcul, lis les [INSTRUCTIONS] détaillées dans le panneau du haut. En mode calcul, prends [color=#e49f44]REG 1[/color] et [color=#e49f44]REG 2[/color] comme entrées et envoie le résultat dans [color=#e49f44]REG 3[/color].

[tip]Pense à la patte de désactivation du décodeur 3 bits.[/tip]
$13013863429580* Pour ce niveau une patte supplémentaire a été ajoutée aux registres. Cette patte émet toujours en sortie la valeur du registre même lorsque la lecture n'est pas activée.


=== trans/instructions_header ===

$15089281203426* [center]Instructions[/center]


=== components/Program4 ===

$27522667367787* Programme
$45650720555565* Composant mémoire programmable


=== trans/options_controls ===

$18297012748869* Contrôles


=== levels/Counter ===

$17701404772563* Ajouter 1
$17940006660359* Compter
$17263901743088*
Construis un compteur qui s'incrémente de 1 à chaque cycle.

De plus il doit y avoir la possibilité de forcer le compteur à une valeur fournie.

Tu reçois 2 entrées, un bit et un octet.

Le bit en entrée permet de basculer entre les modes comptage et enregistrement de la valeur de l'octet.
$68874699768861* Enregistrer {value}
$10555159894041*
Compter est tellement fondamental que même les insectes le font. À partir de là, les espèces peuvent évoluer vers la comparaison et le calcul. Et alors que l'on ne s'y attend pas, voilà que des singes construisent des ordinateurs...

Réalise un composant qui compte en s'incrémentant une fois par cycle.


=== components/Constant32 ===

$39402227599142* Valeur constante
$30896164786171* Constante 32 bits


=== trans/manual_text_ram ===

$10969790213397*
This simulator has several types of RAM different trade-offs, similar to real life RAM options.

[b]RAM[/b]
The RAM component can store a lot of data, but adds a very high delay to the circuit.

[b]Fast RAM[/b]
The fast RAM has a low delay, but a very high gate cost per byte.

[b]Latency RAM[/b]
The normal RAM has very high delay, however instead of waiting for this delay each tick, we can treat the RAM as if load and save takes multiple ticks. The number of ticks save and load will take depends on the length of each tick. Say for example that our circuit has a delay of 100 units, a load would take 10 ticks, since we have to wait about 1000 units of delay. 

A common approach for pipelined architectures is to use Latency RAM as for main memory, but use a small amount of Fast RAM for caching. Since memory access is often adjacent or close (for example when looping over an array), fetching adjacent values when loading from Latency RAM and caching them in Fast RAM can significantly speed up certain kinds of programs.

The simplest way to integrate the Latency RAM is simply to stall the whole architecture while waiting for a save or load. An easy optimization on this comes from realizing that you don't have to wait for saves, except if you want to load.

[b]Dual Load RAM[/b]
Sometimes it is beneficial to separate parts of the logic into a separate processing unit, that operates more or less independently. This could be for handling a display device or a network connection. In these cases, the independent unit will often need to continuously load and save to memory, while the outside logic only needs to occasionally load. Use Dual Laod RAM to avoid having to schedule who gets access to the RAM at what time.


=== components/Xor16 ===

$55408021160573* XOR bit à bit sur 2 valeurs
$47846591761838* XOR 16 bits


=== trans/level_tick_tock_keys ===

$11700778730606*
[right][color=#e49f44]Action
Desired output
Current output[/color][/right]


=== components/And32 ===

$98890160152994* AND bit à bit sur 2 valeurs
$30264879217145* AND 32 bits 


=== components/AND ===

$22719674432950*
[ON] quand les deux entrées sont [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]
$58912167455465* AND (ET)


=== trans/manual_text_ascii_encoding ===

$57727768059917* This simulator uses (extended) ASCII in a few places. Below are the characters with their corresponding number. The console supports different versions of extended ASCII.


=== trans/manual_text_short_circuit ===

$31105471890701*
In electronics, two components outputting different values on the same wire causes a short circuit.

[center][img=100]res://dialogue/short_circuit.png[/img][/center]

However, by disconnecting output pins from a wire, it is possible for multiple pins to share the same wire (called a bus). Importantly, at most 1 component output should remain connected each tick, otherwise you risk a short circuit.

[center][img]res://dialogue/switch.png[/img][/center]

In this simulator, pins that can be disconnected are grey.


=== trans/map_locked ===

$95146987030704* Verrouillé


=== trans/manual_assembly ===

$14434902453525* Assembleur


=== trans/nand_values ===

$38006065064488*
[right][color=#e49f44]Input 1
Input 2[/color]
[b]Output[/b][/right]


=== levels/decoder ===

$16133643476631* Le circuit que tu as créé dans le niveau "Registres" peut copier des valeurs entre différents registres, tandis que "l'Unité arithmétique et logique" a la capacité de faire différentes opérations avec ses deux entrées.
$18435544383511* CALCULER\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18945946395447*
Pour distinguer les 4 [INSTRUCTIONS], nous utiliserons les deux bits de plus haut poids qui définieront le MODE dans lequel nous serons.
Cette liste montre les 4 modes à implémenter:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Valeur immédiate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculer
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copier
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition logique

Ici [ANY] veut dire que l'ont peut avoir n'importe quelle valeur.

Déterminez le mode dans lequel nous sommes à partir de l'entrée et envoie [ON] vers la sortie correspondante.
$15105859227432* COPIER \n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12671132029272* Ton circuit à été sauvegardé dans l'atelier de composants.
$12068329066372* [b]ATTENTION: CETTE VERSION DU CIRCUIT EST OBSOLETE, IL FAUT CLIQUER SUR L'ICONE DE SAUVEGARDE ET CREER UNE NOUVELLE VERSION DE CE CIRCUIT[/b]
$11382827588408* Condition logique\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611* Valeur immédiate\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* Valeur immédiate


=== trans/level_compute_xor_description ===

$61886892927185* [center]Pairwise AND together each bit[/center]


=== trans/manual_truth_tables ===

$75695254533352* Tables de vérité


=== trans/options_effects_volume ===

$24145565754506* Volume des Effets


=== trans/level_signed_negator_description ===

$87777776285772* [center]Invert the sign of the number[/center]


=== main_scripts/overture_level ===

$11338791453100* Dynamic
$27259865408750* Au prochain cycle la valeur du compteur sera {next}, on attend {expected}
$95030012922256* L'Entrée doit être activée seulement si nécessaire
$12873109232054* On attendait {expected} en sortie, pas {got}

#  "cond" is for condition, this label has to be short as it has to fit on a component
$94982725578534* COND
$47188699762650* La Sortie devrait être activée et ce n'est pas le cas
$28026304798371* La Sortie ne devrait être activée que quand c'est nécessaire
$85260864781281* L'Entrée devrait être activée et ce n'est pas le cas
$96569633331621* Charge {value} dans le REG 0
$16914143080303* Copy
$59042824277105* Immediate
$82949244692745* Calculate
$83829200305236* On attendait {expected} en sortie, pas {got}


=== levels/Further Delayed Lines ===

$17366913897135* Construis un circuit dont la sortie est identique à l'entrée avec un retard de 2 cycles.
$60989431641221*
Ce niveau présente le composant Ligne à Retard. Sa sortie est identique à l'entrée avec 1 cycle de décalage.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356*
Nous avons besoin de valeurs négatives dans les octets. Le système que nous avons utilisé jusqu'ici représente tous les nombres de 0 à 255 avec un octet. Ce système est appelé "non signé", car il ne gère que les nombres positifs.

Nous avons besoin d'un système pour gérer les nombres négatifs, habituellement nommé représentation "signée".

De plus, cela simplifierait grandement les prochains circuits si la représentation fonctionnait avec l'additionneur que tu as déjà réalisé.
$17231048881956* Pour mesurer la différence entre deux valeurs, tu as besoin de la soustraction. Pour soustraire, tu as d'abord besoin des nombres négatifs.
$70755151984986* {a} devrait être {b}
$11067230116844* {number} n'a pas de représentation
$62744038163781* OK
$19118970740682*
[color=#dd6576]Modifie les valeurs[/color] pour chaque bit de façon à respecter les objectifs suivants :

[color=#e49f44]1[/color]: Tous les nombres de -127 à 127 doivent pouvoir être représentés
[color=#e49f44]2[/color]: Les Octets représentant les valeurs de 0 to 127 doivent être les mêmes qu'en non signé.
[color=#e49f44]3[/color]: Le nouveau système doit fonctionner avec l'additionneur (pour les résultats entre -127 et 127).
$15431436023571* Tu as deux façons de représenter 0\nCe qui conduit à 0 + 1 = 0
$28284583096369* 1 plus -1 n'est pas égal à 0\n  
$57604042654667* {number} n'a pas de représentation


=== levels/robot_race ===

$15403032472607* La course de robots est notre sport favori sur le vaisseau. Des robots programmés par différentes personnes vont essayer d'arriver à a fin de la course le plus rapidement possible. Le gagnant sera le programmeur dont le programme aura le moins de ligne.
$19966247197959* Cette fois-ci tu contrôleras FastBot : il ne peut pas voir ce qu'il y a devant lui, mais il peut tourner et avancer durant le même coup d'horloge. (Il porte aussi des baskets rouges pour aller plus vite).


=== levels/NAND Gate ===

$17420270098223* Dans ce niveau, le but sera de comprendre comment fonctionne une porte NAND. Sois [color=#dd6576]sur[/color] de savoir comment elle fonctionne avant de valider le niveau, sinon tu pourrais être bloqué dans le prochain!
$11034378482152* Correct ! Tu as débloqué la porte NAND. Avec ce composant tu pourras construire tout le reste de ton ordinateur!
$18270083417453* Vérifier
$19208664264770* [b]Consigne[/b]\nClique sur l'un des boutons de la dernière ligne du tableau.
$17923274216766* Nous en avons conclu que tu n'es probablement pas une plante.
$14777350869870* Nous sommes impressionnés par ta capacité à résoudre le dernier test !
$17994568832660* [b]Consigne[/b]\nLa porte NAND au milieu du circuit change son comportement.\nUtilises la barre sur la gauche pour expérimenter les effets qu'ont les entrées sur les sorties et compléte le tableau en conséquence.


=== components/DelayLine8 ===

$24840584785792* Envoie en sortie au prochain cycle l'entrée de ce cycle 
$63449911993783* Ligne à retard 8 bits


=== trans/options_copy ===

$55679445263875* Copier


=== trans/nand_Label2 ===

$60885816586685* Output


=== trans/tooltip_tooltip ===

$48829429502039*
[b]Run fast[/b]
[color=#cccccc][i]Run your computer without updating the UI at each tick[/i][/color]


=== components/Bit Compressor ===

$74338505460996* Rassemble 8 bits en 1 octet
$98747779812970* Créateur 8 bits


=== components/Input 2 ===

$86870364449392* Entrée


=== components/Bidirectional8 ===

$20234315861487* Patte bidirectionnelle 8 bits
$49499540884410* Permet de contourner certaines erreurs de dépendance cyclique


=== trans/options_pan_down ===

$93140495547084* Déplacer la vue vers le bas


=== components/Mux64 ===

$14050204031082* Alterne entre deux valeurs
$66892629981737* Multiplexeur 64 bits (Mux)


=== trans/options_reset_warning ===

$19141523477461*
Toutes les solutions des niveaux, les composants personnalisés et les architectures seront supprimées. Cela ne peut être annulé, es tu sûr de vouloir le faire ?
(Le jeu sera fermé, il sera réinitialisé au prochain démarrage)


=== trans/manual_hard_disk ===

$45865138134248* Disque dur


=== components/NOR ===

$27510848535619*
[ON] quand aucune entrée n'est [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell]
[/table]
$83375115196253* NOR


=== levels/hex_racer ===

$33474352861351* Level {x}
$92057009138253* Comment écrire {number} en binaire ?
$16009852370452*
Quand on manipule beaucoup de bits, le binaire commence à être difficile à lire. L'Hexadécimal (base 16) représente chaque combinaison de 4 bits par son propre caractère :
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

Voici un exemple de la meilleure lisibilité de l'hexadécimal, comparons les représentations du plus grand nombre de 16 bits :
[code]
Binaire :     1111111111111111
Décimal :     65535
Hexadécimal : FFFF
[/code]

Ce n'est pas facile de dire s'il manque un chiffre binaire ou s'il y a un décalage en décimal, mais l'hexadécimal est tout de suite clair (au moins une fois qu'on prend l'habitude).
$40775762006843* Wrong answer
$84691609525475* Ce niveau est mon deuxième passe-temps préféré. Convertir de l'hexadécimal au binaire en temps limité.
$45532697833519* Niveau {level} atteint !
$87016829502381* Très bien, tu as atteint le niveau {current_level}.
$43463538043782*
Modifie les bits du panneau pour atteindre le nombre hexadécimal demandé.

Tu dois finir le niveau 3 pour réussir.

(clique [color=#e63e5b][url=accessibility_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours)


=== trans/level_full_adder_RichTextLabel2 ===

$25766177620842*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== components/Ror8 ===

$10802217509530* Rotation à droite des bits d'une entrée
$70999134800536* Rotation à droite


=== levels/Water World ===

$13739681561355* Volume Total : 
$19185457941725* Bonne nouvelle, nous voulons transformer la Terre en un parc aquatique exotique !
$18940654086036* Nous avons besoin de ton aide pour trouver un bon emplacement pour le toboggan aquatique "Glissade du Pirate". En particulier nous cherchons un espace qui peut contenir un grand volume d'eau.
$14706805272652* Appuie sur Entrée pour montrer l'eau
$12881972193444*
Le terrain mesure 16 colonnes de large. Lis l'entrée 16 fois pour trouver la hauteur disponible pour chaque colonne de gauche à droite.
  
Envois alors en sortie comme réponse le volume total que le terrain peut contenir.


=== components/NAND ===

$71130919681688* NAND
$12903183841172*
[ON] sauf si les 2 entrées sont [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== trans/map_arithmetic ===

$51337598329530* ARITHMÉTIQUE


=== trans/rotate ===

$88236351843942* Rotation


=== levels/delay_level_check ===

$59355217078543* Correct!
$68999077595244* Check
$90847326020954* Nope!


=== levels/Dancing Machine ===

$14975070588197*
Nous aimons tous la façon dont le Robot bouge sur la piste de dance. C'est pourquoi nous le voulons à la tête de notre équipe de danceurs.
  
Le seul problème c'est de lui faire trouver des séries de mouvements originaux. Comment pourrait-on bien obtenir de la créativité à partir d'une logique déterministe ?

La solution a pour nom générateurs de nombres pseudoaléatoires.
$15955150920362*
Dans ce niveau tu n'as qu'une entrée, nous l'appellerons la graine initiale. La graine passe par les étapes suivantes pour produire un nombre pseudoaléatoire.

Dans l'algorithme ci-dessous, "shl 1" signifie un décalage à gauche,  "shl 2" signifie double décalage à gauche et "shr 1" un décalage à droite.

[b]8 bit xorshift RNG :[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Ensuite envoie en sortie next_seed mod 4 pour déplacer le robot. Enfin utilise next_seed (avant le mod 4) comme graine pour obtenir le nombre suivant pour la séquence de danse et ainsi de suite.

(Attention la graine initiale ne sera jamais 0)


=== trans/options_color_wire ===

$64341547590822* Colorer le fil


=== misc/program_edit_signals ===

$98772447663910* Éditer les points d'observation


=== misc/credits ===

$15234594767991* Crédits


=== main_scripts/levels ===

$64510812504271*
Certains composants utilisés ne sont pas supposés être disponibles dans ce niveau !
La solution n'obtient pas de score.

#  Level type for the level complete menu
$58769207148712* Component

#  Level type for the level complete menu
$90134890578411* Misc

#  Level type for the level complete menu
$69219742310717* Architecture


=== trans/level_decodre_RichTextLabel2 ===

$40723962298647*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired bit
Current bit[/right]


=== trans/manual_bytes ===

$46223559629673* Bytes


=== trans/manual_matrix_display ===

$86092436010494* Affichage par matrice de points


=== trans/options_music_volume ===

$93981778736076* Volume de la Musique


=== component_panels/Counter ===

$57936010210151* Incrementer de : {amount}


=== trans/level_complete_ide ===

$56719825235196*
[b]CODE IDE[/b]
[color=#cccccc][i]Name codes and edit them in a convenient editor[/i][/color]


=== trans/level_alu2_code ===

$93157894815498* [center]OR[/center]


=== misc/binary_submit ===

$95509904060545* Submit


=== trans/and_gate_3_RichTextLabel2 ===

$52008707927408*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== components/ByteConstant ===

$29445030761909* Valeur Constante
$25159790815891* Constante 8 bits 


=== components/Maker16 ===

$55864807379312* Assemble 16 bits en 2 octets
$39941195789458* Créateur 16 bits


=== components/Output64 ===

$43552728118031* Sortie


=== trans/level_decoder_description ===

$10169248860836* [center]Decode the instruction[/center]


=== components/Switch16 ===

$15221175893882* Commutateur 16 bits
$59845475842015* Active/Désactive une valeur


=== components/LessU32 ===

$72614358420262* Inférieur (non signé)
$55380524073095* Détermine si une entrée est inférieure à l'autre


=== trans/options_level ===

$64744152268407* Niveau


=== levels/sandbox ===

$17054292175058* Bienvenue dans le bac à sable, ici tu es libre de t'amuser librement. Je t'ai donné des fils de 64 bits et quelques composants supplémentaires d'Entrées/Sorties (IO).
$10731996208080* Il y a également des versions 64 bit du programme, du compteur, du registre et de la RAM. Rappelle-toi que les lectures en RAM 64 bits prennent 1 cycle.
$72764802067974*
Bienvenue dans le bac à sable. 

Les composants sont disponibles dans les menus du côté droit. Une fois placée, clique sur les pattes du composant et glisse pour les connecter au circuit. À gauche tu trouveras l'interface pour le contrôle de la simulation. Note que tu peux utiliser le clic droit sur le bouton "Vitesse d'Exécution" pour sélectionner la vitesse de ton choix.

Tu peux trouver plus d'information sur la simulation dans le manuel (bouton en haut à gauche). Les fonctions importantes à voir sont l'"atelier de composants" qui te permet de créer tes propres composants and le composant programme, qui te permet de définir ton propre langage assembleur.
$19454393978813* Le mini clavier te permet de contrôler ton ordinateur directement avec ton  clavier.
$14434122873489* Le générateur de forme d'onde (Waveform) te permet de générer des sons. Je vais probablement regretter de t'avoir donné celui-là.
$18405942066048* L'horloge donne l'heure UNIX courante en microsecondes.
$10451578314373* L'Écran Console te permet de dessiner des caractères sur un écran (voir caractères ASCII dans le manuel)


=== components/Output64z ===

$61656790122480* Sortie commutée
$42506906257154* Sortie activée seulement quand la patte d'activation est [ON]


=== trans/level_complete_stat_type ===

$69511102367948* Type


=== ui/toggles/race_condition ===

$75558678297830* Dépendance circulaire


=== trans/options_paste ===

$52159578521318* Volume de la Musique


=== trans/level_double_buffer_RichTextLabel3 ===

$27208335953837*
[right]Input
Desired output
Current output[/right]


=== trans/manual_text_terminology ===

$99266452352883*
[b]Instruction[/b]
A byte or a few bytes that together make the computer perform a specific action.

[b]Opcode[/b]
The part of the instruction that determines which operation (like ADD or AND) is to be done.

[b]Memory address[/b]
A number used as a name for memory locations (often for registers). These are used to specify where an instruction is supposed to load data from or save data to.

[b]Jump[/b]
Changing the value of the program counter, changing which instruction is loaded next.


=== trans/manual_text_truth ===

$16559670174521*
The tables of input and output which are used everywhere throughout the game are commonly known as truth tables.








"Input" and "Output" will often be represented with variable names, like in algebra. And instead of using colors, you will often see the values represented as 0 / 1 or False / True.


=== levels/Conditionals ===

$10794262854382*
Ajoute des instructions si à ton circuit. Avec l'instruction si, les 2 arguments sont comparés et si la condition est vraie, le compteur est chargé avec une adresse de saut.

L'instruction précédente contient 4 octets qui représentent :  
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, RÉSULTAT[/color][/code]

Pour l'instruction si les octets représentent :
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, ADDRESSE\_SAUT[/color][/code]

En plus des copeops précédents, ajoute :
[code][color=#87a8c8]32 SI\_EGAL
33 SI\_NON\_EGAL
34 SI\_MOINS
35 SI\_MOINS\_OU\_EGAL
36 SI\_PLUS
37 SI\_PLUS\_OU\_EGAL[/color][/code]

Compare avec les composants pour nombres non signés.

Chaque opcode fait ce que son nom indique. Par exempie pour sauter à l'octet 16 si REG0 est inférieur à REG1 : 
[code][color=#87a8c8]SI\_MOINS REG0 REG1 16[/color][/code]
$18542005958715* Définis l'incrément du compteur à 4
$17133561664335* Félicitations, tu as terminé l'ordinateur [color=#e49f44]LEG[/color] !
$14973719570693* Ajoute un compteur au circuit
$12920514303805* Ajoute 6 registres au circuit
$14309211963063* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$16826220977157*
 [color=#b72d41][b]ASTUCE[/b][/color] 
 COPY est identique à ADD avec un second
 argument à 0
$14690660047411* [center]Implémente les opcodes conditionnels[/center]
$30132649789584* Le point d'Observation {number} doit pointer sur la sortie
$18994998239232* Je vais te montrer quelques évolutions que tu peux faire, afin d'implémenter les appels de fonction. Mais à partir de là tu devras t'occuper des détails, je ne te dirai plus quels opcodes utiliser, etc.
$12034111753799* Le point d'Observation {number} doit pointer sur le compteur
$36561706158040* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre


=== levels/byte_less ===

$11252365204151* Réalise un circuit dont la sortie est [ON] quand la première entrée est inférieure à la seconde. Les octets sont [color=#dd6576]NON SIGNES[/color].
$62766453128684* Est ce que {a} est inférieur à {b}?
$11632471752785* [center]Détermine si la première entrée est inférieure à la seconde.[/center]


=== levels/Logic Engine ===

$15865646260225*
 [color=#b72d41][b]PROVERBE[/b][/color] 
 La douleur est temporaire, la gloire est 
 éternelle.
$17594613477534*
Réalise un circuit qui peut effectuer les opérations OR, NAND, NOR et AND sur deux entrées. La troisième entrée sera l'[INSTRUCTION]. Une [INSTRUCTION] est juste le nom du nombre qui indique ce que l'on doit calculer.

Instructions :
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Enfin tu ne peux pas déplacer les composants rouges dans ce niveau, pour des raisons que l'on t'expliquera plus tard.


=== misc/multi_select ===

$85147529532131* Sélection multiple (Raccourci : SHIFT & glisser)


=== trans/level_byte_less_i_description ===

$21195810950441* [center]Determine if the first input is less than the second.[/center]


=== components/Splitter16 ===

$92674917729864* Répartiteur 16 bits
$28271182652741* Répartit 16 bits en 2 octets


=== trans/manual_text_universal_gates ===

$37735744928195*
It turns out that you can build all the logic for a computer out of either NAND or NOR gates. The Apollo guidance computers, were built entirely of NOR gates. Designed in the sixties, they had only 4KB of RAM and 32KB of disk space, but guided astronauts to the moon nonetheless.

Modern computers are not built entirely of just one of the universal gates, but when applicable NAND gates are preferred over NOR, because they have less delay and occupy less area.


=== components/Splitter64 ===

$80420054807186* Répartit 64 bits en 8 octets
$14205692632393* Répartiteur 64 bits


=== misc/component_button ===

$75542474510177* PORTE
$63839315669055* DELAI


=== components/SRLatch ===

$11641785582600* Bascule SR
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== trans/levels_byte_or_description ===

$68379799788575* [center]Pairwise OR together each bit[/center]


=== components/Output 3 ===

$96269858195218* Sortie


=== components/Output 1B ===

$77044600156969* Sortie


=== components/Xor64 ===

$95012060885697* XOR 64 bits
$13031452187028* XOR bit à bit de deux valeurs


=== misc/skipped_custom ===

$38174137226538* Select component

#  This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728* Go to location


=== components/ByteXor ===

$98219910712564* XOR 8 bits
$83236921580268* XOR bit à bits de 2 valeurs


=== levels/counting_signals ===

$10724914203078*
Le composant sortie de ce niveau est un compteur binaire dont les 3 premières pattes correspondent à 1, 2 et 4.
Utilise le compteur binaire pour compter le nombre de signaux.

Regarde [color=#e63e5b][url=counting_signals]cet indice[/url][/color] si tu te retrouves coincé

[i][tip]La solution de ce niveau n'est pas très propre et nécessite pas mal de composants.[/tip][/i]
$10881918807029*
 [color=#b72d41][b]ASTUCE:[/b][/color] 
 Il n'y a pas de honte à utiliser
 une feuille et un stylo


=== levels/Spacial Invasion ===

$19967210826470* Attention : tu ne peux tirer avec le laser que lorsque les tir précédents ont disparus.
$16294185981398* Le soute du vaisseau est infesté de rats de l'espaces.
$11505369795084* Regarde [color=#e49f44][url=the\\_robot]la page du robot[/url][/color] pour connaître les instructions pour le programmer. Tu peux aussi trouver un lien vers cette page dans l'éditeur de programmes.
$10515630949378* Nous avons connecté ton ordinateur à notre robot avancé et nous voulons que tu le programmes pour qu'il dératise la soute.


=== misc/button_next ===

$50213503063080* Prochain cycle (Raccourci : F5)


=== components/Nand8 ===

$50859914201083* NAND bit à bit de 2 entrées
$93314093190526* NAND 8 bits


=== components/Add64 ===

$14174811828377* Ajoute 2 entrées
$73418471595285* Ajouter


=== ui/toggles/level_map ===

$71951682957395* Carte des niveaux


=== components/DivMod64 ===

$80284847781948* Diviser
$71663353206665* Diviser et calculer le modulo de deux nombres


=== levels/saving_bytes ===

$10633476398156*
Créez un circuit qui pourra [SAUVEGARDER] ou [CHARGER] un octet.


Lorsque le premier bit est [ON], [CHARGER] la mémoire et envoyez la vers la sortie.
Lorsque le second bit est [ON], [SAUVEGARDER] l'octet en entrée.
$13502950630653*
[color=#ff9800]Aucune
0
0[/color
$19109563882664* NE PAS CHARGER
$16372198430230* SAUVEGARDER
$15498440508450* Ne rien faire
$15582618410991* CHARGER ET SAUVEGARDER
$18873598212433* CHARGER


=== levels/byte_constant ===

$12641789008694* Créez un système qui sortira toujours le nombre 164.


=== main_scripts/leg_level ===

$70383685548547* REG 
$53021804895845* ETi
$69956969985790* OUi
$85913831661289* SI\_INFERIEUR
$11144256835662* XORi
$20104629254326* ARGUMENT 2
$61412773713567* SOUSTRACTION
$65642901654732* {component} devrait être désactivé
$52344899983501* SI\_INFERIEUR\_OU\_EGAL
$89945092889418* SOUSTRACTIONi
$89011349770597* NOT
$71559031724238* SI_NON_EGAL
$98778676892898* {component} devrait être actif avec la valeur {value}
$40520283279584* XOR
$71204580217527* NOTi
$71195301111400* ADDITIONi
$98178474649432* SI\_SUPERIEUR\_OU\_EGAL
$68187490877029* SI_EGAL
$14186606871089* Au prochain cycke la valeur du compteur sera {wrong_value} alors qu'on attend {value}
$27868897434461* Composant compteur introuvable
$37810243909140* COMPTEUR
$38681417496680* ARGUMENT 1
$43723329256095* REGISTRE {nr}
$44009845985661* ADDITION
$50722296752142* ENTREE
$68666991962246* OU
$24003300271049* {component} devrait avoir la valeur {value} et non {wrong_value}
$79492115258673* SI\_SUPERIEUR
$60997201855346* ADRESSE DE RESULTAT
$50231510806554* Composant programme introuvable
$64519909700148* ET
$49810487048038* COMPTEUR
$18236360532765* SORTIE
$84307766381146* OPCODE (code d’opération)


=== levels/call_ret ===

$15840165316981*
Dans ce niveau tu as pour tâche d'implémenter les appels de fonctions et les retours avec les instructions [color=#e49f44]call[/color] et [color=#e49f44]ret[/color].

Fais attention au retour d'une fonction, tu dois sauter à l'adresse qui vient APRÈS l'instruction [color=#e49f44]call[/color], sinon tu te retrouveras avec un boucle infinie.
L'instruction [color=#e49f44]call[/color] doit réaliser les actions suivantes :
 [i]- Ajouter la longueur de l'instruction au compteur et [color=#e49f44]EMPILER[/color] cette longueur sur la pile[/i]
 [i]- Sauter à l'adresse de la fonction[/i]

L'instruction [color=#e49f44]ret[/color] doit réaliser les actions suivantes :
 [i]- [color=#e49f44]DÉPILER[/color] l'adresse de retour de la pile et sauter à cette adresse[/i]

Tu peux échanger de l'information avec et depuis une fonction en écrivant normalement les données dans des registres. Rappelle-toi quels registres sont écrasés par une fonction avant de l'appeler.
$19416009887091*
Parfois il est utile de réutiliser le même morceau de code. On appele ces morceaux des "fonctions". Pour pouvoir les utiliser, on pourrait utiliser le color=#e63e5b][url=termonology]jump[/url][/color] pour sauter au début de la fonction et pour en ressortir à la fin. On appele cette méthode "l'appel" d'une fonction et le retour au programme le "retour" de la fonction.

Mais pour que l'on puisse utiliser ce morceau de code plusieurs fois, on doit pouvoir sauter à des endroits différents lors du retour, dépendant de l'endroit dans le programme où l'on a appelé la fonction.

On pourrait sauvegarder la valeur du compteur dans un registre avant de sauter dans la fonction et utiliser cette valeur pour en ressortir. Cependant, en faisant comme ça on pourrait écrire par dessus la valeur du registre si on appele une fonction depuis une autre fonction et on ne pourrait jamais revenir au programme principal.

Par exemple:
Disons que la fonction A appelle la fonction B qui appelle a son tour la fonction C. Quand on voudra revenir en arrière on aura besoin que de l'adresse de retour de la fonction B et une fois dans B on aura besoin que de l'adresse de retour de la fonction A. En général, indépendamment du nombre d'appels de fonctions, la première adresse stocké sera toujours utilisé en dernier. Magiquement, c'est exactement le comportement du stack.
$19369640789869* Les coupes budgétaires ont conduit à réduire les salaires, et maintenant les assistants du labo sont en grève. Tu vas devoir t'autoévaluer dans ce test. Cela nous permettra d'évaluer ton niveau d'honnêteté et de maturité.
$15463931654475* [center]Ajoute les instructions "call" et "ret"[/center]


=== levels/odd_ticks ===

$18510295620397* Met la sortie à [OFF] pendant les cycles impairs et [ON] pendant les cycles pairs.
$16987046679863* Tu as appris précédemment que nous n'acceptons pas les dépendances circulaires. Il existe cependant une exception à la règle que tu vas voir maintenant.
$16037516781370*
Les pattes des composants carrés ne vont pas affecter la sortie du composant pendant le même cycle, c'est pour cela que l'on peut les utiliser pour les dépendances circulaires. 
  
  [img]dialogue/delay\\_buffer.png[/img]
$17588119878416*
Le ligne à retard a le droit de dépendre de sa sortie, car son entrée ne va pas influencer le reste du circuit jusqu'au prochain cycle.
  
[img]dialogue/delay\\_buffer.png[/img]


=== misc/ProbeWireBit ===

$49521764791439* Sonde de fil (bit)
$15206117280094* Affiche une valeur sur ton composant personnalisé ou dans l'éditeur de programme


=== components/Adder Simple ===

$33973952772642* Ajouter
$98429814030509* Ajoute 2 entrées


=== trans/manual_computer_concepts ===

$60892983318818* Lexique informatique


=== components/ByteShr ===

$89595863403484* Décalage à droite
$69394421220436* Décalage à droite des bits d'une entrée


=== trans/level_sr_latch_RichTextLabel3 ===

$55348415524361*
[right]Entrée 1
Entrée 2
Sortie attendue
Sortie actuelle[/right]


=== trans/level_complete_delay ===

$73470840319057*
[b]Délai[/b]
[color=#cccccc][i]Tu peux désormais voir le délai de tes circuits et des composants.[/i][/color]


=== components/LessU64 ===

$13018528868948* Inférieur (non signé)
$90244529484227* Détermine si une entrée est inférieure à la seconde


=== trans/level_byte_no_description ===

$19806403089477* [center]Inverse chaque bit[/center]


=== trans/level_saving_gracefully_RichTextLabel3 ===

$74117520663650*
[right][color=#e49f44]Valeur
Enregistrée[/color]
Sortie attendue
Sortie actuelle[/right]


=== misc/select_color ===

$97461374731210* Couleur de fil


=== trans/manual_text_instructions ===

$24791538034329*
Ce que ce jeu appelle une "instruction" s'appelle également opération ou opcode (raccourci anglais de code opération. Quelquesoit le système d'exploitation, le langage de programmation et tous les couches logicielles utilisées, tous les logiciels doivent finir par être ramenés à des instructions que le CPU peut exécuter.

A l'intérieur des processeurs modernes, les instructions sont converties en "microcodes" qui correspondent à des étapes encore plus élémentaires et sont inaccessibles au programmeur.


=== trans/manual_text_circular_dependency ===

$29050562435902*
Une dépendance circulaire apparaît quand l'entrée d'un composant dépend de sa propre sortie.

[center][img]res://dialogue/circular_dependency.png[/img][/center]

Ce simulateur n'autorise pas les dépendances circulaires et génère alors une erreur.

Les pattes carrées sont une exception, elles influencent la sortie mais lors d'un autre cycle. Elles ne peuvent donc pas causer de dépendance circulaire.

[center][img]res://dialogue/delay_buffer.png[/img][/center]


=== components/LessU16 ===

$91783087669146* Détermine si une entrée est inférieure à la seconde
$33190791348214* Inférieur (non signé)


=== components/Xor32 ===

$66299093873977* XOR 32 bits 
$38169019785615* XOR bit à bit de 2 entrées


=== trans/level_alu2_text ===

$58359423026017*
[right]Code
[color=#e49f44]Entrée 1
Entrée 2[/color]
Sortie attendue
Sortie actuelle
[/right]


=== trans/level_turing_complete_description ===

$74859324795927* [center]Ajoute les conditions aux codes de calcul[/center]


=== trans/level_nand_check ===

$32982011047799* Vérifie


=== trans/level_complete_tooltip ===

$33922330743421*
[b]Couleur de fil[/b]
[color=#cccccc][i]Organise tes schémas avec ces couleurs.[/i][/color]


=== trans/level_odd_number_RichTextLabel2 ===

$28592851869484*
[right][color=#e49f44]Entrée 1
Entrée 2
Entrée 3
Entrée 4[/color]
Sortie attendue
Sortie actuelle[/right]


=== levels/push_pop ===

$78804623186243* SORTIE
$49526452710191* NE PAS DEPILER
$58050047963238* VALEUR
$19245209470436* Créer une pile
$12227209887733* A chaque cycle les entrées indiqueront soit EMPILER soit DÉPILER. Si c'est EMPILER, stocke la valeur en haut de la pile. Quand c'est DÉPILER retire cette valeur de la pile et envoie-la en sortie.
$15662660252584* Ne rien faire
$62469306234943* NE PAS EMPILER
$46948857059388* DEPILER valeur {value} de la pile
$18761197388580* Pour raison d'économies, il a été décidé de gérer différemment les files d'attente dans les établissements publics pour réduire le nombre de demandes. Plus de premier arrivé, premier servi, maintenant la règle ce sera dernier arrivé, premier servi. Imagine une [color=#e49f44]pile[/color] de fiches numérotées o˘ les usagers peuvent called poser leur fiche au-dessus (action [color=#e49f44]EMPILER[/color]) et les fonctionnaires prennent la fiche du haut de la pile (action [color=#e49f44]DÉPILER[/color]). ¿ toi d'implémenter ce nouveau système.
$65188797398656* EMPILER {value} sur la pile


=== trans/level_complete_robot ===

$73150174144736*
[b]Robotron 9000+[/b]
[color=#cccccc][i]Contrôle [color=#e49f44]Robotron 9000+[/color] à l'aide de ton ordinateur[/i][/color]


=== levels/The Product of Nibbles ===

$14957949958941* Ce que tu as fait ici c'est en fait une multiplication de deux nombres de 4 bits. Le stagiaire s'est chargé de l'étendre aux octets.
$19136817138607* [center]Multiplie les nombres de 4 bits[/center]
$13549246864135* Bit 0
$14533861483435* La multiplication de deux nombres de 4 bits donne un nombre de 8 bits. Réalise le schéma adapté.
$10274387271390* Bit 0
$83694551809785* Multiplier {num1} et {num2}


=== levels/byte_and ===

$15885763626223* Réalise un circuit qui applique la fonction AND logique (bit à bit) sur deux octets.


=== components/LessI64 ===

$42718501644862* Inférieur (signé)
$19948786194409* Détermine si une entrée est inférieure à la seconde


=== components/ByteLessU ===

$68645721548287* Détermine si une entrée est inférieure à la seconde
$73502755965496* Inférieur (non signé)


=== main_scripts/functions ===

$11467644007149* Compteur {nr}
$73560327420927* Cette sauvegarde provient d'une version obsolète de ce niveau.\nCrée et charge un nouveau schéma avec le menu schéma.
$99285446909923* Pour résoudre ce niveau tu dois utiliser le composant 'Sortie du Niveau'
$72465734060414* Court-circuit sur le fil (valeurs en sortie  {values})
$10533010562232* SCORE DELAI : {delay}
$10098517717617* Test : {nr} / {total}
$29225283986051* Pour résoudre ce niveau tu dois utiliser le composant 'Entrée du Niveau'
$87591753278764* Registre {nr}
$95056157627313* Pour résoudre ce niveau tu dois utiliser le composant 'Entrée du Niveau'
$29169064199243* Sortie {nr}
$12249248261034* Pour résoudre ce niveau tu dois utiliser le composant 'Sortie du Niveau'
$13327741293223* Entrée {nr}
$32508339206292* SCORE NAND : {nand}


=== ui/global_translations ===


#  Instead of writing 5839000, the number turns into 5.8M
$22896492410578* 10⁶
$91472284749011* DELAI
$21803034737442* cycle
$86260137015175* CYCLE
$44906330481241* Délai
$30602804398798* Porte
$22213999385406* délai

#  Instead of writing 5839, the number turns into 5.8K
$84696693690500* x10³
$39343770421034* porte
$76763908762578* Cycle
$15265492169229* PORTE

#  Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* x10⁹


=== ui/toggles/level_log2 ===

$91515053618360* Aide-mémoire


=== levels/or_gate_3 ===

$15448906128695* Réalise une porte OR avec 3 entrées.


=== trans/binary_racer_count_down2 ===

$23959994711260* Ready to race?


=== components/Shl16 ===

$79406691850426* Décalage à gauche
$34287811246049* Décale à gauche les bits d'une entrée


=== trans/levels_any_doubles_RichTextLabel2 ===

$60287131882436*
[right]Entrée 1
Entrée 2
Entrée 3
Entrée 4[color=#e49f44]
Sortie actuelle
Sortie attendue[/color][/right]


=== trans/map_complete ===

$81337533438394* Complet


=== trans/schematics_menu_visible_label ===

$34084132835354* Visible in menu


=== components/RegisterRedPlus ===

$57531353625235* Registre


=== trans/level_saving_bytes_text ===

$43691912945654*
[right]Action
Etat attendu
Sortie attendue
[/right]


=== trans/level_description ===

$26184794529449* [center]Ajoute les conditions aux codes de calcul[/center]


=== components/Counter64 ===

$62528867413395* Compteur 64 bits 
$62736827510023* S'incrémente à chaque cycle jusqu'à réinitialisation


=== levels/Storage cracker ===

$11910674853271*
La porte sécurisée de la réserve est défaillante et elle enferme régulièrement notre vieil homme de ménage.
La porte n'arrête pas de changer le code d'accès, nous avons besoin d'un programme qui peut le récupérer quand c'est nécessaire.
$17462419719036*
La façon la plus simple de trouver le code serait d'essayer toutes les combinaisons jusqu'à ce que tu trouves la bonne.
Le mécanisme défectueux fait un bruit désagréable quand ton essai est trop grand, il doit être possible d'en tirer profit.
$11183892008673* Tu réussis ce niveau en envoyant en sortie le code correct, il n'est pas possible d'échouer avec une mauvaise sortie. De plus l'entrée sera à 1 après un essai trop grand et 0 sinon.


=== trans/level_alu1_text ===

$53254733455389*
[right]Code
[color=#e49f44]Entrée 1
Entrée 2[/color]
Sortie attendue
Sortie actuelle
[/right]


=== components/Output16 ===

$37381472194529* Sortie


=== trans/level_nand_1 ===

$71204033550134* Que fais la porte NAND ?


=== trans/manual_text_program ===

$25326551844839*
The program component is a read only memory component, that can have its data programmed in assembly. To edit the assembly, click on the yellow edit icon in the corner of the component.

[center][img]dialogue/manual/program_edit.png[/img][/center]

In the middle of the screen you will see the code area, read more about the assembly [color=#4d82c5][url=Assembly]here[/url][/color].

On the left hand side of the assembly editor interface, you can add assembly codes (mnemonics). Assembly codes act as a replacement for numbers, so instead of remembering what number represents the AND instruction in your architecture, you can add "AND" to your assembly codes, making code easier to read and write.

[center][img]dialogue/manual/assembly_codes.png[/img][/center]

On the program component you will also find the "Watch state" button. 

[center][img]dialogue/manual/watch_state.png[/img][/center]

This can be used to connect the assembly editor to registers, counters or probes. This way, the state of your architecture can be inspected as you write code, without closing the editor.


=== components/Input 3 ===

$70689623552857* Entrée


=== trans/options_cut ===

$88238310953306* Couper


=== components/Output32z ===

$73681609562628* Sortie activée seulement si la patte d'activation est [ON]
$92749186427039* Sortie commutée


=== trans/manual_text_top_truth ===

$83283949590490* AND gate


=== trans/and_gate_RichTextLabel2 ===

$98472849629373*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_byte_equal_description ===

$38686097566531* [center]Check if the bytes are equal[/center]


=== components/Clock ===

$72088325385177* Horloge


=== components/Xnor ===

$94079327237795* XNOR
$90614106399129*
[ON] quand les entrées sont égales
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]


=== components/1_decoder ===

$26685462633615* Bascule entre deux sorties
$98250587600120* Décodeur 1 bit


=== trans/tick ===

$92150881431937* Cycle


=== components/XOR ===

$86856280609387*
[ON] quand les entrées sont différentes
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]
$54832952840086* XOR


=== trans/options_undo ===

$58334563411624* Annuler


=== trans/options_robot_down ===

$71118559743827* Bas


=== components/Not16 ===

$17394768116288* NOT 16 Bits
$91053300263019* Inversion bit à bit d'un mot de 16 bits


=== trans/level_complete_manual_page ===

$39011561067359*
[b]Manual Entry[/b]
[color=#cccccc][i]RTFM[/i][/color]

Entry: [color=#68d277]Architectural complexity[/color]


=== misc/factory ===

$53123649343022* Atelier de composants


=== trans/manual_network ===

$67416967652082* Réseau


=== trans/level_complete_stat_level ===

$92313038380926* Level


=== trans/manual_ram ===

$61854681801183* RAM (mémoire vive)


=== trans/manual_header ===

$10757271456963* Aide-mémoire


=== components/Ror16 ===

$13970397213910* Rotation à droite des bits de l'entrée
$90115282457191* Rotation à droite


=== misc/opcode_name ===

$15090156481094* Name


=== ui/top_bar/gate_score ===

$16224450605442* NAND SCORE:


=== trans/xor_gate_RichTextLabel2 ===

$21417732641222*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/options_setting_program_alignment ===

$54874717650167* Code aligné


=== misc/level_gate_unlocks_unknown ===

$76731326010721* Déverrouille quelque chose d'inconnu


=== misc/score_sync ===

$76911045833478* synchroniser le score


=== trans/map_cpu_architecture ===

$95559333192525* ARCHITECTURE PROCESSEUR


=== components/ON ===

$96212935718484* Toujours [ON]
$95896157427528* ON


=== components/RegisterRed ===

$10081371413873* Registre


=== trans/levels_negative_header ===

$82195103144851* [center]Requirements[/center]


=== trans/delete_confirm ===

$57294448765637*
Are you sure you want 
to delete this schematic?
$74657548486940* Yes


=== levels/byte_adder ===

$16888130664370*
Si le résultat prend plus que 8 bits de place, met la sortie retenue à [ON] (tu peux l'utiliser comme un 9ème bit)

Il y a aussi une entrée retenue, elle sera utile pour additionner des octets à la suite. On additionne la retenue en entrée au résultat (0 [OFF] ou 1 [ON]).

Utilise [color=#e63e5b][url=byte\_adder]cet indice[/url][/color] si tu es coincé.
$18732877690173* Additione les deux octets en entrée. Chaque bit en sortie devra être le résultat de l'addition des bits d'entrées et potentiellement de la retenue. 


=== components/Mux32 ===

$16638728645850* Alterne entre deux valeurs
$21257226547838* Multiplexeur 32 bits (Mux)


=== components/Shr32 ===

$87104108203785* Décalage à droite des bits de l'entrée
$88430124157796* Décalage à droite


=== levels/saving_gracefully ===

$12474728041023*
La Ligne à Retard nous permet d'utiliser une valeur un cycle plus tard.

Nous devons réaliser un composant qui nous permet d'utiliser une valeur dans le futur, quel que soit le nombre de cycles plus tard.
Nous appellerons cette valeur [color=#e49f44]sauvegarde[/color].
$13045361823397* NE PAS SAUVEGARDER
$13740696609075*
Ce niveau comporte deux entrées.
La valeur sauvegardée est modifiée seulement quand la première entrée est à [ON].
La seconde entrée est la nouvelle valeur de la [color=#e49f44]sauvegarde[/color].

Envois toujours en sortie la [color=#e49f44]sauvegarde[/color].


=== trans/levels_bytw_or_text ===

$21877344150481*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== components/DelayLine64 ===

$80000130396288* Ligne à retard 64 bits
$35525647389906* Envoie en sortie au prochain cycle l'entrée de ce cycle 


=== trans/level_unseen_fruit_description ===

$96313037592447* [center]Use the robot to scan the fruit[/center]


=== trans/manual_Cyclic recipes ===

$45682345144408* Circular recipes


=== main_scripts/dialogue ===


#  hint for odd number
$68750974209145* Tu peux déterminer si 2 entrées ont un nombre impair de [ON] avec juste un unique composant...

#  hint for the bus
$50799425816171* Utilise des commutateurs pour placer les entrées sur le même fil.

#  Hint for byte switch
$86319296925137* A quoi cela ressemblerait si tu ne commutais qu'un seul bit ? A quoi ressemblerait la table de vérité d'un tel composant ?

#  Hint for the maze
$36837749971886*
En suivant toujours le mur gauche (ou droit) du labyrinthe tu es sûr d'atteindre la sortie au bout d'un moment.

Le pseudo-code pour cet algorithme est à peu près :
 Avance d'un pas
 Tourne à gauche
 Tourne à droite tant qu'il y a un mur en face
 Tente d'ouvrir une porte (au cas ou la sortie serait en face) 
 Recommence

#  Hint for byte adder
$37093555217568* Tu n'as besoin que de 8 additionneurs complets.

#  hint for counting signals
$21044442262778* Le schéma pour les bits impairs est semblable à ce qui a été fait pour "Nombre IMPAIR de Signaux". Pour les bits pairs c'est comme dans "Doublement compliqué", sauf si les 4 sont ON.

#  hint for saving gracefully
$25321701584378*
Dans ce niveau tu dois utiliser 1 Ligne à Retard. Ecris la table de vérité de ce qui doit aller dans la Ligne à Retard. Traite l'entrée de la Ligne à Retard comme la sortie de ta table.

Les entrées sont les 2 entrées du niveaux ET la sortie de la Ligne à Retard, car la sortie dépend modifie sa propre entrée. Au total tu as trois "entrées" pour cette table ce qui fait 8 combinaisons. Une fois que l'objectif du niveau est sous forme de table, il devrait être beaucoup plus simple à résoudre.

#  Hint for conditions
$87674181578455*
Il y a 3 bits de conditions. Quand le premier bit est [ON] cela signifie que la condition est validée pour un résultat à 0. Quand le second bit est [ON] cela signifie que la condition est validée pour un résultat inférieur à 0. Si aucun des 2 premiers bits n'est [ON] la condition est validée.
Enfin si le dernier bit est [ON] inverse la valeur de la condition obtenue.

#  hint for xor gate
$88963098241493* Ce level peut être réalisé avec 3 composants, une porte NAND, une AND et une OR.

#  Hint for masking time
$46866534894828*
En binaire, calculer le modulo 4 d'un nombre revient à conserver seulement les 2 bits de poids faible. C'est dû au fait que les bits supérieurs représentent 4,8,16 qui sont tous multiples de 4.
C'est vrai en général pour le modulo d'une puissance de 2, le bit le plus faible représente le nombre modulo 2 (pair ou impair), les 3 bits les plus faibles le modulo 8 et ainsi de suite.

De même, en décimal 4321 modulo 100 est aussi simple à calculer (la  réponse est 21, les chiffres de rang supérieur sont ignorés), du fait que 100 est une puissance de 10.

Maintenant tu dois juste trouver comment obtenir les 2 derniers chiffres d'un nombre.

#  hint for less
$56438995128380*
D'abord tu dois déterminer quels bits sont différents entre les 2 octets. Ceci peut se faire avec un XOR octet (souvenons nous que XOR est [ON] quand les entrées diffèrent). Nous savons que le nombre qui a le plus haut bit différent à [ON] est le plus grand. Mais il ne faut considérer que le plus haut bit différent, donc pour chaque bit, utilise un chaine de portes OR pour vérifier si un bit supérieur est [ON].

Enfin, le dernier bit doit être considéré séparément pour les nombres signés, il a l'effet opposé (si un seule nombre l'a [ON], ce nombre est forcément inférieur)


=== trans/instructions_the_robot ===

$26621808961883*
[color=#e49f44]0[/color] Move right
[color=#e49f44]1[/color] Move down
[color=#e49f44]2[/color] Move left
[color=#e49f44]3[/color] Move up
[color=#e49f44]4[/color] Enjoy the moment
[color=#e49f44]5[/color] Use action [color=#a9a9a9](enter)[/color]
[color=#e49f44]6[/color] Shoot laser [color=#a9a9a9](tab)[/color]


=== trans/nor_gate_RichTextLabel2 ===

$52955821161579*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== components/Nand32 ===

$24565725389553* NAND bit à bit de 2 valeurs 32 bits
$71611588991682* NAND 32 bits


=== trans/options_robot_controls ===

$44632988778557* Contrôles du Robot


=== trans/manual_text_edit_instructions ===

$75786562031150*
After you complete the level "Turing Complete" the instruction panel allows you to manually edit instructions. This is useful if you wish to build your own computers.

If you just finished the OVERTURE computer and see something weird, odds are you may have changed the definitions.

Each row has a label and 8 bits you can set to either[img]dialogue/on.png[/img], [img]dialogue/off.png[/img] or [img]dialogue/any.png[/img] (wildcard). When using the instruction panel, if the bitpattern matches a row, the label will be shown.


=== components/Rol32 ===

$88734684504266* Rotation à gauche des bits d'une entrée
$83642246004160* Rotation à gauche


=== trans/odd_number_error ===

$61530231182650* Too many components used


=== components/ByteAnd ===

$61791872137683* AND bit à bits de deux valeurs
$21541105796357* AND 8 Bits


=== trans/options_code_font_size ===

$98135524286922* Taille de la police du code


=== components/Counter ===

$51446864816252* S'incrémente à chaque cycle hors réinitialisaition
$67910883947749* Compteur 8 bits


=== trans/ide_assembly_codes ===

$62016169253008*
[center]Assembly
codes[/center]


=== trans/options_general_title ===

$21908594290225* Général


=== levels/binary_start ===

$19099025738142* Start


=== components/Keyboard ===

$40965596602414* Clavier
$76766452660421* Enregistre les appuis de touches de ton clavier


=== trans/level_byte_xor_text ===

$15756501406553*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== components/Input1_1B ===

$10517158300617* Entrée
$57868504368581* Lit l'entrée des niveaux (CHECKME)


=== trans/manual_edit_instructions ===

$86365051641280* Edit instructions


=== trans/manual_text_network ===

$70445160410129*
[b]Overview[/b]
The "Network" component gives you low level access to networking. In general you manipulate your network by sending the component [color=#e49f44]Requests[/color] and when update [color=#39aa49]Events[/color] return from the network they get queued up and you process them one at a time. To keep track of different simultaneous connections [color=#dd6576]Connection ID[/color]s are used.

These are the request types you can send to the component and their arguments:
[code]0[/code] No request
[code]1[/code] [color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])
[code]2[/code] [color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])
[code]3[/code] [color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])
[code]5[/code] [color=#e49f44]Read next event[/color]
[i]See component panel for which pin correspond to which argument.[/i]

Request types [color=#e49f44]Listen[/color] and [color=#e49f44]Connect[/color] outputs the [color=#dd6576]Connection ID[/color] of the new connection.

For 2 programs to [color=#e49f44]Send data[/color] to each other, one program must first [color=#e49f44]Listen[/color] (called a server) on a [color=#dd6576]Port[/color] and the other must then [color=#e49f44]Connect[/color] (called a client), using the [color=#dd6576]IP[/color] of the listening program and the [color=#dd6576]Port[/color] it selected. Once the connection is established, the server and client function exactly the same.

Notice an [color=#dd6576]IP[/color] is a 32 bit number, normally written as 4 bytes with dots in between (example: 127.0.0.1). In this simulator you reverse the order of the bytes, so 127.0.0.1 becomes 0x0100007F. 0x0100007F is always your computers loopback address and you can use this to connect programs running on the same computer.

You can detect when events happen on the network, by checking the "Next event type" pin. These are the event types:
[code]0[/code] No event
[code]1[/code] [color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])
[code]2[/code] [color=#39aa49]Connect complete[/color]
[code]3[/code] [color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])

[color=#39aa49]Incoming connection[/color] only happens after a [color=#e49f44]Listen[/color]. Use the [color=#dd6576]Port[/color] to distinguish between listeners (it is not possible to listen to the same port twice at the same time).

[color=#39aa49]Connect complete[/color] only happens after a [color=#e49f44]Connect[/color], wait for this before you start sending data.

You may send or receive between 1 and 8 bytes of data at a time, use the [color=#dd6576]Data length[/color] to decide.

A connection may be either "possibly open" or "closed". There is no way to know if a connection is actually open other than sending data. The underlying network protocols were designed like this for reliability and speed, it is not a limitation of the simulator.

If you get a [color=#dd6576]Connection ID[/color] of -1, this means there was an error connecting.


=== levels/unseen_fruit ===

$13023474026617*
Les fruits sont la découverte la plus remarquable sur ta planète. Ils sont très savoureux.

C'est pourquoi nous organisons une dégustation de fruits dans cette cantine.
$14259900563789* Surveille régulièrement le tapis roulant sur lequel les fruits arrivent. Si tu vois le même type de fruit pour la seconde fois, active et tourne le panneau de contrôle.
$17070232883226* Mais nous voulons être sur de ne pas avoir deux fois le même fruit, car cela serait trop embarrassant.


=== ui/toggles/negative_numbers ===

$50924073287410* Choix du format de nombre


=== misc/factory_back_inner ===

$12211557416281* Revenir au niveau


=== levels/conditions ===

$12951779797594*
Dans ce niveau il y a en entrée une valeur et 3 bits de condition.

Les 3 bits déterminent la condition comme indiqué ci-dessous. Évalue la valeur en fonction de la condition et envoie [ON] si elle est vérifiée et [OFF] sinon.

Code condition       Sortir [ON] si [code]
[OFF] [OFF] [OFF]    Jamais
[OFF] [OFF] [ON]    Si valeur = 0
[OFF] [ON] [OFF]    Si valeur < 0
[OFF] [ON] [ON]    Si valeur ≤ 0
[ON] [OFF] [OFF]    Toujours
[ON] [OFF] [ON]    Si valeur ≠ 0
[ON] [ON] [OFF]    Si valeur ≥ 0
[ON] [ON] [ON]    Si valeur > 0[/code]
$16407231803964* Si VALEUR < 0 sortie [img]dialogue/on.png[/img]
$16742265812068* Quelquesoit la VALEUR output [img]dialogue/on.png[/img]
$17616699231679* Si VALEUR > 0 sortie [img]dialogue/on.png[/img]
$16632557438774* Si VALEUR ≠ 0 sortie [img]dialogue/on.png[/img]
$18234235689107* Si VALEUR ≥ 0 sortie [img]dialogue/on.png[/img]
$12429396872036* Quelquesoit la VALEUR output [img]dialogue/off.png[/img]
$13680487623452* Si VALEUR ≤ 0 sortie [img]dialogue/on.png[/img]
$19014698800906* Si VALEUR = 0 sortie [img]dialogue/on.png[/img]
$12706881725738* Ton circuit a été enregistré dans l'atelier de composants.


=== components/ByteShl ===

$74488427658653* Décalage à gauche
$66482114876737* Décalage à gauche des bits d'une entrée


=== trans/manual_instructions ===

$90323246286028* Instructions


=== components/Add16 ===

$28092601427278* Ajoute deux entrées
$30820974870562* Ajouter


=== levels/and_gate ===

$15232844525838*
Réalise le circuit qui correspond au tableau.
  
[tip]Double-clique sur un composant pour le déplacer avec son groupe de fils connectés directement.[/tip]
$15231724707514* Je ne veux pas te décourager, mais je pense que l'éléphant va gagner la compétition. Sans vouloir t'offenser, ton cerveau est tout petit en comparaison.


=== components/Not32 ===

$33620523355085* NOT 32 bits
$24607331341411* Inversion bit à bit d'un mot de 32 bits


=== trans/schematics_description ===

$39347262933523* Description


=== trans/nand_Label ===

$11482037025960*
Input 1


Input 2


=== components/MemoryProbe ===

$46948613505134* Affiche une valeur sur ton composant personnalisé ou dans l'éditeur de programme
$44867305035474* Sonde Mémoire


=== trans/options_working ===

$18749833316380* Actif


=== trans/level_component_factory_error ===

$49014901714855* Map squares can only contain one input or output node.


=== misc/StateProbe ===

$54427436420428* Sonde de fil
$15969687819995* Affiche une valeur sur ton composant personnalisé ou dans l'éditeur de programme


=== trans/options_robot_use ===

$49182380646128* Utiliser


=== trans/map_working_computer ===

$38843517090942* ORDINATEUR FONCTIONNEL


=== trans/manual_text_rgb ===

$52915933943906*
This simulator uses 3 byte RGB colors for some components. Color are 1 byte each, the byte value determining the intensity of each color: 
[color=#e3243f]RRRRRRRR[/color][color=#55ff55]GGGGGGGG[/color][color=#3333ff]BBBBBBBB[/color]


=== trans/level_ram_component_RichTextLabel2 ===

$92123299522120* [center]Expected states[/center]


=== levels/sr_latch ===

$11150103897185*
Dans ce niveau, les composants peuvent dépendre d'eux-mêmes ou former des boucles contenant 2 composants. Malgré ces dépendances certains de ces circuits ont des sorties stables, au moins pour certaines valeurs en entrée.

Le circuit que l'on te demande de construire ici a une dépendance circulaire. Le circuit a aussi 2 "états stables" pour la plupart des entrées. Un état stable signifie ici que les sorties de chaque composant sont en accord avec leurs entrées. Par exemple, une porte OR avec une entrée déconnectée et l'autre connectée à sa propre sortie est stable. Si la sortie est [OFF], les 2 entrées sont [OFF], ce qui est acceptable pour la porte OR. Si la sortie est [ON] alors l'une des entrées l'est aussi. Par contre, une porte NOT connectée à sa propre entrée n'est pas stable. Si la sortie est [ON], alors l'entrée l'est aussi. Cela fait que la porte NOT essaie de changer sa sortie en [OFF]. Le circuit va osciller entre ces deux états indéfiniment et il n'est donc pas stable.
$15754153332116*
Ce niveau présente le concept de bascule. Ce dispositif n'est pas utilisé ailleurs dans le jeu. Néanmoins ce niveau existe pour une raison d'exhaustivité.
  
Si tu n'as aucune expérience en électronique, il est recommandé de sauter ce niveau. Tu pourras toujours revenir plus tard.
$18165461234561* Les lignes à retard sont simples à comprendre et peuvent être utilisées pour construire n'importe quelle architecture d'ordinateur. Pourtant le matériel moderne ne les utilise plus comme base des mémoires.
$15213907597666* Avec 2 portes NOR, construisez le circuit qui correspond à la table. Tu auras besoin d'une bascule.
$19448398663695*
Pour déterminer quels composants contrôlent la sortie dans une dépendance circulaire, il est impossible de fixer un composant de départ. À la place nous utilisons les valeurs des fils du cycle précédent. Cela s'explique par le fait que les électrons ne se déplacent pas instantanément dans la réalité. En fonction du câble, le circuit oscille entre [ON] et [OFF], ou se fixe dans un état stable.
  
Quand un circuit peut se fixer dans 2 états stables distincts, tu as la base pour une mémoire. L'état suivant dépendra des valeurs sur les fils du cycle précédent. De tels circuits sont appelés "bascules".


=== trans/complete_unlocks ===

$45250062735373* Unlocks


=== components/FastRam ===

$79436020115192* Mémoire rapide mais à coût élevé en portes
$12924829814634* RAM rapide


=== levels/byte_xor ===

$19636386696963* Réalise un circuit qui applique XOR bit à bit sur deux octets.


=== trans/level_RichTextLabel2 ===

$12683441099336*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== trans/manual_program ===

$91120798735036* Programme


=== levels/Immediate Values ===

$64348543296709* Le point d'Observation {value} doit pointer sur la sortie
$14060810229477* Ajoute 6 registres dans le circuit
$79667526283284* Le point d'Observation {value} doit pointer sur le compteur
$14960344494328*
Parfois il est utile de charger une valeur directement depuis le programme que d'un registre. Cela s'appelle charger une valeur immédiate. Pour l'architecture [color=#e49f44]LEG[/color] l'opcode indique directement que nous voulons faire cela. C'est possible de la façon suivante :

Quand le 8ème bit de l'opcode est [ON], utilise l'argument 1 comme une valeur immédiate et non comme une adresse de registre.
Quand le 7ème bit de l'opcode est [ON], utilise l'argument 2 comme une valeur immédiate et non comme une adresse de registre.
	
		[img]dialogue/leg_diagram.png[/img]
$10788301006338* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19338533633006* Définis l'incrément du compteur à 4
$15197362332657* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$18004215603701* Ajoute un compteur au circuit
$10141611261952* [center]Implémente les valeurs immédiates[/center]


=== components/switch ===

$87345192339084* Active/désactive une valeur
$29301846684808* Commutateur 8 bits


=== components/Register64 ===

$86007777261800* Régistre 64 bits
$99461037008796* Mémoire 64 bits


=== levels/Wire Spaghetti ===

$29329105515650* Ajoute un registre de plus au circuit
$17106892574116* Ajoute un compteur au circuit
$50177586789991* Ajoute {nr} registres de plus au circuit
$15754373587500* Définis l'incrément du compteur à 4
$56024330661504* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19099471819164*
Voici les premières choses à faire pour résoudre ce niveau :
    
[b]1.[/b] Clique l'icône schéma ([b][i]?[/i][/b]) et crée une nouvelle architecture.
[b]2.[/b] Ajoute un bloc de programme avec 4 sorties.
[b]3.[/b] Ajoute un compteur, définis son incrément à 4 et connecte-le au bloc de programme.
[b]4.[/b] Ajoute 6 registres (ou 6 composants personnels contenant un registre)
[b]5.[/b] Clique "Editer point d'observation" sur le composant programme et connecter les registres aux points 0 à 5. Connecte le compteur au 6 et la sortie au 7.
$18860645759682*
L'architecture [color=#e49f44]LEG[/color] est un ordinateur qui lit 4 octets de programme par cycle. 

Le premier octet correspond à l'opération (called the [color=#e49f44]OPCODE[/color]).

Comme beaucoup d'opérations prennent 2 arguments (ADD, OR etc.), les second et troisième octets servent pour les arguments.

Et comme la plupart des opérations retourne 1 résultat, le quatrième octet est pour le résultat.
  
  [img]dialogue/leg\_diagram\_1.png[/img]
$11377431500625* Ajoute 6 registres au circuit
$14051336765362* Enfin c'est maintenant que tu commences à construire l'architecture [color=#e49f44]LEG[/color] !
$13268807052125* (Tu pourras additionner 7+7, mais ici 7 signifie lire depuis l'entrée et l'entrée a pour valeur 8)
$30006055126224* Le point d'Observation {output} doit pointer sur la sortie
$19066122929275* [center]Met en place les registres et implémente l'opcode ADD [/center]
$10912834168905*
Enfin, pour ce niveau l'[color=#e49f44]OPCODE[/color] est toujours 0. Cela veut dire qu'il faut additionner les arguments 1 2 et envoyer le résultat sur la destination.

Les valeurs utilisées pour les arguments ou la destination sont les suivantes :
[code]
[color=#e49f44]0[/color]: Registre 0
[color=#e49f44]1[/color]: Registre 1
[color=#e49f44]2[/color]: Registre 2
[color=#e49f44]3[/color]: Registre 3
[color=#e49f44]4[/color]: Registre 4
[color=#e49f44]5[/color]: Registre 5
[color=#e49f44]6[/color]: Compteur
[color=#e49f44]7[/color]: Entrée/Sortie
[/code]

Dans le niveau suivant tu implémenteras d'autres [color=#e49f44]OPCODES[/color], ce qui nécessitera une nouvelle ALU différente de celle d'[color=#e49f44]OVERTURE[/color].
$10922418807673* L'argument 7 nécessite de lire sur l'entrée, mais l'entrée n'est pas active.
$62258842382434* Le point d'Observation {counter} doit pointer sur le compteur
$18769284297247* Créé un nouveau schéma et ajoute un programme avec une sortie sur 4 octets.


=== trans/schematic_new_file_name ===

$24424463568668* New schematic


=== trans/options_resubmit ===

$13328644005279* Réessayer


=== trans/negative_numbers ===

$57872971841486* Nombres négatifs


=== trans/level_bit_adder_RichTextLabel2 ===

$79624864981341*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== components/Output8zLevel ===

$49513138880387* Sortie


