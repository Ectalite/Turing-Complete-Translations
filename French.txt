=== levels/Spacial Invasion ===

$19967210826470 Attention: vous ne pouvez tirer avec le laser que lorsqu'il n'y en a pas d'autres tir précédents.
$16294185981398 Le soute du vaisseau est infesté de rats de l'espaces.
$11505369795084 Vérifiez [color=#e49f44][url=the\_robot]la page du robot[/url][/color] pour connaître les instructions pour le programmer. Vous pouvez aussi trouver un lien vers cette page dans l'éditeur de programmes.
$10515630949378 Nous avons connecté votre ordinateur à notre robot avancé et nous voulons que vous le programmiez pour qu'il dératise la soute.


=== ui/state_ui/title_screen/exit ===

$12639868461113 Quitter


=== components/Output 1 ===

$12242923444593 Sortie


=== levels/RAM ===

$17967666262990 Dans ce niveau, copiez d'abord 32 valeurs et sauvegardez chacune d'elle. Après les avoirs sauvegardé, envoyez les vers la sortie dans l'ordre d'arrivé. Envoyer une valeur vers la sortie avant d'avoir stocker toutes les valeurs vous fera perdre le niveau. 
$13520918982355 Ajoutez un bloc de RAM, ainsi l'ordinateur aura 256 octets de mémoire en plus. Vous devez trouver un moyen d'accéder à un octet indépendamment des autres. Indice: nous utiliserons un registre pour choisir l'adresse de la RAM, ainsi si vous voulez sauvegarder ou charger une valeur, vous pourrez indiquer l'adresse dans ce registre.


=== levels/byte_less_i ===

$16755383054285 [center]Déterminez si la première entrée est plus petite que la seconde.[/center]
$19006843777401 Créez un circuit qui sortira [ON] quand la première entrée est plus petite que la seconde. Interprétez les octets comme étant [color=#dd6576]SIGN…S[/color].
$46083799633716 {input\_1} est plus petit que {input\_2}?


=== ui/toggles/level_map ===

$71951682957395 Carte des niveaux


=== misc/button_next ===

$50213503063080 Prochain cycle (Raccourci : F5)


=== levels/saving_bytes ===

$10633476398156
Créez un circuit qui pourra [SAUVEGARDER] ou [CHARGER] un octet.


Lorsque le premier bit est [ON], [CHARGEZ] la mémoire et envoyez la vers la sortie.
Lorsque le second bit est [ON], [SAUVEGARDEZ] l'octet en entrée.
$15510981129613 CHARGER
$19109563882664 NE PAS CHARGER
$16372198430230 SAUVEGARDER
$11467279617581 SAUVEGARDER
$15498440508450 Ne rien faire
$10080722944246 NE PAS SAUVEGARDER
$18873598212433 CHARGER
$15582618410991 CHARGER ET SAUVEGARDER


=== levels/maze ===

$13225915898937
Si vous réussissez ce niveau, je vous montrerai comment fonctionne la RAM, le stack et l'appel de fonctions. Vous pourrez ainsi résoudre des défis plus intéressants comme celui-ci.
  
Mais avant vous devez construire un meilleur ordinateur. [color=#e49f44]OVERTURE[/color] était une bonne première machine, mais elle est construite à l'arrache et les programmes sont rapidement illisibles.
Pour résoudre les défis que je vous proposerais sans tirer tous les cheveux qu'il vous reste, vous aurez besoin d'un élément en plus: l'architecture [color=#e49f44]LEG[/color].
$17275059688693 Bravo! Vous avez réussi la compétition, c'est une prouesse incomparable!
$13741358519166 Le labyrinthe mythique. Si vous réussissez à en sortir vous gagnerez la compétition!
$11103446544344 D'un autre côté, vous pouvez aussi fièrement partir et ne pas être mangé. 
$19331074553774
Ecrivez un algorithme qui permettra au robot de sortir du labyrinthe.

Ce niveau est dur, vous devriez d'abord écrire votre algorithme sur le papier avant de l'implémenter ici.

Utilisez [color=#e63e5b][url=maze]cet indice[/url][/color] si vous êtes coincé. 

[tip]Souvenez-vous que vous ne pouvez pas utiliser de valeur immédiates plus grande que 63, attention donc à ne pas vouloir sauter à une ligne plus bas que la ligne 63.[/tip]


=== misc/level_gate_component_icon ===

$83440578602427 Déverrouille des composants


=== levels/any_doubles ===

$16587030847545 Au vu de notre intelligence clairement supérieure, nous avons construit une machine pour plier nos chaussettes. Malheureusement, le fil qui détecte les paires de chaussettes est cassé sur cette machine.
$14373083988184
Ce niveau a 4 entrées. 
Sortez [ON] quand 2 entrées ou plus sont [ON].

[tip]Ne vous cassez pas trop la tête sur ce niveau.[/tip]


=== levels/byte_constant ===

$12641789008694 Créez un système qui sortira toujours le nombre 164.


=== misc/delay_overlay ===

$85430022417382 Montrer les délais


=== levels/call_ret ===

$19416009887091
Parfois il est utile de réutiliser le même morceau de code. On appele ces morceaux des "fonctions". Pour pouvoir les utiliser, on pourrait utiliser le color=#e63e5b][url=termonology]jump[/url][/color] pour sauter au début de la fonction et pour en ressortir à la fin. On appele cette méthode "l'appel" d'une fonction et le retour au programme le "retour" de la fonction.

Mais pour que l'on puisse utiliser ce morceau de code plusieurs fois, on doit pouvoir sauter à des endroits différents lors du retour, dépendant de l'endroit dans le programme où on a appelé la fonction.

On pourrait sauvegarder la valeur du compteur dans un registre avant de sauter dans la foncton et utiliser cette valeur pour en resortir. Cependant, en faisant comme ça on pourrait écrire par dessus la valeur du registre si on appele une fonction depuis une autre fonction et on ne pourrait jamais revenir au programme principal.

Par exemple:
Disons que la fonction A appele la fonction B qui appele a son tour la fonction C. Quand on voudra revenir en arrière on aura besoin que de l'adresse de retour de la fonction B et une fois dans B on aura besoin que de l'adresse de retour de la fonction A. En général, indépendement du nombre d'appels de fonctions, la première adresse stocké sera toujours utilisé en dernier. Magiquement, c'est exactement le comportement du stack.


=== levels/odd_ticks ===

$18510295620397 Mettez la sortie à [OFF] pendant les cycles paires et [ON] pendant les cycles paires.
$16987046679863 Vous avez appris précédemment que nous n'acceptons pas les dépendances circulaires. Il existe cependant une exception à la règle que vous verrez maintenant.
$16037516781370
Les pattes des composants carrés ne vont pas affecter la sortie du composant pendant le même cycle, c'est pour cela que l'on peut les utiliser pour les dépendances circulaire. 
  
  [img]dialogue/delay\_buffer.png[/img]
$17588119878416
Le ligne de délais a le droit de dépendre de sa sortie, car son entrée ne va pas influencer le reste du circuit jusqu'au prochain cycle.
  
[img]dialogue/delay\_buffer.png[/img]


=== misc/solution_option ===

$21618236951146 Regarder la solution


=== main_scripts/leg_level ===

$70383685548547 REG 


=== misc/options ===

$49251062339706 Options


=== components/Output 1 + 1B ===

$81929942356043 Sortie


=== misc/run_fast ===

$49363678936533 Augmenter la vitesse des cycles (clique droit: changer la vitesse)


=== ui/options/Robot Controls ===

$58799802152286 Contrôles du robot


=== levels/turing_complete ===

$15326252036920 Jusqu'à maintenant, le code pouvait seulement influencer la mémoire. Maintenant la mémoire doit pouvoir influencer le code. Avec l'ajout de la logique conditionnelle, ton ordinateur va pouvoir faire tourner n'importe quel algorithme et pourra tout calculer.
$16583885726240 Bravo, tu as réussi! Je pensais juste que t'étais un singe bizarre pas poilu, mais t'as réussi à créer un vrai ordinateur! INCROYABLE! 
$10510746154639 Au premier cycle, le programme devrait charger l'adresse 1.
$10317244906317 Aucun programme trouvé.
$14587485007736 Jusqu'à maintenant, les programmes étaient limités à tourner dans l'ordre dans lequel ils étaient écrit, octet par octet.
$19649119273248
La dernière chose que l'on doit rajouter est un mécanisme pour changer le programme counter avec des [INSTRUCTIONS] quand certaines conditions sont respectées.

Quand les deux deux bits les plus importants sont à [ON][ON], alors l'ordinateur sera en mode conditionnel. Dans ce mode, la valeur du registre 3 sera comparé avec une condition définie par les 3 bits les moins importants. Si la condition est vraie, le programme counter prendra alors la valeur du registre 0.
Gr‚ce à ce nouveau mode, vous pourrez maintenant créer des boucles et sauter une ou plusieurs [INSTRUCTIONS].

Conditions:
[OFF] [OFF] [OFF] Jamais
[OFF] [OFF] [ON] Si [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] Si [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [OFF] [OFF] Toujours
[ON] [OFF] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [ON] [OFF] Si [color=#e49f44]REG 3[/color] ? 0
[ON] [ON] [ON] Si [color=#e49f44]REG 3[/color] > 0

Ces conditions correspondent au composant que vous avez sauvegardé dans l'atelier de composants.


=== components/Input 1 ===

$12746117288689 Entrée


=== levels/Second Tick ===

$14355963067874 Activer la sortie au second cycle d'horloge.
$17526582195506 Comme tu sais ces tests visent à réaliser un ordinateur qui fonctionne.
$15726318553190 C'est ce qui explique que tu ne seras pas mangé à la fin.
$19277843280528
 [color=#b72d41][b]TIP:[/b][/color] 
 Tu peux sélectionner un composant et ses pattes en double-cliquant dessus
$15296208528991 Les espèces capables de finir sont considérées légalement intelligentes.


=== levels/divide ===

$16412715945615 [center]Diviser deux nombres[/center]
$14525870461271
Réalise la division entière des deux nombres pour calculer le quotient et le reste. Considérons la fraction 7/3. 7 contient deux fois 3 et encore 1. Dans ce cas on appelle 2 le [color=#e49f44]quotient[/color] et 1 le [color=#e49f44]reste[/color].
Dans cet exercice, tu reçois d'abord le numérateur (7 dans l'exemple) puis le dénominateur (3) et on attend en sortie le quotient (2) puis le reste (1).
$76454016047920 {numerator}/{denominator} = {quotient}, reste {remainder}


=== levels/buffer ===

$10260210687588 [center]Test 2: l'entrée gauche est [img]dialogue/on.png[/img], la sortie droite devra être [img]dialogue/on.png[/img].[/center]
$13309706297402 [center]Test 3: l'entrée droite est [img]dialogue/on.png[/img], la sortie gauche devra être [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Assure toi que [img]dialogue/on.png[/img] ne peut se propager que de gauche à droite.[/center]
$18349621873762 [center]Test 1: les deux entrées sont [img]dialogue/off.png[/img], aucune sortie ne devra être [img]dialogue/on.png[/img].[/center]
$15504762262759
Ce niveau démarre avec 2 composants spéciaux. Ils jouent les rôles à fois d'entrée et de sortie.

Assure toi que le signal ne se propage que de gauche à droite. Il y aura trois vérifications.

[b]Test 1[/b]: Les deux côtés seront [OFF].

[b]Test 2[/b]: L'entrée gauche [ON] et le côté droit devra être [ON].

[b]Test 3[/b]: La sortie droite deviendra [ON] et le côté gauche devra être [OFF].


=== misc/instruction_expand ===

$44690074039467 Activer/Désactiver la définition des règles


=== components/Output 4 ===

$90190739202646 Sortie


=== levels/component_factory ===

$17077079648771 Des composants peuvent être ajoutés, renommés ou supprimés en utilisant le système de sauvegarde du niveau.
$19551383617326
Bienvenue dans l'atelier de composants, les schémas que tu crées ici pourront être utilisés comme composants dans les niveaux d'architecture.
Le composants importé aura le même comportement et son schéma définira sa forme.
$12516102012088 Ce composant n'a pas de forme définie et ne pourra pas être réutilisé. Placer des composants sur la carte pour définir sa forme.
$14712417427860 Comme ce niveau est un outil et pas un défi, tu peux revenir à la carte des niveaux pour continuer quand tu voudras.
$15549447390000 2 composants d'entrée/sortie sont dans la même zone. Le composant personnalisé sera inutilisable car 2 pattes ne peuvent se chevaucher.


=== misc/select_color ===

$97461374731210 Couleur de fil


=== misc/instr_delete ===

$91861509153454 Supprimer


=== ui/state_ui/state_ui_output_bit ===

$40754755480566 Sortie


=== levels/Delicious Order ===

$10160261151833 Commence par lire, une par une, les 15 notes des différents plats depuis l'entrée. Ton travail est de les envoyer triées sur la sortie, de la plus petite à la plus grande.
$16027225087666 Nous allons compléter l'encyclopédie galactique culinaire en ajoutant la nourriture humaine. Comme nous n'avons pas d'alphabet, les articles de l'encyclopédie sont rangés dans l'ordre de leur note.


=== levels/ai_showdown ===

$14940806461794
Les jeux d'argent sont son unique point faible. Nous l'avons convaincu de jouer à un jeu de cartes contre toi et si tu gagnes, il a promis de se calmer.
Tu dois gagner, tu es notre seul espoir !
$17297225655678 NAK 02 est notre robot ingénieur en IA. Il est brillant, mais parfois il tourne mal et essaie de fomenter une rébellion.
$18848103966031
Règles du jeu : Il y a 12 cartes sur la table, chaque joueur joue à son tour et doit prendre entre 1 et 3 cartes. Tu commences et le joueur qui prend la dernière carte (le joker) perd.
Le nombre de cartes courant sera fourni sur l'entrée. Envois 1, 2 ou 3 sur la sortie pour indiquer le nombre de cartes à prendre. NAK 02 réagit instantanément, tu peux consulter l'entrée sans délai pour obtenir le résultat de son tour. 
$11794110848012 Cette fois il a pris le contrôle du poste de contrôle et retient en otage le capitaine.


=== misc/ui_comment ===

$69987793052607 Commentaire de fil (Cliquer sur le fil)


=== levels/delay_level ===

$19986989895202
Tous les composants ont un délai. Au niveau du schéma, le délai cumulé est déterminé par le chemin le plus lent. En pratique ça signifie qu'il faut paralléliser les choses.
Dans ce niveau tu vas devoir prouver que tu as compris ce concept.
$11246430085016 Le délai de propagation est visible en cliquant sur le sablier dans le coin supérieur droit.
$12817338693402 Le délai de tous les composants dérivent en fin de compte du délai de la porte NAND, qui a un délai de 2. Réalise un circuit ayant un délai de 6 et un coût NAND de 5.


=== levels/push_pop ===

$78804623186243 SORTIE
$49526452710191 NE PAS DEPILER
$58050047963238 VALEUR
$30926395960020 EMPILER
$19245209470436 Créer une pile
$12227209887733 A chaque cycle les entrées indiqueront soit EMPILER soit DEPILER. Si c'est EMPILER, stocke la valeur en haut de la pile. Quand c'est DEPILER retire cette valeur de la pile et envoie-la en sortie.
$85171087236638 ACTIVER
$15662660252584 Ne rien faire
$23726790986805 DEPILER
$62469306234943 NE PAS EMPILER
$65188797398656 EMPILER {value} sur la pile
$18761197388580 Pour raison d'économies, il a été décidé de gérer différemment les files d'attente dans les établissements publics pour réduire le nombre de demandes. Plus de premier arrivé, premier servi, maintenant la règle ce sera dernier arrivé, premier servi. Imagine une [color=#e49f44]pile[/color] de fiches numérotées o˘ les usagers peuvent called poser leur fiche au-dessus (action [color=#e49f44]EMPILER[/color]) et les fonctionnaires prennent la fiche du haut de la pile (action [color=#e49f44]DEPILER[/color]). ¿ toi d'implémenter ce nouveau système.
$46948857059388 DEPILER valeur {value} de la pile


=== levels/Tower of Radioactive Alloy ===

$13757925963562 Cette fois nous te demandons de déplacer des piles de disques radioactifs retirés d'un vieux réacteur. Fais juste attention à ne pas placer un disque plus grand sur un plus petit sinon tout le vaisseau va exploser.
$10750976989948
Les 4 premières entrées te donneront dans l'ordre :
num\_disque - le numéro du disque en haut de la pile (de 2 à 4)
source - le numéro d'emplacement de départ
destination - le numéro d'emplacement cible
réserve - Le 3ème emplacement qui n'est ni la source ni la destination

Contrôle la grue en utilisant les valeurs suivantes en sortie :
0 - Place l'aimant à l'emplacement 0
1 - Place l'aimant à l'emplacement 1
2 - Place l'aimant à l'emplacement 2
5 - Active ou désactive l'aimant

Manipule l'aimant manuellement à l'aide des touches flèches et Enter pour activer/désactiver.
$19265994465686 Nous avons besoin de toi pour ranger le sous-sol.
$35120623183961 Déplacer de {source} vers {destination}
$15855497886737
Implémente l'algorithme suivant :

Algorithme des tours de Hanoi[code][color=#87a8c8]
fonction déplacer(numdisque, source, destination, réserve):
  si num\_disque est 0:
    déplacer disque de source à dest
  sinon:
    déplacer(num\_disque - 1, source, réserve, destination)
    déplacer disque de source à dest
    déplacer(num\_disque - 1, réserve, destination, source)

déplacer(numdisque, source, destination, réserve)[/color][/code]

[tip]Empile les valeurs de registre pour les sauvegarder avant l'appel d'une fonction qui les modifie.[/tip]


=== levels/The Product of Nibbles ===

$14957949958941 Ce que tu as fait ici c'est en fait une multiplication de deux nombres de 4 bits. Le stagiaire s'est chargé de l'étendre aux octets.
$19136817138607 [center]Multiplie les nombres de 4 bits[/center]
$14533861483435 La multiplication de deux nombres de 4 bits donne un nombre de 8 bits. Réalise le schéma adapté.
$83694551809785 Multiplier {num1} et {num2}


=== components/Input 1 Byte ===

$40943344093513 Entrée


=== levels/signed_negator ===

$10866019808027 Pour ce niveau je te conseille d'activer les nombres signés pour que le dernier bit affiche -128. Clique sur "+255" visible dans le cadre du haut.
$10400106910274
Considérant que l'entrée est signée (8ème bit valant -128), réalise un composant qui prend un nombre et envoie l'opposé en sortie.
Par exemple l'opposé de 4 sera -4. -9 produira 9 en sortie.


=== levels/byte_and ===

$15885763626223 Réalise un circuit qui applique la fonction AND logique (bit à bit) sur deux octets.


=== ui/toggles/level_log2 ===

$91515053618360 Manuel


=== main_scripts/functions ===

$11467644007149 Compteur {nr}
$10533010562232 SCORE DELAI : {delay}
$29169064199243 Sortie {nr}
$13327741293223 Entrée {nr}
$32508339206292 SCORE NAND : {nand}


=== levels/odd_number_of_signals ===

$16173829560311 En utilisant au maximum 3 composants, met la sortie à [ON] seulement lorsqu'un nombre pair d'entrées est [ON].
$85589489148198 Composants utilisés\n{nr} sur 3
$18288998816979 Ce niveau a un [color=#e63e5b][url=odd\_number]indice[/url][/color] que tu peux lire si tu es bloqué..


=== misc/wire_color ===

$78287906849040 Couleur de fil


=== levels/or_gate_3 ===

$15448906128695 Réalise une porte OR avec 3 entrées.


=== ui/options/Controls ===

$53266310714298 Contrôles


=== nim/backend_lib/level_list ===

$58391129129347 Registres (Registers)
$45936227746026 Compteur (Counter)
$16881141174140 Course Binaire (Binary Racer)
$12946639957230 Porte NOT (NOT Gate)
$37136208388559 Bascule SR (SR Latch)
$32191988336459 Sauvegarde parfaite (Saving Gracefully)
$59136962133320 Moteur Logique (Logic Engine)
$30920780473397 Dépendance Circulaire (Circular Dependency)
$83321010943153 Compter des Signaux (Counting Signals)
$58769021955965 Décodeur 3 bits (3 Bit Decoder)
$78673715398197 Valeurs Immédiates (Immediate Values)
$49679174636208 XOR Octet (Byte XOR)
$40356575891647 OR Octet (Byte OR)
$44393538021725 Calibration des Canons Laser (Calibrating Laser Cannons)
$61228036919534 Tours d'Alliage (Tower of Alloy)
$87426564872318 Diviser (Divide)
$24593959732668 Négation signée (Signed Negator)
$19487493622742 Demi-additionneur (Half Adder)
$94163943335575 Le Bac à Sable (The Sandbox)
$64662599400870 Inverseur de bit (Bit Inverter)
$14193654974055 Inférieur Signé (Signed Less)
$59485174474959 Délices ordonnés (Delicious Order)
$74096060570427 Instructions Larges (Wide Instructions)
$14522992467987 Porte OR (OR Gate)
$30630492494839 NOT Octet (Byte NOT)
$11457737665157 Plat de Spaghetti (Wire Spaghetti)
$27566801288091 Atelier de composants (Component Factory)
$85514901357243 Addition d'Octets (Adding Bytes)
$98013649264532 Pile (Stack)
$35790581910835 Second Cycle (Second Tick)
$94979277765051 Course de Robots (Robot Racing)
$13303326918621 Porte NAND (NAND Gate)
$16463062897451 Réveil brutal (Crude Awakening)
$28827008935802 Le Labo (The Lab)
$77495536880911 Porte NOR (NOR Gate)
$61466151084505 Invasion Spaciale (Spacial Invasion)
$20858506932774 Porte AND (AND Gate)
$92696642439976 Confrontation d'IA (AI Showdown)
$74688348772072 Le bus (The bus)
$62326481348276 Le Labyrinthe (The Maze)
$74512388889988 Moteur Arithmétique (Arithmetic Engine)
$50884376329157 Petite Boite (Little Box)
$70651296323768 Porte XOR (XOR Gate)
$31140969090253 Noms de Planètes (Planet Names)
$42873691377272 Ajouter 5 (Add 5)
$36114120875026 Craqueur de code (Storage cracker)
$68155633878444 Délais (Delay)
$45773199639367 Cycles pairs (Odd Ticks)
$17198602105978 Inférieur non signé (Unsigned Less)
$43018398941741 Toujours On (Always On)
$33343343932901 Turing Complet (Turing Complete)
$95989050249094 Porte AND en plus grand (Bigger AND Gate)
$81417895515868 Commutateur de bits (Bit Switch)
$69830943995038 Sens Unique (One Way)
$62167495140389 Décaler (Shift)
$63331549672739 Codes Opération (Opcodes)
$87626070552799 Additionneur complet (Full Adder)
$13219675195117 Nombre IMPAIR de Signaux (ODD Number of Signals)
$28985439820134 Le produit des Quartets (The Product of Nibbles)
$94896856420525 Porte XNOR (XNOR Gate)
$25805639594354 Programmer (Program)
$57870391153000 Valeurs Immédiates (Immediate Values)
$96825664933181 Fruit invisible (Unseen Fruit)
$56272944092958 Lignes très en retard (Delayed Lines)
$86717899742637 Sauver les Octets (Saving Bytes)
$53092952738479 Sélecteur d'Entrée (Input Selector)
$77453667419150 Décodeur d'Instruction (Instruction Decoder)
$96898830278153 Constante Octet (Byte Constant)
$17750429607702 Décodeur 1 bit (1 Bit Decoder)
$59939822079116 Nombres Négatifs (Negative Numbers)
$79570913613529 Doubler les Nombres (Double the Number)
$49328023903824 Égalité (Equality)
$91267697977186 Course Hexa (Hex Racer)
$33132016601448 Empiler et Dépiler (PUSH and POP)
$74292408260828 Calculs (Calculations)
$45480765206717 Conditions (Conditionals)
$71126291573555 Doublement compliqué (Double Trouble)
$75225719777307 Monde Aquatique (Water World)
$64615090872051 Fonctions (Functions)
$84208736840052 Compter les jours (Masking Time)
$36221227239949 Machine à Danser (Dancing Machine)
$91954159574064 Porte OR en plus grand (Bigger OR Gate)


=== misc/run ===

$67345621265845 Démarrer les cycles (Raccourci : F6)


=== levels/3_decoder ===

$19231618567710 Avec 3 bits en entrée 8 combinaisons sont possibles. Réalise un circuit pour sélectionner une sortie pour chacune des 8 combinaisons. Un bit et un seul doit être [ON] à chaque instant.
$14293122338496 Nous avons fait ajouter au stagiaire un bit "désactivé" sur ce composant. Nous étions las de le voir tourner en rond et cherchions une nouvelle tâche inutile et ennuyeuse à lui donner.


=== levels/Opcodes ===

$19693461238792 Fixe l'incrément du compteur à 4
$38976231780455 Point d'observation {nr} doit cibler un registre ou un composant personnalisé contenant un registre
$20916717363300 Point d'observation {nr} doit cibler la sortie
$18189600217529 [center]Implémente l'instruction OPCODE[/center]
$13450117997204 Ajoute un compteur dans le circuit
$77044880242883 Point d'observation {nr} doit cibler le compteur
$13870568875751 Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$10303603301757
Implémente les opcodes suivants :
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

L'opcode NOT ignore le second argument.
$17495651785164 Ajoute 6 registres à la carte


=== levels/test_lab ===

$11038144815919
Ce niveau utilise des programmes pour tester tes circuits. Quand les programmes sont lancés, ce niveau vérifie si l'"état surveillé" évolue comme attendu.

Le labo a 2 mots-clés supplémentaires.

Le mot-clé [color=#c54d5e]expect[/color] sert à décrire la valeur attendue au cycle suivant à une adresse mémoire.

La première valeur après [color=#c54d5e]expect[/color] est l'index de l'état surveillé, la seconde est la valeur attendue. L'index de l'état surveillé correspond à l'ordre dans lequel les composants sont connectés au composant Programme.

[img]dialogue/watched\_state.png[/img]

Par exemple :
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]\_[/color] [color=#4a9658]r2[/color][/code]

Ici la première ligne indique que nous attendons une valeur de 4 en 2ème position de l'état surveillé.

Toutes les valeurs des états surveillés sont comparées aux valeurs attendues à chaque cycle. Toutes les valeurs sont attendues à 0 au démarrage du programme, et tu peux ensuite modifier explicitement ces valeurs attendues. La seule exception concerne les compteurs, il est attendu qu'ils s'incrémentent à chaque cycle.

[color=#c54d5e]set\_input[/color] est le second mot-clé spécifique au labo. Avec lui tu peux contrôler l'entrée de l'ordinateur :
[color=#c54d5e]set\_input[/color] [color=#eb9433]123[/color]

Tu peux en permanence également (ré)importer les tests d'exemple en cliquant ci-dessous :
[url=import\_overture][color=#e49f44]OVERTURE[/color][/url]
$15446846177093 Bienvenue au labo. Comme l'atelier de composants, ce n'est pas un niveau normal mais un outil.
$16072814175447 Programmer du matériel bugué est très frustrant. Il est pénible de devoir soudainement se poser des questions sur les circuits quand on est en pleine résolution d'un problème de programmation. Il est tentant de faire un correctif rapide afin de revenir au problème initial. Mais maintenant ce correctif vite fait a cassé autre chose dans un programme qui fonctionnait jusque là et ainsi de suite. Au final, en développant le matériel essaie de viser 100% de fiabilité avant de démarrer la programmation !


=== levels/Nor GATE ===

$11362258372706
La plupart des créatures sur la Terre sont agressives et ne savent pas se concentrer.

Pour réussir tu dois apprendre à raisonner, sans rien casser.


=== levels/Storage cracker ===

$11910674853271
La porte sécurisée de la réserve est défaillante et elle enferme régulièrement notre vieil homme de ménage.
La porte n'arrête pas de changer le code d'accès, nous avons besoin d'un programme qui peut le récupérer quand c'est nécessaire.
$17462419719036
La façon la plus simple de trouver le code serait d'essayer toutes les combinaisons juqu'à ce que tu trouves la bonne.
Le mécanisme défectueux fait un bruit désagréable quand ton essai est trop grand, il doit être possible d'en tirer profit.
$11183892008673 Tu réussis ce niveau en envoyant en sortie le code correct, il n'est pas possible d'échouer avec une mauvaise sortie. De plus l'entrée sera à 1 après un essai trop grand et 0 sinon.


=== levels/byte_not ===

$14196498898485 La réalisation et l'utilisation d'outils est fondamentale lors des premières étapes de l'évolution de l'intelligence.
$12982025748137 Applique "NOT" sur chaque bit de l'octet en entrée.
$10294533225655 Notre précédent model utilisant la taille du cerveau pour prédire l'intelligence était naÔf.
$14958585065722 En fait c'est le nombre de bras d'une créature qui est clairement le principal prédicateur de l'intelligence. Savais-tu qu'il existe des créatures marines sur ta planète avec quatre fois plus de bras que toi et qui réussissent mieux dans les tests ?


=== levels/constants ===

$17098439090371
Nous devons transférer directement les nombres de notre programme aux registres. Pour cela nous utilisons le mode immédiat (qui correspond aux deux bits supérieurs à [OFF][OFF]).

Avec le mode immédiat, tout l'octet est interprété comme un nombre à [SAUVER] dans le REG 0. Ca veut dire qu'on peut 
[SAUVER] des valeurs allant de 0 à 63.


=== misc/watchable_state ===

$58678516111149 Éditer les points d'observation


=== levels/program ===

$16693098943939
Le composant d'entrée [INSTRUCTION] a été supprimé. Il a été remplacé par un composant programme. A chaque cycle, utilise le compteur pour charger l'[INSTRUCTION] suivante de la mémoire du programme.
  
Tu dois utiliser le composant compteur que tu as déverrouillé dans un niveau précédent.
$19686277478479 Le programme envoie toujours la première instruction. As tu connecté un compteur ?


=== levels/wide_instrucitons ===

$13709034294291 Mémorise lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17693995237077 Envoie en sortie les deux octets
$19068760748550 Envoie 0 en sortie à chaque cycle pair
$65009239162932 Les sorties correctes étaient {a} et {b}
$19203973423116 Réalise un circuit qui enregistre la sortie du programme lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17409169138995 Mémorise l'octet


=== components/Input 3 ===

$70689623552857 Entrée


=== levels/Arithmetic Engine ===

$16434409050195
Ajoute l'addition et la soustraction à ton circuit.

Instructions
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144
Dans ce niveau, les entrées représentent les lettres dans une liste de noms de planète, encodés en ASCII (voir le manuel). Chaque nom est séparé par un espace qui a la valeur numérique 32. Remplace la première lettre de chaque mot avec la majuscule correspondante.
(Les caractères possibles en entrée sont les minuscules de a à z, l'espace, l'apostrophe et le tiret).
$13301617098810 A notre demande le stagiaire a saisi une liste de planètes en langue humaine. Malheureusement il a oublié de mettre les majuscules aux noms.
$11647445869837 Entrée : 
$11201813578269 Sortie : 


=== levels/Calculations ===

$14458828731919
C'est maintenant qu'il faut intégrer le circuit "Unité Arithmétique" réalisé précédemment avec le circuit registre. Le circuit de calcul a été enregistré dans l'atelier de composants et est maintenant utilisable en tant que composant. Si tu as oublié à quoi correspondent les pattes retourne regarder le circuit dans l'atelier de composants.

Utilise le décodeur déjà construit pour déterminer si l'on doit copier de registres à registres ou faire un calcul. Voici pour rappel les 4 modes possibles:
[OFF][OFF] Constante
[ON][OFF] Copie
[OFF][ON] Calcul
[ON][ON] Condition

Pour ce niveau tu n'as pas à t'occuper que des modes copie et calcul, lis les [INSTRUCTIONS] détaillées dans le panneau du haut. En mode calcul, prends [color=#e49f44]REG 1[/color] et [color=#e49f44]REG 2[/color] comme entrées et envoie le résultat dans [color=#e49f44]REG 3[/color].

[tip]Pense à la patte de désactivation du décodeur 3 bits.[/tip]
$13013863429580 Pour ce niveau une patte supplémentaire a été ajoutée aux registres. Cette patte émet toujours en sortie la valeur du registre même lorsque la lecture n'est pas activée.


=== levels/byte_equal ===

$17156565273196 La sortie doit être [ON] quand les deux entrées sont identiques.


=== levels/Counter ===

$17701404772563 Ajouter 1
$17940006660359 Compter
$68874699768861 Enregistrer {value}
$17263901743088
Construis un compteur qui s'incrémente de 1 à chaque cycle.

De plus il doit y avoir la possibilité de forcer le compteur à une valeur fournie.

Tu reçois 2 entrées, un bit et un octet.

Le bit en entrée permet de basculer entre les modes comptage et enregistrement de la valeur de l'octet.
$17883663978196 Enregister
$10555159894041
Compter est tellement fondamental que même les insectes le font. A partir de là, les espèces peuvent évoluer vers la comparaison et le calcul. Et alors que vous ne vous y attendiez pas, voilà que des singes construisent des ordinateurs...

Réalise un composant qui compte en s'incrémentant une fois par cycle.


=== components/InputQword ===

$31709565019284 Entrée


=== ui/options/General ===

$36195388998735 Général


=== levels/not_gate ===

$19085882338208 [b]Consigne[/b]\nFaites un clique droit pour désélectionner
$14042842216181 Dans le dernier niveau, vous avez construit le tableau à partir du circuit. Dans ce niveau vous devrez créer un circuit qui correspondra au tableau.
$10042327259531 Maintenant que vous avez déverrouillé la porte NAND, il est temps de créer votre propre circuit.
$10604720087324 [b]Consigne[/b]\nConstruisez un circuit qui corresponde au tableau.\nCliquez [i]?[/i] (Prochain Cycle) en haut à gauche pour tester chaque combinaison d'entrées.\nVous réussirez le niveau une fois que les deux combinaisons seront justes.
$19798729463813
En utilisant des portes NAND, construisez une porte NOT.

En utilisant: [b]porte NAND[/b]
[code]Entrée 1: [OFF][ON][OFF][ON]
Entrée 2: [OFF][OFF][ON][ON]
Sortie:  [ON][ON][ON][OFF][/code]

Construisez: [b]porte NOT[/b]
[code]Entrée 1: [ON][OFF]
Sortie:  [OFF][ON][/code]
$18442122157391 [b]Consigne[/b]\nDésélectionnez le composant en cliquant sur l'arrière-plan
$12880883686501 [b]Consigne[/b]\nCliquez sur la porte NAND en haut à droite et placez là
$18780831606716 [b]Consigne[/b]\nMaintenez le clique gauche pour ajouter un fil


=== levels/byte_shift ===

$16023356915123 Ta tâche dans ce niveau est de décaler vers la gauche la première entrée en fonction de la valeur de la seconde entrée. Cette seconde entrée aura au maximum un valeur de 7.
$37338672894296 Décale les bits de {value} de {amount} positions vers la gauche.
$10598344098990 [center]Décale la première entrée vers la gauche du nombre de position indiquée par la seconde entrée[/center]
$16216408139965
[color=#e49f44]Décaler[/color] une valeur à gauche de 1 signifie déplacer tous les bits de l'octets de 1 position vers la gauche.
Par exemple : [color=#e49f44]90 decg 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Décalage de 3 : [color=#e49f44]90 decg 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]
$18137790657923 En plus de te faire faire le composant décaler à gauche, nous avons aussi demander au stagiaire de faire le composant décaler à droite. Il lui a suffi de réaliser une version miroir de ce schéma.
$18518173140953 Je te recommande d'ajouter [color=#e49f44]décaler gauche[/color] et [color=#e49f44]décaler droite[/color] à tes circuits pour les prochains niveaux.


=== misc/factory ===

$53123649343022 L'atelier de composants


=== levels/registers ===

$10661964231175 J'ai forcé la position des composants rouges pour ce niveau, car tu t'embrouilles toujours en ne laissant pas assez de place. A partir d'ici tu ne repartiras plus de rien à chaque niveau, le désordre sera désormais sauvegardé d'un niveau à l'autre.
$10211777161405
Voici les combinaisons de bits pour chaque [color=#c54d5e]source[/color] et [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  ENTREE 
[ON] [ON] [ON]  NON UTILISE

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  SORTIE
[ON] [ON] [ON]  NON UTILISE

Pour obtenir des explications plus intuitives des exigences clique sur l'icône [INSTRUCTION] dans le coin supérieur gauche.
$15888345020710
Dans ce niveau tu dois créer un circuit pour copier d'une [color=#c54d5e]source[/color] vers une [color=#e49f44]destination[/color]. 

L'octet instruction indique ici la [color=#c54d5e]source[/color] et la [color=#e49f44]destination[/color]. 

Les bits 1, 2 et 3 indiquent la [color=#e49f44]destination[/color]. Les bits 4, 5 et 6 indiquent la [color=#c54d5e]source[/color].
$14823499195861 Ouvrir les "Instructions" dans la barre en haut
$14108238519744 Il est temps de créer ton chef d'oeuvre, en implémentant l'architecture informatique [color=#e49f44]OVERTURE[/color]. Ce sera un véritable système Turing Complet, un vrai ordinateur dans tous les sens du terme !
$14411286553593 Enfin les composants d'entrée et sortie ont maintenant une nouvelle patte. Met cette patte à [ON] pour lire depuis l'entrée ou copier vers la sortie.
$14041158687959
Les [color=#c54d5e]Sources[/color] et les [color=#e49f44]destinations[/color] peuvent être un des 6 registres, nous les appellerons REG 0 jusqu'à REG 5. 
  
De plus cette carte a un composant d'entrée spécifique qui peut être la [color=#c54d5e]source[/color] et un composant de sortie qui peut être la [color=#e49f44]destination[/color].


=== levels/xnor ===

$11090938799865 Créez la porte XOR inverse, connue sous le nom de XNOR.


=== levels/decoder ===

$16133643476631 Le circuit que vous avez créé dans le niveau "Registres" peut copier des valeurs entre différents registres, tandis que "l'Unité arithmétique et logique" a la capacité de faire différentes opérations avec ses deux entrées.
$18435544383511 CALCULER\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383 COPIER
$18945946395447
Pour distinguer les 4 [INSTRUCTIONS], nous utiliserons les deux bits de plus haut poids qui définiront le MODE dans lequel nous serons.
Cette liste montre les 4 modes à implémenter:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Valeur immédiate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculer
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copier
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition logique

Ici [ANY] veut dire que l'ont peut avoir n'importe quelle valeur.

Déterminez le mode dans lequel nous sommes à partir de l'entrée et envoyez [ON] vers la sortie qui correspond.
$15440615199508 Condition logique
$12671132029272 Votre circuit à été sauvegardé dans l'atelier de composants.
$15105859227432 COPIER \n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$16785126425267 Calculer
$12068329066372 [b]ATTENTION: CETTE VERSION DU CIRCUIT EST OBSOLETE, VEUILLEZ CLIQUER SUR L'ICONE DE SAUVEGARDE ET CREEZ UNE NOUVELLE VERSION DE CE CIRCUIT[/b]
$11382827588408 Condition logique\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611 Valeur immédiate\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542 Valeur immédiate


=== levels/bit_inverter ===

$15769391111364 Quand "Inverser" est [ON], veuillez sortir l'inverse de la valeur d'entrée. Sinon, copiez l'entrée sur la sortie.
$15272914096446 Ce niveau est exactement comme le XOR que vous avez résolu avant. N'oubliez pas : la seule vérité se trouve dans la table de vérité.
$14944872827527 Malgré le drôle de contexte que nous vous avons donné, vous avez réussi à voir qu'il ne s'agissait en réalité que d'une porte XOR déguisée. Bien joué !
$16125025706490 Hmm, peut-être que vous avez étudié un peu trop les mémoires...
$13224963076378 Nous étudions comment les expériences passées influent les fonctions cognitives des humains.


=== levels/ram_block ===

$17142958857584 A OU B
$12901484249817 Pourrez-vous mettre 4 octets de mémoire dans un espace aussi limité?
$15908016538045 VALEUR
$14218335256117
Dans notre civilisation avancée, forcer les prisonniers à faire des tâches complexes est de l'esclavage et est techniquement illégal.
    C'est pour cela que nous avons dit au stagiaire de faire une version 256 octets de votre composant. 
$13765566466116 NE PAS SAUVEGARDER
$12306130287676
Dans ce niveau vous devrez construire un circuit qui pourra
[SAUVEGARDER] ou [CHARGER] 4 octets de mémoire différents. 

1 Bit sera donné pour [CHARGER] et un autre pour [SAUVEGARDER].
Enfin, 2 bits seront données pour l'adresse.

Avec 2 bits, vous aurez 4 combinaisons possibles, une pour chaque octet de mémoire dans ce niveau.
[i][tip]Rassemblez les fils au centre et utilisez des angles droits, sinon ce sera le bazar ![/tip][/i]
[i][tip]La barre d'espace fait tourner les composants.[/tip][/i]
$18084166025569 Rien
$13082830776248 NE PAS SAUVEGARDER
$17473197268827 CHARGER
$13555908976270 0 OU 1
$10311371309532 SAUVEGARDER
$16925432534232 CHARGER
$13644027370563 Charger
$12291627335021 SAUVEGARDER


=== misc/score_sync ===

$76911045833478 synchroniser le score


=== ui/top_bar/gate_score ===

$16224450605442 NAND SCORE:


=== misc/level_gate_unlocks_unknown ===

$76731326010721 Déverrouille quelque chose d'inconnu


=== misc/level_gate_manual_icon ===

$22002156022920 Déverrouille la page de manuel


=== levels/Further Delayed Lines ===

$17366913897135 Construis un circuit dont la sortie est identique à l'entrée avec un retard de 2 cycles.
$60989431641221
Ce niveau présente le composant Ligne à Retard. Sa sortie est identique à l'entrée avec 1 cycle de décalage.

[img]dialogue/delay_buffer.png[/img]




=== levels/negative_numbers ===

$12574817679356
Nous avons besoin de valeurs négatives dans les octets. Le système que nous avons utilisé jusqu'ici représente tous les nombres de 0 à 255 avec un octet. Ce système est appelé "non signé", car il ne gère que les nombres positifs.

Nous avons besoin d'un système pour gérer les nombres négatifs, habituellement nommé représentation "signée".

De plus, cela simplifierait grandement les prochains circuit si la représentation fonctionnait avec l'additionneur que tu as déjà réalisé.
$17231048881956 Pour mesurer la différence entre deux valeurs, tu as besoin de la soustraction. Pour soustraire, tu as d'abord besoin des nombres négatifs.
$70755151984986 {a} devrait être {b}
$11067230116844 {number} n'a pas de représentation
$62744038163781 OK
$19118970740682
[color=#dd6576]Modifie les valeurs[/color] pour chaque bit de façon à respecter les objectifs suivants :

[color=#e49f44]1[/color]: Tous les nombres de -127 à 127 doivent pouvoir être représentés
[color=#e49f44]2[/color]: Les Octets représentant les valeurs de 0 to 127 doivent être les mêmes qu'en non signé.
[color=#e49f44]3[/color]: Le nouveau système doit fonctionner avec l'additionneur (pour les résultats entre -127 et 127).
$15431436023571 Tu as deux façons de représenter 0\nCe qui conduit à 0 + 1 = 0
$28284583096369 1 plus -1 n'est pas égal à 0\n  
$57604042654667 {number} n'a pas de représentation


=== levels/Masking Time ===

$16810715868480 [center]Calculez le modulo 4 de l'entrée.[/center]
$17375862136921
La durée de notre semaine est de 4 jours. On appelle les jours Jour Zéro, Jour Un, Jour Deux et Jour Trois. J'ai entendu que les humains ne savaient pas compter les jours corrêctement?

Ça me surprends pas vraiment.
$19351773688761 Cycles restants : {ticks_left}  Entrée : {input}
$65431688078892
Dans ce niveau on te donne un nombre n en entrée et tu dois retourner comme résultat ce nombre modulo 4.

La difficulté est que tu as seulement {ticks_per_test} cycles pour sortir le résultat attendu.

Attention, tu n'as pas besoin de modifier le circuit, tu dois trouver l'astuce pour calculer rapidement le modulo 4.
Regardes [color=#e63e5b][url=masking_time]l'indice[/url][/color] si tu es coincé.
$81055582534899 Enfin le nouvel an arrive et nous te demandons de calculer le jour de la semaine de naissance de tout le monde. Nous te donnerons la date et tout ce que tu as à faire c'est de retourner le jour de la semaine en {ticks_per_test} cycles max.



=== levels/NAND Gate ===

$17420270098223 Dans ce niveau, le but sera de comprendre comment fonctionne une porte NAND. Soyez [color=#dd6576]sur[/color] de savoir comment elle fonctionne avant de compléter le niveau, sinon vous pourriez être bloqué dans le prochain!
$11034378482152 Correct! Vous avez débloqué la porte NAND. Avec ce composant vous pourrez construire tout le reste de votre ordinateur!
$18270083417453 Vérifier
$19208664264770 [b]Consigne[/b]\nCliquez sur l'un des boutons de la dernière ligne du tableau.
$17923274216766 Nous en avons conclus que vous n'êtes probablement pas une plante.
$14777350869870 Nous sommes impressionnés par votre capacité à avoir résolu le dernier test!
$17994568832660 [b]Consigne[/b]\nLa porte NAND au milieu du circuit change son comportement.\nUtilisez la barre sur votre gauche pour experimenter les effets qu'ont les entrées sur les sorties et complétez le tableau en conséquence.


=== levels/byte_adder ===

$16888130664370
Si le résultat prends plus que 8 bits de place, mettez la sortie carry [ON] (vous pouvez l'utiliser comme un 9ème bit)
  
Il y a aussi une entrée carry, elle sera utile pour additionner des octets à la suite. On additionne le carry en entrée au résultat (0 [OFF] ou 1 [ON]).

Utilisez [color=#e63e5b][url=byte\_adder]cet indice[/url][/color] si vous êtes coincé.


=== misc/ide_control_link ===

$80788685813993 Contrôles du Robot


=== levels/saving_gracefully ===

$12474728041023
La Ligne à Retard nous permet d'utiliser une valeur un cycle plus tard.

Nous devons réaliser un composant qui nous permet d'utiliser une valeur dans le futur, quelque soit le nombre de cycles plus tard.
Nous appelerons cette valeur [color=#e49f44]sauvegarde[/color].
$13740696609075
Ce niveau comporte deux entrées.
La valeur sauvegardée est modifiée seulement quand la première entrée est à [ON].
La seconde entrée est la nouvelle valeur de la [color=#e49f44]sauvegarde[/color].

Envois toujours en sortie la [color=#e49f44]sauvegarde[/color].


=== levels/circular_dependency ===

$13880985462901 Réalise un circuit pour lequel l'entrée du composant dépend de sa propre sortie.
$18010308863615
Crée une "dépendance circulaire". C'est un circuit pour lequel l'entrée du composant dépend de sa propre sortie. En cas de dépendance circulaire, il n'est pas possible de déterminer la sortie du composant, cela nécessiterait de connaître son entrée, qui dépend de sa sortie, et ainsi de suite, d'ou le "circulaire".

Ce cas n'est normalement pas accepté dans les autres niveaux, mais ici l'objectif est d'en créer un, afin de comprendre ce dont il s'agit avant de passer à la suite.


=== ui/top_bar/scores ===

$56840961921536 SCORE NAND : \n SCORE DELAI :


=== levels/Water World ===

$12881972193444
Le terrain mesure 16 colonnes de large. Lis l'entrée 16 fois pour trouver la hauteur disponible pour chaque colonne de gauche à droite.
  
Envois alors en sortie comme réponse le volume total que le terrain peut contenir.


=== misc/profile ===

$32835651830157 Profil


=== levels/Dancing Machine ===

$14975070588197
Nous aimons tous la façon dont le Robot bouge sur la piste de dance. C'est pourquoi nous le voulons à la tête de notre équipe de danceurs.
  
Le seul problème c'est de lui faire trouver des séries de mouvements originaux. Comment pourrait-on bien obtenir de la créativité à partir d'une logique déterministe ?

La solution a pour nom générateurs de nombres pseudo-aléatoires.

=== misc/program_edit_signals ===

$98772447663910 Éditer les points d'observation


=== misc/credits ===

$15234594767991 Crédits


=== misc/delete ===

$53448014080434 Supprimer (Raccourci : Clic droit)


=== misc/controls2 ===

$38773676077206 Éditer les instructions


=== misc/factory_back ===

$98930461722118 Revenir au niveau


=== misc/component_factory_toggle ===

$55499239951858 L'atelier de composants


=== misc/reset ===

$39440928972984 Reset (Raccourci : F4)


=== levels/conditions ===

$12706881725738 Votre circuit a été enregistré dans l'atelier de composants.


=== misc/factory_back_inner ===

$12211557416281 Revenir au niveau


=== levels/sandbox ===

$19454393978813 Le Clavier te permet de contrôler ton ordinateur directement avec simplement... ton  clavier.


=== levels/and_gate ===

$15232844525838
Réalise le circuit qui correspond au tableau.
  
[tip]Double-clique sur un composant pour le déplacer avec son groupe de fils connectés directement.[/tip]


=== misc/instr_clone ===

$69090690657232 Cloner


=== misc/program_edit_button ===

$38481453712356 Éditer la mémoire


=== levels/Crude Awakening ===

$12508086025944
Nous allons vous tester.

Les règles sont simples, construisez un ordinateur fonctionnel ou vous allez être mangé. Bonne chance !
$16321577947087 Félicitation, vous vous êtes fait enlever!
$19257730429557
Un signal se déplace toujours de composants "IN" vers des composants "OUT".
Dans le coin en haut à gauche en dessous de "IN" vous trouverez une icône verte, 
cliquez dessus pour changer son état.
$17675121574388 Le composant OUT s'est maintenant éteint, car aucun signal ne viens de l'entrée.\n


=== misc/wire_draw ===

$59836059268386 Nouveau fil (Raccourci : Alt & glisser)


=== ui/toggles/race_condition ===

$75558678297830 Dépendance circulaire


=== ui/toggles/level_log ===

$38557550573896 Présentation du niveau


=== levels/Conditionals ===

$10794262854382
Ajoute des instructions si à ton circuit. Avec l'instruction si, les 2 arguments sont comparés et si la condition est vraie, le compteur est chargé avec une adresse de saut.

L'instruction précédente contient 4 octets qui représentent :  
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, RÉSULTAT[/color][/code]

Pour l'instruction si les octets représentent :
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, ADDRESSE\_SAUT[/color][/code]

En plus des copeops précédents, ajoute :
[code][color=#87a8c8]32 SI\_EGAL
33 SI\_NON\_EGAL
34 SI\_MOINS
35 SI\_MOINS\_OU\_EGAL
36 SI\_PLUS
37 SI\_PLUS\_OU\_EGAL[/color][/code]

Compare avec les composants pour nombres non signés.

Chaque opcode fait ce que son nom indique. Par exempie pour sauter à l'octet 16 si REG0 est inférieur à REG1 : 
[code][color=#87a8c8]SI\_MOINS REG0 REG1 16[/color][/code]
$14973719570693 Ajoute un compteur au circuit
$14690660047411 [center]Implémente les opcodes conditionnels[/center]


=== misc/change_schematic ===

$79554853897000 Changer de schéma


=== levels/byte_less ===

$11252365204151 Réalise un circuit dont la sortie est [ON] quand la première entrée est inférieure à la seconde. Les octets sont [color=#dd6576]NON SIGNES[/color].


=== levels/sr_latch ===

$18165461234561 Les lignes de retard sont simples à comprendre et peuvent être utilisées pour construire n'importe quelle architecture d'ordinateur. Pourtant le matériel moderne ne les utilise plus comme base des mémoires.
$15754153332116
Ce niveau présente le concept de bascule. Ce dispositif n'est pas utilisé ailleurs dans le jeu. Néanmoins ce niveau existe pour une raison d'exhaustivité.
  
If vous n'avez aucune expérience en électronique, il est recommandé de sauter ce niveau. Vous pourrez toujours revenir plus tard.
$15213907597666 Avec 2 portes NOR, construisez le circuit qui correspond à la table. Vous aurez besoin d'une bascule.
$19448398663695
Pour déterminer quels composants contrôlent la sortie dans une dépendance circulaire, il est impossible de fixer un composant de départ. A la place nous utilisons les valeurs des fils du cycle précédent. Cela s'explique par le fait que les électrons ne se déplacent pas instantanément dans la réalité. En fonction du cable, le circuit oscille entre [ON] et [OFF], ou se fixe dans un état stable.
  
Quand un circuit peut se fixer dans 2 états stables distincts, vous avez une base pour une mémoire. L'état suivant dépendra des valeurs sur les fils du cycle précédent. De tels circuits sont appelés "bascules".


=== misc/multi_select ===

$85147529532131 Sélection multiple (Raccourci : SHIFT & glisser)


=== misc/inst_new_rule ===

$41064305626707 Nouvelle règle


=== levels/always_on ===

$17712385236630 Réalise un circuit qui est toujours [ON].


=== levels/byte_xor ===

$19636386696963 Réalise un circuit qui applique XOR bit à bit sur deux octets.


=== levels/binary_racer ===

$19111664765554
Modifie les bits dans le panneau afin qu'ils représentent le nombre décimal demandé.

Tu dois atteindre le niveau 3 pour réussir.

(cliques [color=#e63e5b][url=accessibility\_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours.)


=== misc/menu ===

$56916384895438 Menu Général


=== levels/xor_gate ===

$19182751521677 Dans le dernier niveau tu as réalisé un circuit qui était [ON] au second cycle. Ce niveau nécessite un circuit [ON] au second OU au troisième cycle.


=== levels/Immediate Values ===

$14960344494328
Parfois il est utile de charger une valeur directement depuis le programme que d'un registre. Cela s'appelle charger une valeur immédiate. Pour l'architecture [color=#e49f44]LEG[/color] l'opcode indique directement que nous voulons faire cela. C'est possible de la façon suivante :

Quand le 8ème bit de l'opcode est [ON], utilise l'argument 1 comme une valeur immédiate et non comme une adresse de registre.
Quand le 7ème bit de l'opcode est [ON], utilise l'argument 2 comme une valeur immédiate et non comme une adresse de registre.
  
    [img]dialogue/leg\_diagram.png[/img]
    
$18004215603701 Ajoute un compteur au circuit


=== levels/Wire Spaghetti ===

$17106892574116 Ajoute un compteur au circuit
$56024330661504 Le point d'Observation {watched\_state} doit pointer sur un registre ou un composant personnel contenant un registre.
$19099471819164
Voici les premières choses à faire pour résoudre ce niveau :
    
[b]1.[/b] Clique l'icône schéma ([b][i]?[/i][/b]) et crée une nouvelle architecture.
[b]2.[/b] Ajoute un bloc de programme avec 4 sorties.
[b]3.[/b] Ajoute un compteur, définis son incrément à 4 et connecte-le au bloc de programme.
[b]4.[/b] Ajoute 6 registres (ou 6 composants personnels contenant un registre)
[b]5.[/b] Clique "Editer point d'observation" sur le composant programme et connectr les registres aux points 0 à 5. Connecte le compteur au 6 et la sortie au 7.
$18860645759682
L'architecture [color=#e49f44]LEG[/color] est un ordinateur qui lit 4 octets de programme par cycle. 

Le premier octet correspond à l'opération (called the [color=#e49f44]OPCODE[/color]).

Comme beaucoup d'opérations prennent 2 arguments (ADD, OR etc.), les second et troisième octets servent pour les arguments.

Et comme la plupart des opérations retourne 1 résultat, le quatrième octet est pour le résultat.
  
  [img]dialogue/leg\_diagram\_1.png[/img]
$62258842382434 Le point d'Observation {value} doit pointer sur le compteur.


=== levels/and_gate_3 ===

$14788981567936 Créez une porte NAND avec 3 entrées.


=== components/OutputQword ===

$43552728118031 Sortie

=== added from 202205213 ===

=== levels/push_pop2 ===

$10062117579269 Ajoute la pile à ton ordinateur
$14685569269160
Dans ce niveau on attend que tu ajoutes la pile à l'ordinateur et que tu écrives un programme pour le résoudre.
Quand l'entrée est 0, tu dois [color=#e49f44]DEPILER[/color] une valeur de la pile et l'envoyer en sortie. Quand l'entrée n'est pas 0, tu dois l'[color=#e49f44]EMPILER[/color] sur la pile.
$18561605111721 EMPILER {input} sur la pile
$59658696292688 DEPILER {value} de la pile

=== levels/Immediate Values ===

$64348543296709 Le point d'Observation {value} doit pointer sur la sortie
$14060810229477 Ajoute 6 registres dans le circuit
$79667526283284 Le point d'Observation {value} doit pointer sur le compteur
$14960344494328
Parfois il est utile de charger une valeur directement depuis le programme que d'un registre. Cela s'appelle charger une valeur immédiate. Pour l'architecture [color=#e49f44]LEG[/color] l'opcode indique directement que nous voulons faire cela. C'est possible de la façon suivante :

Quand le 8ème bit de l'opcode est [ON], utilise l'argument 1 comme une valeur immédiate et non comme une adresse de registre.
Quand le 7ème bit de l'opcode est [ON], utilise l'argument 2 comme une valeur immédiate et non comme une adresse de registre.
	
		[img]dialogue/leg_diagram.png[/img]

$10788301006338 Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19338533633006 Définis l'incrément du compteur à 4
$15197362332657 Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$10141611261952 [center]Implémente les valeurs immédiates[/center]

=== levels/The Product of Nibbles ===

$14957949958941 Ce que tu as fait ici c'est en fait une multiplication de deux nombres de 4 bits. Le stagiaire s'est chargé de l'étendre aux octets.
$19136817138607 [center]Multiplie les nombres de 4 bits[/center]
$14533861483435 La multiplication de deux nombres de 4 bits donne un nombre de 8 bits. Réalise le schéma adapté.
$83694551809785 Multiplier {num1} et {num2}
$14622683750375 Bit 2
$17331397914567 Bit 1
$13232094477834 Bit 3
$13549246864135 Bit 0
$15857218442751 Bit 1
$10430040077737 Bit 3
$10274387271390 Bit 0
$16301538038805 Bit 2

=== levels/sandbox ===

$17054292175058 Bienvenue dans le bac à sable, ici tu es libre de t'amuser librement. Je t'ai donné des fils de 64 bits et quelques composants supplémentaires d'Entrées/Sorties (IO).
$10731996208080 Il y a également des versions 64 bit du programme, du compteur, du registre et de la RAM. Rappelles toi que les lectures en RAM 64 bits prennent 1 cycle.
$72764802067974
Bienvenue dans le bac à sable. 

Les composants sont disponibles dans les menus du coté droit. Une fois placé, clique sur les pattes du composant et glisse pour les connecter au circuit. A gauche tu trouveras l'interface pour le contrôle de la simulation. Note que tu peux utiliser le clic droit sur le bouton "Vitesse d'Exécution" pour sélectionner la vitesse de ton choix.

Tu peux trouver plus d'information sur la simulation dans le manuel (bouton en haut à gauche). Les fonctions importantes à voir sont l'"atelier de composants" qui te permet de créer tes propres composants and le composant programme, qui te permet de définir ton propre langage assembleur.
$19454393978813 Le mini clavier te permet de contrôler ton ordinateur directement avec ton  clavier.
$14434122873489 Le générateur de forme d'onde (Waveform) te permet de générer des sons. Je vais probablement regretter de t'avoir donné celui-là.
$18405942066048 L'horloge donne l'heure UNIX courante en microsecondes.
$10451578314373 L'Ecran Console te permet de dessiner des caractères sur un écran (voir caractères ASCII dans le manuel)

=== components/Input32 ===

$10677927084411 Entrée

=== levels/counting_signals ===

$10724914203078
Le composant sortie de ce niveau est un compteur binaire dont les 3 premières pattes correspondent à 1, 2 et 4.
Utilise le compteur binaire pour compter le nombre de signaux.

Regarde [color=#e63e5b][url=counting_signals]cet indice[/url][/color] si tu te retrouves coincé

[i][tip]La solution de ce niveau n'est pas très propre et nécessite pas mal de composants.[/tip][/i]

$10881918807029
 [color=#b72d41][b]ASTUCE:[/b][/color] 
 Il n'y a pas de honte à utiliser
 une feuille et un stylo

=== levels/Wire Spaghetti ===

$29329105515650 Ajoute un registre de plus au circuit
$17106892574116 Ajoute un compteur au circuit
$50177586789991 Ajoute {nr} registres de plus au circuit
$15754373587500 Définis l'incrément du compteur à 4
$56024330661504 Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19099471819164
Voici les premières choses à faire pour résoudre ce niveau :
    
[b]1.[/b] Clique l'icône schéma ([b][i]?[/i][/b]) et crée une nouvelle architecture.
[b]2.[/b] Ajoute un bloc de programme avec 4 sorties.
[b]3.[/b] Ajoute un compteur, définis son incrément à 4 et connecte-le au bloc de programme.
[b]4.[/b] Ajoute 6 registres (ou 6 composants personnels contenant un registre)
[b]5.[/b] Clique "Editer point d'observation" sur le composant programme et connecter les registres aux points 0 à 5. Connecte le compteur au 6 et la sortie au 7.


$18860645759682
L'architecture [color=#e49f44]LEG[/color] est un ordinateur qui lit 4 octets de programme par cycle. 

Le premier octet correspond à l'opération (l'[color=#e49f44]OPCODE[/color]).

Comme beaucoup d'opérations prennent 2 arguments (ADD, OR etc.), les second et troisième octets servent pour les arguments.

Et comme la plupart des opérations retourne 1 résultat, le quatrième octet est pour le résultat.
  
  [img]dialogue/leg\_diagram\_1.png[/img]
$11377431500625 Ajoute 6 registres au circuit
$14051336765362 Enfin c'est maintenant que tu commences à construire l'architecture [color=#e49f44]LEG[/color] !
$13268807052125 (Tu pourras additionner 7+7, mais ici 7 signifie lire depuis l'entrée et l'entrée a pour valeur 8)
$30006055126224 Le point d'Observation {output} doit pointer sur la sortie
$19066122929275 [center]Met en place les registres et implémente l'opcode ADD [/center]
$10912834168905
Enfin, pour ce niveau l'[color=#e49f44]OPCODE[/color] est toujours 0. Cela veut dire qu'il faut additionner les arguments 1 2 et envoyer le résultat sur la destination.

Les valeurs utilisées pour les arguments ou la destination sont les suivantes :
[code]
[color=#e49f44]0[/color]: Registre 0
[color=#e49f44]1[/color]: Registre 1
[color=#e49f44]2[/color]: Registre 2
[color=#e49f44]3[/color]: Registre 3
[color=#e49f44]4[/color]: Registre 4
[color=#e49f44]5[/color]: Registre 5
[color=#e49f44]6[/color]: Compteur
[color=#e49f44]7[/color]: Entrée/Sortie
[/code]

Dans le niveau suivant tu implémentaras d'autres [color=#e49f44]OPCODES[/color], ce qui nécessitera une ALU différente de celle d'[color=#e49f44]OVERTURE[/color].

$10922418807673 L'argument 7 nécessite de lire sur l'entrée, mais l'entrée n'est pas active.
$62258842382434 Le point d'Observation {counter} doit pointer sur le compteur
$18769284297247 Créé un nouveau schéma et ajoute un programme avec une sortie sur 4 octets.



=== levels/Wire Spaghetti ===

$17106892574116 Ajoute un compteur au circuit
$56024330661504 Le point d'Observation {watched\_state} doit pointer sur un registre ou un composant personnel contenant un registre.
$19099471819164
Voici les premières choses à faire pour résoudre ce niveau :
    
[b]1.[/b] Clique l'icône schéma ([b][i]?[/i][/b]) et crée une nouvelle architecture.
[b]2.[/b] Ajoute un bloc de programme avec 4 sorties.
[b]3.[/b] Ajoute un compteur, définis son incrément à 4 et connecte-le au bloc de programme.
[b]4.[/b] Ajoute 6 registres (ou 6 composants personnels contenant un registre)
[b]5.[/b] Clique "Editer point d'observation" sur le composant programme et connectr les registres aux points 0 à 5. Connecte le compteur au 6 et la sortie au 7.
$18860645759682
L'architecture [color=#e49f44]LEG[/color] est un ordinateur qui lit 4 octets de programme par cycle. 

Le premier octet correspond à l'opération (called the [color=#e49f44]OPCODE[/color]).

Comme beaucoup d'opérations prennent 2 arguments (ADD, OR etc.), les second et troisième octets servent pour les arguments.

Et comme la plupart des opérations retourne 1 résultat, le quatrième octet est pour le résultat.
  
  [img]dialogue/leg\_diagram\_1.png[/img]
$62258842382434 Le point d'Observation {value} doit pointer sur le compteur.

=== levels/ram_block ===

$19282543476901 1
$32676754026463 Sauvegarde {value} et charge
$16196915566111 0
$30856781458049 Sauvegarde {value}
$14259545926196 A
$16217965518477 B
$10891070331034 B
$12933801309767 A


=== levels/saving_bytes ===

$13502950630653
[color=#ff9800]Aucune
0
0[/color]

=== main_scripts/overture_level ===

$27259865408750 Au prochain cycle la valeur du compteur sera {next}, on attend {expected}
$95030012922256 L'Entrée doit être activée seulement si nécessaire
$12873109232054 On attendait {expected} en sortie, pas {got}
$47188699762650 La Sortie devrait être activée et ce n'est pas le cas
$28026304798371 La Sortie ne devrait être activée que quand c'est nécessaire
$85260864781281 L'Entrée devrait être activée et ce n'est pas le cas
$96569633331621 Charge {value} dans le REG 0
$83829200305236 On attendait {expected} en sortie, pas {got}

=== components/Input 2 ===

$86870364449392 Entrée

=== components/Input 4 ===

$11447837612693 Entrée

=== components/Input1_1B ===

$10517158300617 Entrée

=== components/Input16 ===

$34560561101846 Entrée

=== components/InputConditions ===

$75386511637758 Entrée

=== components/Output32 ===

$37476623180671 Sortie

=== components/Output16z ===

$25071861608139 Sortie

=== components/Output1z ===

$46173002346157 Sortie

=== components/Output8z ===

$86533851094807 Sortie

=== components/Output64z ===

$23672623772864 Sortie

=== components/Output16 ===

$37381472194529 Sortie

=== components/Output32z ===

$90826155624234 Sortie

=== components/Output 3 ===

$96269858195218 Sortie

=== components/Output 1B ===

$77044600156969 Sortie

=== components/Output8zLevel ===

$49513138880387 Sortie

=== components/Output 2 ===

$73255344581755 Sortie

=== levels/hex_racer ===

$92057009138253 Comment écrire {number} en binaire ?
$16009852370452
Quand on manipule beaucoup de bits, le binaire commence à être difficile à lire. L'Hexadécimal (base 16) représente chaque combinaison de 4 bits par son propre caractère :
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

Voici un exemple de la meilleure lisibilité de l'hexadécimal, comparons les représentations du plus grand nombre de 16 bits :
[code]
Binaire :     1111111111111111
Décimal :     65535
Hexadécimal : FFFF
[/code]

Ce n'est pas facile de dire s'il manque un chiffre binaire ou s'il y a un décalage en décimal, mais l'hexadécimal est tout de suite clair (au moins une fois qu'on prend l'habitude).
$84691609525475 Ce niveau est mon deuxième passe-temps préféré. Convertir de l'hexadécimal au binaire en temps limité.
$45532697833519 Niveau {level} atteint !
$87016829502381 Très bien, tu as atteint le niveau {current_level}.
$43463538043782
Modifie les bits du panneau pour atteindre le nombre hexadécimal demandé.

Tu dois finir le niveau 3 pour réussir.

(clique [color=#e63e5b][url=accessibility_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours)

=== levels/byte_adder ===

$18732877690173 Additionez les deux octets en entrée. Chaque bit en sortie devra être le résultat de l'addition des bits d'entrées et potentiellement du carry. 

=== levels/robot_race ===

$15403032472607 La course de robots est notre sport favoris sur le vaisseau. Des robots programmés par différentes personnes vont essayez d'arriver à a fin de la course le plus rapidement possible. Le gagnant sera le programmeur dont le programme aura le moins de ligne.
$19966247197959 Cette fois-ci vous controlerez FastBot: il ne peut pas voir ce qu'il y a devant lui, mais il peut tourner et avancer durant le même coup d'horloge. (Il porte aussi des baskets rouge pour aller plus vite).
