=== components/LessI32 ===

$87609006355839* Less (signed)
$99994775592318* Checks if one input is less than the other


=== levels/ram_block ===

$16196915566111* 0
$14259545926196* A
$12933801309767* A


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== components/ON ===

$95896157427528* ON


=== levels/negative_numbers ===

$62744038163781* OK


=== main_scripts/leg_level ===

$11144256835662* XORi
$20104629254326* ARGUMENT 2
$89011349770597* NOT
$40520283279584* XOR
$71204580217527* NOTi
$38681417496680* ARGUMENT 1


=== components/Console ===

$66743357915699* Console


=== components/Off ===

$61860786587357* OFF


=== levels/circular_dependency ===

$16336401898647* Test 1/2


=== components/NOR ===

$83375115196253* NOR


=== components/Rom ===

$24976506406652* ROM


=== components/Ror8 ===

$10802217509530* Rotates the bits of an input right
$70999134800536* Rotate right


=== components/NAND ===

$71130919681688* NAND


=== trans/map_arithmetic ===

$51337598329530* ARITHMETIC


=== components/Rol32 ===

$88734684504266* Rotates the bits of an input left
$83642246004160* Rotate left


=== components/Bidirectional1 ===

$95836352586032* Can circumvent certain circular dependency errors
$34912798641933* 1 bit bidirectional pin


=== components/Mul32 ===

$98530670555665* Multiply
$51210946736766* Multiplies two inputs


=== components/Halt ===

$30351143139905* Halt

NOTE: This is the default message of the Halt component
$54106972240596* Halt
$62990744955549* Stops execution with a custom message


=== components/ByteAnd ===

$61791872137683* Bitwise AND two values
$21541105796357* 8 Bit AND


=== components/Bidirectional32 ===

$54631386552063* 32 bit bidirectional pin
$35105566244017* Can circumvent certain circular dependency errors


=== components/Output16z ===

$78873885833823* Switched Output
$54278394672948* Only outputs if the switch pin is [ON]


=== components/Counter ===

$51446864816252* Increments each tick, unless overwritten
$67910883947749* 8 Bit Counter


=== components/ByteMul ===

$56549841656852* Multiply
$68631919890554* Multiplies two inputs


=== misc/specifications ===

$68054407020318* Instructions


=== trans/map_assembly_challenges ===

$31733554125775* ASSEMBLY CHALLENGES


=== levels/The Product of Nibbles ===

$13549246864135* Bit 0
$10274387271390* Bit 0


=== components/Input1_1B ===

$57868504368581* Loads the input from levels


=== main_scripts/functions ===

$87591753278764* Reg {nr}


=== trans/architecture_2 ===

$38100016313511* CPU ARCHITECTURE 2


=== components/NetworkClient ===

$44510554000571* Network
$90462653419289* Handles network connections


=== trans/map_basic_logic ===

$75078723880086* BASIC LOGIC


=== components/Counter32 ===

$87245349851451* 32 Bit Counter
$92765669828982* Increments each tick, unless overwritten


=== ui/abbreviated_units ===


NOTE: Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M

NOTE: Instead of writing 5839, the number turns into 5.8K
$84696693690500* K


=== components/Maker16 ===

$55864807379312* Turns 16 bits into 2 bytes
$39941195789458* 16 bit Maker


=== components/ByteConstant ===

$29445030761909* Constant value
$25159790815891* 8 Bit Constant


=== components/NEG ===

$88379907297327* Negate
$62021716182809* Bitwise negates an input


=== components/Switch16 ===

$15221175893882* 16 Bit Switch
$59845475842015* Toggles a value


=== components/And3 ===

$19664974941910* 3 Pin AND
$86839706221116* 3 pin AND gate


=== nim/backend_lib/level_list ===

$15420972347773* RAM
$26705128002562* Conditions
$70993791338383* XOR


=== components/Counter16 ===

$37313834107391* Increments each tick, unless overwritten
$49104925799943* 16 Bit Counter


=== components/Add32 ===

$91616185859914* Adds two inputs
$64111401384153* Add


=== components/LessU32 ===

$72614358420262* Less (unsigned)
$55380524073095* Checks if one input is less than the other


=== components/Output8z ===

$16915419621070* Switched Output
$58449766432492* Only outputs if the switch pin is [ON]


=== components/NOT ===

$34453052824732* NOT
$90844421681709*
Inverts the input
[table=3]
[cell]Input[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== components/MemoryProbe ===

$46948613505134* Display a value on your custom component or in the program editor
$44867305035474* Memory Probe


=== components/Not32 ===

$33620523355085* 32 Bit NOT
$24607331341411* Bitwise negates 32 bits


=== components/Equal32 ===

$32710942647020* Equal
$32433537137277* Checks if the two inputs are equal


=== components/Add16 ===

$28092601427278* Adds two inputs
$30820974870562* Add


=== components/Byte Expander ===

$60488114435022* Splits a byte into 8 bits
$21904470559153* Byte Splitter


=== components/And16 ===

$56198785587874* Bitwise AND two values
$26727645933234* 16 bit AND


=== misc/StateProbe ===

$54427436420428* Wire Probe
$15969687819995* Display a value on your custom component or in the program editor


=== components/Splitter32 ===

$90978982016052* Splits 32 bits into 4 byts
$24096666569346* 32 bit Splitter


=== trans/map_working_computer ===

$38843517090942* WORKING COMPUTER


=== components/Or32 ===

$92752025948920* Bitwise OR two values
$40180779432911* 32 Bit OR


=== components/Shl32 ===

$38930281262898* Shift left
$88685329847417* Shifts the bits of an input left


=== components/Shl64 ===

$56766765894165* Shifts the bits of an input left
$37014604954362* Shift left


=== components/And64 ===

$80790829001391* 64 bit AND
$89424947351456* Bitwise AND two values


=== components/Program64 ===

$76480303942112* Programmable memory component


=== components/3_decoder ===

$59129788113517* Toggles between eight outputs
$94375716460090* 3 Bit decoder


=== components/Xnor8 ===

$31985293401482* 8 Bit XNOR
$45789912406647* Bitwise XNOR two values


=== components/ByteEqual ===

$35668435514829* Checks if the two inputs are equal
$39369982838671* Equal


=== components/Mul64 ===

$72281597169494* Multiply
$11665562499390* Multiplies two inputs


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== components/Splitter64 ===

$80420054807186* Splits 64 bits into 8 byts
$14205692632393* 64bit Splitter


=== components/switch ===

$87345192339084* Toggles a value
$29301846684808* 8 Bit Switch


=== components/Register64 ===

$86007777261800* 64 Bit Register
$99461037008796* 64 bit memory


=== components/Splitter16 ===

$92674917729864* 16 bit Splitter
$28271182652741* Splits 16 bits into 2 byts


=== components/FastRam ===

$79436020115192* Fast but high gate cost memory
$12924829814634* Fast RAM


=== components/SRLatch ===

$11641785582600* Set/Reset Latch
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== components/Maker32 ===

$82420653444614* Turns 32 bits into 4 bytes
$85308499118176* 32 bit Maker


=== components/Xnor ===

$94079327237795* XNOR


=== components/XOR ===

$54832952840086* XOR


=== main_scripts/dialouge ===


NOTE: Hitn for byte switch
$86319296925137* What would this look like if you were only switching 1 bit? What would the truth table for such a component look like?

NOTE: hint for the bus
$50799425816171* Use switches to put the inputs on the same wire.

NOTE: hint for odd number
$68750974209145* You can figure out if 2 inputs have an odd number of [ON] with just 1 component...

NOTE: Hint for the maze
$36837749971886*
Always following the left (or right) hand side of the maze will make sure you eventually reach the exit.
	
The pseudo code for such an algorithm looks like this:
 Step forward
 Turn left
 Turn right as long as there is a wall ahead
 Press use after each turn (in case the exit is ahead)
 Repeat

NOTE: hint for counting signals

NOTE: Hint for byte adder
$37093555217568* You only need 8 full adders.
$21044442262778* The circuitry for the 1's bit is the same as what you did in the level "Odd Number of Signals". The circuitry for the 2's bit is what you did in "Double Trouble", except when all 4 are on.

NOTE: hint for saving gracefully
$25321701584378*
In this level you need to use 1 Delay Line. Make a truth table for what should go into the Delay Line. Consider the input to the Delay Line as the output for your table. 

The inputs are the 2 level inputs AND the output of the Delay Line, as the output plays a role in its input. In total you have 3 "inputs" to for this table which gives you 8 combinations. Once you have the level requirements as a table, it should be a lot easier to solve.

NOTE: Hint for conditions
$87674181578455*
There are 3 condition bits. The first bit being [ON] means the result being 0 meets the condition. The second bit being [ON] means the result being less than 0 meets the condition. If either of those two are [ON], the condition is met. 
Finally, if the last bit is [ON], negate the status of the condition being met or not.

NOTE: hint for xor gate
$88963098241493* This level can be done with 3 components, a NAND, an AND and an OR gate.

NOTE: Hint for masking time
$46866534894828*
In binary, taking modulo 4 of a number is the same as only using the two lower bits. This is because the higher bits represet 4, 8, 16 etc, and they all divide 4 with no remainder.
This is true in general for modulo a power of 2, the lowest bit of a number represents that number modulo 2 (even or odd), the lowest 3 bits modulo 8 and so on.

Likewise, in decimal 4321 modulo 100 is also simple (answer is 21, the higher digits are disregarded), this is because 100 is a power of 10.

Now you just have to figure out how to get the last 2 digits of a number.

NOTE: hint for less
$56438995128380*
First determine which bits are different between the 2 bytes. This can be done using a byte XOR (remember XOR turns [ON] when the inputs are not the same). We know the number that has the highest different bit [ON] is the larger number. But we must only consider the highest different bit, so for each bit, use a chain of OR gates to check if any higher are [ON].
		
Finally, the last bit is considered seperately for signed numbers, here it has the opposite effect (if only one number has it [ON], that number is guaranteed to be lower)


=== components/Neg32 ===

$26991597084705* Negate
$35735598635057* Bitwise negates an input


=== components/Xor64 ===

$95012060885697* 64 bit XOR
$13031452187028* Bitwise XOR two values


=== components/Output64z ===

$61656790122480* Switched Output
$42506906257154* Only outputs if the switch pin is [ON]


=== components/OR ===

$13013154620359*
[ON] when either input is [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]


=== components/Ram ===

$95418291334002* 256 Byte Ram
$27094240214067* Memory component


=== components/Constant16 ===

$85825068431072* 16 Bit Constant
$61330657823382* Constant value


=== components/ByteXor ===

$98219910712564* 8 bit XOR
$83236921580268* Bitwise XOR two values


=== components/Hdd ===

$75645507178296* HDD


=== components/ByteShl ===

$74488427658653* Shift left
$66482114876737* Shifts the bits of an input left


