=== components/Nand8 ===

$50859914201083* Bitwise NAND two values
$93314093190526* 8 Bit NAND


=== trans/map_available ===

$81707212583931* Available


=== components/Add64 ===

$14174811828377* Adds two inputs
$73418471595285* Add


=== components/Output 1 + 1B ===

$43917122084061* Accepts output for levels


=== main_scripts/leg_level ===

$11144256835662* XORi
$20104629254326* ARGUMENT 2
$89011349770597* NOT
$40520283279584* XOR
$71204580217527* NOTi
$38681417496680* ARGUMENT 1


=== components/DelayLine1 ===

$30487770736917* Delay Line
$38206009264853* Outputs this tick's input, next tick


=== components/Adder Simple ===

$33973952772642* Add
$98429814030509* Adds two inputs


=== misc/ProbeWireBit ===

$49521764791439* Wire Probe (bit)
$15206117280094* Display a value on your custom component or in the program editor


=== components/Neg64 ===

$88458190974122* Negate
$52206550732945* Bitwise negates an input


=== components/DelayLine32 ===

$56616725618490* Outputs this tick's input, next tick
$49292282287971* 32 Bit Delay Line


=== components/Nand64 ===

$27197172037913* 64 Bit NAND
$66590147372797* Bitwise NAND two values


=== components/ByteShr ===

$89595863403484* Shift right
$69394421220436* Shifts the bits of an input right


=== components/DelayLine16 ===

$61925612221077* 16 Bit Delay Line
$65706144678496* Outputs this tick's input, next tick


=== trans/map_programming ===

$44937904689376* PROGRAMMING


=== components/LessU64 ===

$13018528868948* Less (unsigned)
$90244529484227* Checks if one input is less than the other


=== components/Nor64 ===

$17208777467974* Bitwise NOR two values
$72509242083648* 64 Bit NOR


=== components/Rom ===

$24976506406652* ROM
$81743370431597* Read only memory (outside the sandbox)


=== components/LessU16 ===

$91783087669146* Checks if one input is less than the other
$33190791348214* Less (unsigned)


=== components/Xor32 ===

$66299093873977* 32 bit XOR
$38169019785615* Bitwise XOR two values


=== components/Equal64 ===

$34603983706314* Checks if the two inputs are equal
$82876546747608* Equal


=== components/IndexByte ===

$27264669944539* Byte Indexer
$54699455184164* Extracts a byte from a wire


=== components/64Ram ===

$78790416494254* RAM


=== components/Bidirectional16 ===

$31038378395810* 16 bit bidirectional pin
$99604485981015* Can circumvent certain circular dependency errors


=== components/Register ===

$19705753304166* 8 bit memory
$68946767861738* 8 Bit Register


=== trans/map_functions ===

$83960548773205* FUNCTIONS


=== levels/The Product of Nibbles ===

$13549246864135* Bit 0
$10274387271390* Bit 0


=== components/Input 1 Byte ===

$40943344093513* Input


=== components/LessI64 ===

$42718501644862* Less (signed)
$19948786194409* Checks if one input is less than the other


=== components/ByteLessU ===

$68645721548287* Checks if one input is less than the other
$73502755965496* Less (unsigned)


=== main_scripts/functions ===

$87591753278764* Reg {nr}


=== trans/map_complete ===

$81337533438394* Complete


=== components/Program1Red ===

$26811947547688* Programmable memory component
$55594749714809* Program


=== ui/abbreviated_units ===


NOTE: Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M

NOTE: Instead of writing 5839, the number turns into 5.8K
$84696693690500* K

NOTE: Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* B


=== components/Shl16 ===

$79406691850426* Shift left
$34287811246049* Shifts the bits of an input left


=== nim/backend_lib/level_list ===

$15420972347773* RAM
$26705128002562* Conditions
$70993791338383* XOR


=== components/Counter64 ===

$62528867413395* 64 Bit Counter
$62736827510023* Increments each tick, unless overwritten


=== components/BNOT ===

$53686485035156* 8 Bit NOT
$26822227902426* Bitwise negates 8 bits


=== components/Ror64 ===

$43920264894591* Rotate right
$49583010717958* Rotates the bits of an input right


=== components/Output32z ===

$73681609562628* Only outputs if the switch pin is [ON]
$92749186427039* Switched Output


=== trans/map_memory ===

$58330421958143* MEMORY


=== components/Rol8 ===

$79612280948390* Rotate left
$55557725551789* Rotates the bits of an input left


=== components/OR ===

$13013154620359*
[ON] when either input is [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]
$97247779246257* OR


=== components/Clock ===

$72088325385177* Clock


=== components/Xnor ===

$94079327237795* XNOR
$90614106399129*
[ON] when nputs are the same
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]


=== trans/tick ===

$92150881431937* Tick


=== components/1_decoder ===

$26685462633615* Toggles between two outputs
$98250587600120* 1 Bit decoder


=== components/XOR ===

$86856280609387*
[ON] when inputs are different
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]
$54832952840086* XOR


=== components/AND ===

$58912167455465* AND


=== components/IndexBit ===

$89611629299917* Bit Indexer
$84431924133490* Extracts a single bit from a wire


=== components/Not16 ===

$17394768116288* 16 Bit NOT
$91053300263019* Bitwise negates 16 bits


=== trans/map_locked ===

$95146987030704* Locked


=== components/Ror16 ===

$13970397213910* Rotates the bits of an input right
$90115282457191* Rotate right


=== levels/ram_block ===

$16196915566111* 0
$14259545926196* A
$12933801309767* A


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== components/Shr64 ===

$93124177265670* Shifts the bits of an input right
$73798355428095* Shift right


=== components/ON ===

$95896157427528* ON


=== components/Nor16 ===

$57921392198825* Bitwise NOR two values
$69522380057631* 16 Bit NOR


=== components/Constant64 ===

$92424468899005* Constant value
$25858905835416* 64 Bit Constant


=== components/LatencyRam ===

$74156976676497* Latency RAM
$31261866779127* Lowers delay by having save and load take several ticks to complete


=== components/DotMatrixDisplay ===

$18651725958642* 6x8 Dot Matrix Display
$71512568789377* 6x8 pixel display


=== trans/map_cpu_architecture ===

$95559333192525* CPU ARCHITECTURE


=== components/Ror32 ===

$84788620524361* Rotate right
$50013003040535* Rotates the bits of an input right


=== levels/negative_numbers ===

$62744038163781* OK


=== components/DelayLine8 ===

$24840584785792* Outputs this tick's input, next tick
$63449911993783* 8 Bit Delay Line


=== components/Bit Compressor ===

$74338505460996* Turns 8 bits into 1 byte
$98747779812970* 8 bit Maker


=== components/BOR ===

$19406015796751* Bitwise OR two values
$54190050450484* 8 Bit OR


=== components/Console ===

$66743357915699* Console
$16105755937680* 80x24 text character display


=== components/Xnor16 ===

$73699169812942* Bitwise XNOR two values
$40088995721509* 16 Bit XNOR


=== components/ByteLessI ===

$52765625016236* Checks if one input is less than the other
$25403981009644* Less (signed)


=== components/LessI16 ===

$75600169624828* Less (signed)
$73697238171042* Checks if one input is less than the other


=== components/Mux32 ===

$16638728645850* Toggles between two values
$21257226547838* 32 Bit Mux


=== components/Shr32 ===

$87104108203785* Shifts the bits of an input right
$88430124157796* Shift right


=== misc/FileInput ===

$28866575833369* Reads bytes from your hard disk
$34159012148766* File Loader


=== components/Mux64 ===

$14050204031082* Toggles between two values
$66892629981737* 64 Bit Mux


=== components/Bidirectional8 ===

$20234315861487* 8 bit bidirectional pin
$49499540884410* Can circumvent certain circular dependency errors


=== components/BitSwitch ===

$56917313833836* Toggles a bit
$41574334638147* Switch


=== components/DelayLine64 ===

$80000130396288* 64 Bit Delay Line
$35525647389906* Outputs this tick's input, next tick


=== components/Shr16 ===

$20291717268875* Shifts the bits of an input right
$31674686871821* Shift right


=== trans/map_keys_to_pan ===

$26276191141664* Use keyboard to pan


=== components/Xnor32 ===

$17419057954798* Bitwise XNOR two values
$52489451755306* 32 Bit XNOR


=== components/NOR ===

$27510848535619*
[ON] when neither inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell]
[/table]
$83375115196253* NOR


=== components/Screen ===

$12771040946773* Displays the visuals that accompany certain levels
$50037736094411* Screen


=== levels/circular_dependency ===

$16336401898647* Test 1/2


=== components/Off ===

$61860786587357* OFF


=== components/Or3 ===

$17576327690867* 3 pin OR gate
$99630419947500* 3 Pin OR


=== components/Nand32 ===

$24565725389553* Bitwise NAND two values
$71611588991682* 32 Bit NAND


=== components/NAND ===

$71130919681688* NAND
$12903183841172*
[ON] unless both inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== components/Output1Sum ===

$90026011029075* Sum


=== components/Rol32 ===

$88734684504266* Rotates the bits of an input left
$83642246004160* Rotate left


=== components/Ror8 ===

$10802217509530* Rotates the bits of an input right
$70999134800536* Rotate right


=== components/Bidirectional1 ===

$95836352586032* Can circumvent certain circular dependency errors
$34912798641933* 1 bit bidirectional pin


=== trans/map_arithmetic ===

$51337598329530* ARITHMETIC


=== components/Mul32 ===

$98530670555665* Multiply
$51210946736766* Multiplies two inputs


=== components/Halt ===

$30351143139905* Halt

NOTE: This is the default message of the Halt component
$54106972240596* Halt
$62990744955549* Stops execution with a custom message


=== components/ByteAnd ===

$61791872137683* Bitwise AND two values
$21541105796357* 8 Bit AND


=== components/Bidirectional32 ===

$54631386552063* 32 bit bidirectional pin
$35105566244017* Can circumvent certain circular dependency errors


=== components/Output16z ===

$78873885833823* Switched Output
$54278394672948* Only outputs if the switch pin is [ON]


=== components/Counter ===

$51446864816252* Increments each tick, unless overwritten
$67910883947749* 8 Bit Counter


=== components/ByteMul ===

$56549841656852* Multiply
$68631919890554* Multiplies two inputs


=== misc/specifications ===

$68054407020318* Instructions


=== trans/map_assembly_challenges ===

$31733554125775* ASSEMBLY CHALLENGES


=== components/Input1_1B ===

$57868504368581* Loads the input from levels


=== trans/architecture_2 ===

$38100016313511* CPU ARCHITECTURE 2


=== components/NetworkClient ===

$44510554000571* Network
$90462653419289* Handles network connections


=== trans/map_basic_logic ===

$75078723880086* BASIC LOGIC


=== components/Counter32 ===

$87245349851451* 32 Bit Counter
$92765669828982* Increments each tick, unless overwritten


=== components/Maker16 ===

$55864807379312* Turns 16 bits into 2 bytes
$39941195789458* 16 bit Maker


=== components/ByteConstant ===

$29445030761909* Constant value
$25159790815891* 8 Bit Constant


=== components/And3 ===

$19664974941910* 3 Pin AND
$86839706221116* 3 pin AND gate


=== components/NEG ===

$88379907297327* Negate
$62021716182809* Bitwise negates an input


=== components/Switch16 ===

$15221175893882* 16 Bit Switch
$59845475842015* Toggles a value


=== components/Add32 ===

$91616185859914* Adds two inputs
$64111401384153* Add


=== components/LessU32 ===

$72614358420262* Less (unsigned)
$55380524073095* Checks if one input is less than the other


=== components/Counter16 ===

$37313834107391* Increments each tick, unless overwritten
$49104925799943* 16 Bit Counter


=== components/Output8z ===

$16915419621070* Switched Output
$58449766432492* Only outputs if the switch pin is [ON]


=== components/Not32 ===

$33620523355085* 32 Bit NOT
$24607331341411* Bitwise negates 32 bits


=== components/Equal32 ===

$32710942647020* Equal
$32433537137277* Checks if the two inputs are equal


=== components/NOT ===

$34453052824732* NOT
$90844421681709*
Inverts the input
[table=3]
[cell]Input[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== components/MemoryProbe ===

$46948613505134* Display a value on your custom component or in the program editor
$44867305035474* Memory Probe


=== components/Add16 ===

$28092601427278* Adds two inputs
$30820974870562* Add


=== components/Or32 ===

$92752025948920* Bitwise OR two values
$40180779432911* 32 Bit OR


=== components/3_decoder ===

$59129788113517* Toggles between eight outputs
$94375716460090* 3 Bit decoder


=== components/Byte Expander ===

$60488114435022* Splits a byte into 8 bits
$21904470559153* Byte Splitter


=== components/And16 ===

$56198785587874* Bitwise AND two values
$26727645933234* 16 bit AND


=== misc/StateProbe ===

$54427436420428* Wire Probe
$15969687819995* Display a value on your custom component or in the program editor


=== components/Splitter32 ===

$90978982016052* Splits 32 bits into 4 byts
$24096666569346* 32 bit Splitter


=== trans/map_working_computer ===

$38843517090942* WORKING COMPUTER


=== components/Xnor8 ===

$31985293401482* 8 Bit XNOR
$45789912406647* Bitwise XNOR two values


=== components/Shl32 ===

$38930281262898* Shift left
$88685329847417* Shifts the bits of an input left


=== components/Shl64 ===

$56766765894165* Shifts the bits of an input left
$37014604954362* Shift left


=== components/And64 ===

$80790829001391* 64 bit AND
$89424947351456* Bitwise AND two values


=== components/Program64 ===

$76480303942112* Programmable memory component


=== components/FastRam ===

$79436020115192* Fast but high gate cost memory
$12924829814634* Fast RAM


=== components/Output64z ===

$61656790122480* Switched Output
$42506906257154* Only outputs if the switch pin is [ON]


=== components/ByteEqual ===

$35668435514829* Checks if the two inputs are equal
$39369982838671* Equal


=== components/Mul64 ===

$72281597169494* Multiply
$11665562499390* Multiplies two inputs


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== components/Splitter64 ===

$80420054807186* Splits 64 bits into 8 byts
$14205692632393* 64bit Splitter


=== components/switch ===

$87345192339084* Toggles a value
$29301846684808* 8 Bit Switch


=== components/Register64 ===

$86007777261800* 64 Bit Register
$99461037008796* 64 bit memory


=== components/Splitter16 ===

$92674917729864* 16 bit Splitter
$28271182652741* Splits 16 bits into 2 byts


=== components/ByteShl ===

$74488427658653* Shift left
$66482114876737* Shifts the bits of an input left


=== components/SRLatch ===

$11641785582600* Set/Reset Latch
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== components/Maker32 ===

$82420653444614* Turns 32 bits into 4 bytes
$85308499118176* 32 bit Maker


=== main_scripts/dialouge ===


NOTE: Hitn for byte switch
$86319296925137* What would this look like if you were only switching 1 bit? What would the truth table for such a component look like?

NOTE: hint for the bus
$50799425816171* Use switches to put the inputs on the same wire.

NOTE: hint for odd number
$68750974209145* You can figure out if 2 inputs have an odd number of [ON] with just 1 component...

NOTE: Hint for the maze
$36837749971886*
Always following the left (or right) hand side of the maze will make sure you eventually reach the exit.
	
The pseudo code for such an algorithm looks like this:
 Step forward
 Turn left
 Turn right as long as there is a wall ahead
 Press use after each turn (in case the exit is ahead)
 Repeat

NOTE: hint for counting signals

NOTE: Hint for byte adder
$37093555217568* You only need 8 full adders.
$21044442262778* The circuitry for the 1's bit is the same as what you did in the level "Odd Number of Signals". The circuitry for the 2's bit is what you did in "Double Trouble", except when all 4 are on.

NOTE: hint for saving gracefully
$25321701584378*
In this level you need to use 1 Delay Line. Make a truth table for what should go into the Delay Line. Consider the input to the Delay Line as the output for your table. 

The inputs are the 2 level inputs AND the output of the Delay Line, as the output plays a role in its input. In total you have 3 "inputs" to for this table which gives you 8 combinations. Once you have the level requirements as a table, it should be a lot easier to solve.

NOTE: Hint for conditions
$87674181578455*
There are 3 condition bits. The first bit being [ON] means the result being 0 meets the condition. The second bit being [ON] means the result being less than 0 meets the condition. If either of those two are [ON], the condition is met. 
Finally, if the last bit is [ON], negate the status of the condition being met or not.

NOTE: hint for xor gate
$88963098241493* This level can be done with 3 components, a NAND, an AND and an OR gate.

NOTE: Hint for masking time
$46866534894828*
In binary, taking modulo 4 of a number is the same as only using the two lower bits. This is because the higher bits represet 4, 8, 16 etc, and they all divide 4 with no remainder.
This is true in general for modulo a power of 2, the lowest bit of a number represents that number modulo 2 (even or odd), the lowest 3 bits modulo 8 and so on.

Likewise, in decimal 4321 modulo 100 is also simple (answer is 21, the higher digits are disregarded), this is because 100 is a power of 10.

Now you just have to figure out how to get the last 2 digits of a number.

NOTE: hint for less
$56438995128380*
First determine which bits are different between the 2 bytes. This can be done using a byte XOR (remember XOR turns [ON] when the inputs are not the same). We know the number that has the highest different bit [ON] is the larger number. But we must only consider the highest different bit, so for each bit, use a chain of OR gates to check if any higher are [ON].
		
Finally, the last bit is considered seperately for signed numbers, here it has the opposite effect (if only one number has it [ON], that number is guaranteed to be lower)


=== components/Neg32 ===

$26991597084705* Negate
$35735598635057* Bitwise negates an input


=== components/Xor64 ===

$95012060885697* 64 bit XOR
$13031452187028* Bitwise XOR two values


=== components/Ram ===

$95418291334002* 256 Byte Ram
$27094240214067* Memory component


=== components/Constant16 ===

$85825068431072* 16 Bit Constant
$61330657823382* Constant value


=== components/ByteXor ===

$98219910712564* 8 bit XOR
$83236921580268* Bitwise XOR two values


=== components/Hdd ===

$75645507178296* HDD


=== components/LessI32 ===

$87609006355839* Less (signed)
$99994775592318* Checks if one input is less than the other


