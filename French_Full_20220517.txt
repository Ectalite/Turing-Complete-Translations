=== components/Output 1 ===

$12242923444593* Sortie


=== levels/RAM ===

$17967666262990 Dans ce niveau, copie d'abord 32 valeurs et sauvegarde chacune d'elle. Après les avoir sauvegardées, envoyez-les vers la sortie dans l'ordre d'arrivée. Envoyer une valeur vers la sortie avant d'avoir stocké toutes les valeurs te fera perdre le niveau. 
$13520918982355 Ajoute un bloc de RAM, ainsi l'ordinateur aura 256 octets de mémoire en plus. Tu dois trouver un moyen d'accéder à un octet indépendamment des autres. Indice : nous utiliserons un registre pour choisir l'adresse de la RAM, ainsi si tu veux sauvegarder ou charger une valeur, tu pourras indiquer l'adresse dans ce registre.


=== levels/byte_less_i ===

$16755383054285 [center]Détermine si la première entrée est plus petite que la seconde.[/center]
$19006843777401 Crée un circuit qui sortira [ON] quand la première entrée est plus petite que la seconde. Interpréte les octets comme étant [color=#dd6576]SIGNES[/color].
$46083799633716* {input\_1} est plus petit que {input\_2}?


=== levels/maze ===

$13225915898937
Si tu réussis ce niveau, je te montrerai comment fonctionne la RAM, la pile et l'appel de fonction. Tu pourras ainsi résoudre des défis plus intéressants comme celui-ci.

Mais avant, tu dois construire un meilleur ordinateur. [color=#e49f44]OVERTURE[/color] était une bonne première machine, mais elle est construite à l'arrache et les programmes sont rapidement illisibles.
Pour résoudre les défis que je t proposerais sans t'arracher tous les cheveux qu'il te reste, tu auras besoin d'un élément en plus : l'architecture [color=#e49f44]LEG[/color].
$17275059688693 Bravo ! Tu as réussi la compétition, c'est une prouesse incomparable !
$13741358519166 Le labyrinthe mythique. Si tu réussis à en sortir, tu gagneras la compétition!
$11103446544344 D'un autre côté, tu peux aussi fièrement partir et ne pas être mangé. 
$19331074553774
Écris un algorithme qui permettra au robot de sortir du labyrinthe.

Ce niveau est dur, tu devrais d'abord écrire ton algorithme sur le papier avant de l'implémenter ici.

Utilise [color=#e63e5b][url=maze]cet indice[/url][/color] si tu es coincé. 

[tip]Souviens-toi que tu ne peux pas utiliser de valeur immédiate plus grande que 63, attention donc à ne pas vouloir sauter à une ligne plus bas que la ligne 63.[/tip]


=== misc/delay_overlay ===

$85430022417382* Montrer les délais


=== levels/push_pop2 ===

$10062117579269* Ajoute la pile à ton ordinateur
$14685569269160
Dans ce niveau on attend que tu ajoutes la pile à l'ordinateur et que tu écrives un programme pour le résoudre.
Quand l'entrée est 0, tu dois [color=#e49f44]DÉPILER[/color] une valeur de la pile et l'envoyer en sortie. Quand l'entrée n'est pas 0, tu dois l'[color=#e49f44]EMPILER[/color] sur la pile.
$18561605111721* EMPILER {input} sur la pile
$59658696292688 DÉPILER {value} de la pile


=== misc/options ===

$49251062339706* Options


=== levels/turing_complete ===

$15326252036920* Jusqu'à maintenant, le code pouvait seulement influencer la mémoire. Maintenant la mémoire doit pouvoir influencer le code. Avec l'ajout de la logique conditionnelle, ton ordinateur va pouvoir faire tourner n'importe quel algorithme et pourra tout calculer.
$16583885726240 Bravo, tu as réussi ! Je pensais juste que t'étais un singe bizarre, pas poilu, mais t'as réussi à créer un vrai ordinateur ! INCROYABLE ! 
$10510746154639* Au premier cycle, le programme devrait charger l'adresse 1.
$10317244906317* Aucun programme trouvé.
$14587485007736 Jusqu'à maintenant, les programmes étaient limités à tourner dans l'ordre dans lequel ils étaient écrits, octet par octet.
$19649119273248
La dernière chose que l'on doit rajouter est un mécanisme pour changer le compteur de programme avec des [INSTRUCTIONS] quand certaines conditions sont respectées.

Quand les deux deux bits les plus importants sont à [ON][ON], alors l'ordinateur sera en mode conditionnel. Dans ce mode, la valeur du registre 3 sera comparée avec une condition définie par les 3 bits les moins importants. Si la condition est vraie, le programme compteur prendra alors la valeur du registre 0.
Grâce à ce nouveau mode, tu pourras maintenant créer des boucles et sauter une ou plusieurs [INSTRUCTIONS].

Conditions:
[OFF] [OFF] [OFF] Jamais
[OFF] [OFF] [ON] Si [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] Si [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [OFF] [OFF] Toujours
[ON] [OFF] [ON] Si [color=#e49f44]REG 3[/color] ? 0 
[ON] [ON] [OFF] Si [color=#e49f44]REG 3[/color] ? 0
[ON] [ON] [ON] Si [color=#e49f44]REG 3[/color] > 0

Ces conditions correspondent au composant que tu as sauvegardé dans l'atelier de composants.


=== components/Input 1 ===

$12746117288689* Entrée


=== levels/Second Tick ===

$14355963067874* Activer la sortie au second cycle d'horloge.
$17526582195506* Comme tu sais ces tests visent à réaliser un ordinateur qui fonctionne.
$15726318553190* C'est ce qui explique que tu ne seras pas mangé à la fin.
$19277843280528*
 [color=#b72d41][b]TIP:[/b][/color] 
 Tu peux sélectionner un composant et ses pattes en double-cliquant dessus
$15296208528991* Les espèces capables de finir sont considérées légalement intelligentes.


=== levels/buffer ===

$10260210687588* [center]Test 2: l'entrée gauche est [img]dialogue/on.png[/img], la sortie droite devra être [img]dialogue/on.png[/img].[/center]
$13309706297402* [center]Test 3: l'entrée droite est [img]dialogue/on.png[/img], la sortie gauche devra être [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Assure-toi que [img]dialogue/on.png[/img] ne peut se propager que de gauche à droite.[/center]
$18349621873762* [center]Test 1: les deux entrées sont [img]dialogue/off.png[/img], aucune sortie ne devra être [img]dialogue/on.png[/img].[/center]
$15504762262759
Ce niveau démarre avec 2 composants spéciaux. Ils jouent les rôles à fois d'entrée et de sortie.

Assure-toi que le signal ne se propage que de gauche à droite. Il y aura trois vérifications.

[b]Test 1[/b]: Les deux côtés seront [OFF].

[b]Test 2[/b]: L'entrée gauche [ON] et le côté droit devra être [ON].

[b]Test 3[/b]: La sortie droite deviendra [ON] et le côté gauche devra être [OFF].


=== levels/component_factory ===

$14665712485657* Ce composant personnalisé ne peut pas être utilisé car il n'a aucune surface.
$17077079648771* Des composants peuvent être ajoutés, renommés ou supprimés en utilisant le système de sauvegarde du niveau.
$19551383617326*
Bienvenue dans l'atelier de composants, les schémas que tu crées ici pourront être utilisés comme composants dans les niveaux d'architecture.
Le composants importé aura le même comportement et son schéma définira sa forme.
$12516102012088* Ce composant n'a pas de forme définie et ne pourra pas être réutilisé. Placer des composants sur la carte pour définir sa forme.
$14712417427860* Comme ce niveau est un outil et pas un défi, tu peux revenir à la carte des niveaux pour continuer quand tu voudras.
$15549447390000* 2 composants d'entrée/sortie sont dans la même zone. Le composant personnalisé sera inutilisable car 2 pattes ne peuvent se chevaucher.


=== ui/state_ui/state_ui_output_bit ===

$40754755480566* Sortie


=== misc/instr_delete ===

$91861509153454* Supprimer


=== levels/ai_showdown ===

$14940806461794*
Les jeux d'argent sont son unique point faible. Nous l'avons convaincu de jouer à un jeu de cartes contre toi et si tu gagnes, il a promis de se calmer.
Tu dois gagner, tu es notre seul espoir !
$17297225655678* NAK 02 est notre robot ingénieur en IA. Il est brillant, mais parfois il tourne mal et essaie de fomenter une rébellion.
$18848103966031*
Règles du jeu : Il y a 12 cartes sur la table, chaque joueur joue à son tour et doit prendre entre 1 et 3 cartes. Tu commences et le joueur qui prend la dernière carte (le joker) perd.
Le nombre de cartes courant sera fourni sur l'entrée. Envois 1, 2 ou 3 sur la sortie pour indiquer le nombre de cartes à prendre. NAK 02 réagit instantanément, tu peux consulter l'entrée sans délai pour obtenir le résultat de son tour. 
$11794110848012* Cette fois il a pris le contrôle du poste de contrôle et retient en otage le capitaine.


=== misc/ui_comment ===

$69987793052607* Commentaire de fil (Cliquer sur le fil)


=== levels/delay_level ===

$19986989895202*
Tous les composants ont un délai. Au niveau du schéma, le délai cumulé est déterminé par le chemin le plus lent. En pratique ça signifie qu'il faut paralléliser les choses.
Dans ce niveau tu vas devoir prouver que tu as compris ce concept.
$11246430085016* Le délai de propagation est visible en cliquant sur le sablier dans le coin supérieur droit.
$12817338693402* Le délai de tous les composants dérivent en fin de compte du délai de la porte NAND, qui a un délai de 2. Réalise un circuit ayant un délai de 6 et un coût NAND de 5.


=== components/Output1z ===

$46173002346157* Sortie


=== levels/signed_negator ===

$10866019808027* Pour ce niveau je te conseille d'activer les nombres signés pour que le dernier bit affiche -128. Clique sur "+255" visible dans le cadre du haut.
$10400106910274*
Considérant que l'entrée est signée (8ème bit valant -128), réalise un composant qui prend un nombre et envoie l'opposé en sortie.
Par exemple l'opposé de 4 sera -4. -9 produira 9 en sortie.


=== ui/options/Controls ===

$53266310714298* Contrôles


=== nim/backend_lib/level_list ===

$58391129129347* Registres (Registers)
$45936227746026* Compteur (Counter)
$16881141174140* Course Binaire (Binary Racer)
$12946639957230* Porte NOT (NOT Gate)
$37136208388559* Bascule SR (SR Latch)
$32191988336459* Sauvegarde parfaite (Saving Gracefully)
$59136962133320* Moteur Logique (Logic Engine)
$30920780473397* Dépendance Circulaire (Circular Dependency)
$83321010943153* Compter des Signaux (Counting Signals)
$58769021955965* Décodeur 3 bits (3 Bit Decoder)
$78673715398197* Valeurs Immédiates (Immediate Values)
$49679174636208* XOR Octet (Byte XOR)
$40356575891647* OR Octet (Byte OR)
$44393538021725* Calibration des Canons Laser (Calibrating Laser Cannons)
$61228036919534* Tours d'Alliage (Tower of Alloy)
$87426564872318* Diviser (Divide)
$24593959732668* Négation signée (Signed Negator)
$19487493622742* Demi-additionneur (Half Adder)
$94163943335575* Le Bac à Sable (The Sandbox)
$64662599400870* Inverseur de bit (Bit Inverter)
$14193654974055* Inférieur Signé (Signed Less)
$59485174474959* Délices ordonnés (Delicious Order)
$74096060570427* Instructions Larges (Wide Instructions)
$14522992467987* Porte OR (OR Gate)
$30630492494839* NOT Octet (Byte NOT)
$11457737665157* Plat de Spaghetti (Wire Spaghetti)
$27566801288091* Atelier de composants (Component Factory)
$85514901357243* Addition d'Octets (Adding Bytes)
$98013649264532* Pile (Stack)
$35790581910835* Second Cycle (Second Tick)
$94979277765051* Course de Robots (Robot Racing)
$13303326918621* Porte NAND (NAND Gate)
$16463062897451* Réveil brutal (Crude Awakening)
$28827008935802* Le Labo (The Lab)
$77495536880911* Porte NOR (NOR Gate)
$61466151084505* Invasion Spaciale (Spacial Invasion)
$20858506932774* Porte AND (AND Gate)
$92696642439976* Confrontation d'IA (AI Showdown)
$62326481348276* Le Labyrinthe (The Maze)
$74512388889988* Moteur Arithmétique (Arithmetic Engine)
$50884376329157* Petite Boite (Little Box)
$70651296323768* Porte XOR (XOR Gate)
$31140969090253* Noms de Planètes (Planet Names)
$74688348772072* Le bus (The bus)
$42873691377272* Ajouter 5 (Add 5)
$68155633878444* Délais (Delay)
$45773199639367* Cycles pairs (Odd Ticks)
$17198602105978* Inférieur non signé (Unsigned Less)
$43018398941741* Toujours On (Always On)
$36114120875026* Craqueur de code (Storage cracker)
$33343343932901* Turing Complet (Turing Complete)
$95989050249094* Porte AND en plus grand (Bigger AND Gate)
$69830943995038* Sens Unique (One Way)
$81417895515868* Commutateur de bits (Bit Switch)
$62167495140389* Décaler (Shift)
$87626070552799* Additionneur complet (Full Adder)
$13219675195117* Nombre IMPAIR de Signaux (ODD Number of Signals)
$63331549672739* Codes Opération (Opcodes)
$28985439820134* Le produit des Quartets (The Product of Nibbles)
$94896856420525* Porte XNOR (XNOR Gate)
$25805639594354* Programmer (Program)
$57870391153000* Valeurs Immédiates (Immediate Values)
$96825664933181* Fruit invisible (Unseen Fruit)
$56272944092958* Lignes très en retard (Delayed Lines)
$86717899742637* Sauver les Octets (Saving Bytes)
$53092952738479* Sélecteur d'Entrée (Input Selector)
$77453667419150* Décodeur d'Instruction (Instruction Decoder)
$96898830278153* Constante Octet (Byte Constant)
$17750429607702* Décodeur 1 bit (1 Bit Decoder)
$59939822079116* Nombres Négatifs (Negative Numbers)
$79570913613529* Doubler les Nombres (Double the Number)
$49328023903824* Égalité (Equality)
$33132016601448* Empiler et Dépiler (PUSH and POP)
$74292408260828* Calculs (Calculations)
$45480765206717* Conditions (Conditionals)
$71126291573555* Doublement compliqué (Double Trouble)
$91267697977186* Course Hexa (Hex Racer)
$75225719777307* Monde Aquatique (Water World)
$64615090872051* Fonctions (Functions)
$84208736840052* Compter les jours (Masking Time)
$36221227239949* Machine à Danser (Dancing Machine)
$91954159574064* Porte OR en plus grand (Bigger OR Gate)


=== misc/run ===

$67345621265845* Démarrer les cycles (Raccourci : F6)


=== components/Input16 ===

$34560561101846* Entrée


=== levels/Opcodes ===

$19693461238792* Fixe l'incrément du compteur à 4
$38976231780455* Point d'observation {nr} doit cibler un registre ou un composant personnalisé contenant un registre
$20916717363300* Point d'observation {nr} doit cibler la sortie
$18189600217529* [center]Implémente l'instruction OPCODE[/center]
$13450117997204* Ajoute un compteur dans le circuit
$77044880242883* Point d'observation {nr} doit cibler le compteur
$13870568875751* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$10303603301757*
Implémente les opcodes suivants :
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

L'opcode NOT ignore le second argument.
$17495651785164* Ajoute 6 registres à la carte


=== levels/test_lab ===

$11038144815919*
Ce niveau utilise des programmes pour tester tes circuits. Quand les programmes sont lancés, ce niveau vérifie si l'"état surveillé" évolue comme attendu.

Le labo a 2 mots-clés supplémentaires.

Le mot-clé [color=#c54d5e]expect[/color] sert à décrire la valeur attendue au cycle suivant à une adresse mémoire.

La première valeur après [color=#c54d5e]expect[/color] est l'index de l'état surveillé, la seconde est la valeur attendue. L'index de l'état surveillé correspond à l'ordre dans lequel les composants sont connectés au composant Programme.

[img]dialogue/watched\_state.png[/img]

Par exemple :
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]\_[/color] [color=#4a9658]r2[/color][/code]

Ici la première ligne indique que nous attendons une valeur de 4 en 2ème position de l'état surveillé.

Toutes les valeurs des états surveillés sont comparées aux valeurs attendues à chaque cycle. Toutes les valeurs sont attendues à 0 au démarrage du programme, et tu peux ensuite modifier explicitement ces valeurs attendues. La seule exception concerne les compteurs, il est attendu qu'ils s'incrémentent à chaque cycle.

[color=#c54d5e]set\_input[/color] est le second mot-clé spécifique au labo. Avec lui tu peux contrôler l'entrée de l'ordinateur :
[color=#c54d5e]set\_input[/color] [color=#eb9433]123[/color]

Tu peux en permanence également (ré)importer les tests d'exemple en cliquant ci-dessous :
[url=import\_overture][color=#e49f44]OVERTURE[/color][/url]
$32399229965611* De plus, comme tu viens de finir [color=#e49f44]LEG[/color], j'ai débloqué tous les composants 16, 32 et 64 bit que tu trouveras dans le bac à sable.
$15446846177093* Bienvenue au labo. Comme l'atelier de composants, ce n'est pas un niveau normal mais un outil.
$16072814175447* Programmer du matériel bugué est très frustrant. Il est pénible de devoir soudainement se poser des questions sur les circuits quand on est en pleine résolution d'un problème de programmation. Il est tentant de faire un correctif rapide afin de revenir au problème initial. Mais maintenant ce correctif vite fait a cassé autre chose dans un programme qui fonctionnait jusque là et ainsi de suite. Au final, en développant le matériel essaie de viser 100% de fiabilité avant de démarrer la programmation !


=== levels/Nor GATE ===

$11362258372706
La plupart des créatures sur la Terre sont agressives et ne savent pas se concentrer.

Pour réussir, tu dois apprendre à raisonner, sans rien casser.


=== ui/state_ui/title_screen/play ===

$66967233942803* Jouer la Campagne


=== levels/byte_not ===

$14196498898485 La réalisation et l'utilisation d'outils est fondamental lors des premières étapes de l'évolution de l'intelligence.
$12982025748137* Applique "NOT" sur chaque bit de l'octet en entrée.
$10294533225655 Notre précédent modèle utilisant la taille du cerveau pour prédire l'intelligence était naïf.
$14958585065722* En fait c'est le nombre de bras d'une créature qui est clairement le principal prédicateur de l'intelligence. Savais-tu qu'il existe des créatures marines sur ta planète avec quatre fois plus de bras que toi et qui réussissent mieux dans les tests ?


=== misc/watchable_state ===

$58678516111149* Éditer les espions


=== levels/wide_instrucitons ===

$13709034294291* Mémorise lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17693995237077* Envoie en sortie les deux octets
$19068760748550* Envoie 0 en sortie à chaque cycle pair
$65009239162932* Les sorties correctes étaient {a} et {b}
$19203973423116* Réalise un circuit qui enregistre la sortie du programme lors des cycles pairs et envoie en sortie les deux octets lors des cycles impairs.
$17409169138995* Mémorise l'octet


=== levels/bit_switch ===

$56295261249455*
Si les composants envoient en sortie des valeurs différentes sur le même fil, tu auras une erreur. Par contre, certains composants ont des pattes de sortie grises, elles n'envoient rien en sortie quand le composant n'est pas activé. C'est le cas du composant Commutateur de bit (Bit Switch).

[img]dialogue/bit_switch.png[/img]

Cela signifie que plusieurs de ces pattes grises peuvent être connectées au même fil et ne pas causer d'erreur, tant qu'il n'y a pas plus d'une d'entre elles activée à la fois.
$42793594302151* En utilisant 2 portes NOT et 2 Commutateurs, construis une porte XOR.


=== misc/lab_toggle ===

$16432178820878* le Labo


=== levels/Calculations ===

$14458828731919*
C'est maintenant qu'il faut intégrer le circuit "Unité Arithmétique" réalisé précédemment avec le circuit registre. Le circuit de calcul a été enregistré dans l'atelier de composants et est maintenant utilisable en tant que composant. Si tu as oublié à quoi correspondent les pattes retourne regarder le circuit dans l'atelier de composants.

Utilise le décodeur déjà construit pour déterminer si l'on doit copier de registres à registres ou faire un calcul. Voici pour rappel les 4 modes possibles:
[OFF][OFF] Constante
[ON][OFF] Copie
[OFF][ON] Calcul
[ON][ON] Condition

Pour ce niveau tu n'as pas à t'occuper que des modes copie et calcul, lis les [INSTRUCTIONS] détaillées dans le panneau du haut. En mode calcul, prends [color=#e49f44]REG 1[/color] et [color=#e49f44]REG 2[/color] comme entrées et envoie le résultat dans [color=#e49f44]REG 3[/color].

[tip]Pense à la patte de désactivation du décodeur 3 bits.[/tip]
$13013863429580* Pour ce niveau une patte supplémentaire a été ajoutée aux registres. Cette patte émet toujours en sortie la valeur du registre même lorsque la lecture n'est pas activée.


=== levels/Counter ===

$17701404772563* Ajouter 1
$17940006660359* Compter
$68874699768861* Enregistrer {value}
$17263901743088*
Construis un compteur qui s'incrémente de 1 à chaque cycle.

De plus il doit y avoir la possibilité de forcer le compteur à une valeur fournie.

Tu reçois 2 entrées, un bit et un octet.

Le bit en entrée permet de basculer entre les modes comptage et enregistrement de la valeur de l'octet.
$17883663978196* Enregister
$10555159894041
Compter est tellement fondamental que même les insectes le font. À partir de là, les espèces peuvent évoluer vers la comparaison et le calcul. Et alors que l'on ne s'y attend pas, voilà que des singes construisent des ordinateurs...

Réalise un composant qui compte en s'incrémentant une fois par cycle.


=== misc/sandbox_toggle ===

$30516879701896* Bac à Sable


=== levels/byte_shift ===

$16023356915123* Ta tâche dans ce niveau est de décaler vers la gauche la première entrée en fonction de la valeur de la seconde entrée. Cette seconde entrée aura au maximum un valeur de 7.
$37338672894296* Décale les bits de {value} de {amount} positions vers la gauche.
$10598344098990* [center]Décale la première entrée vers la gauche du nombre de position indiquée par la seconde entrée[/center]
$16216408139965*
[color=#e49f44]Décaler[/color] une valeur à gauche de 1 signifie déplacer tous les bits de l'octets de 1 position vers la gauche.
Par exemple : [color=#e49f44]90 decg 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Décalage de 3 : [color=#e49f44]90 decg 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] deviendrait :
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]
$18137790657923* En plus de te faire faire le composant décaler à gauche, nous avons aussi demander au stagiaire de faire le composant décaler à droite. Il lui a suffi de réaliser une version miroir de ce schéma.
$18518173140953* Je te recommande d'ajouter [color=#e49f44]décaler gauche[/color] et [color=#e49f44]décaler droite[/color] à tes circuits pour les prochains niveaux.


=== main_menu/sandbox_button ===

$16857608955464* bac à sable


=== levels/xnor ===

$11090938799865 Crée la porte XOR inverse, connue sous le nom de XNOR.


=== levels/decoder ===

$16133643476631 Le circuit que tu as créé dans le niveau "Registres" peut copier des valeurs entre différents registres, tandis que "l'Unité arithmétique et logique" a la capacité de faire différentes opérations avec ses deux entrées.
$18435544383511* CALCULER\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383* COPIER
$18945946395447
Pour distinguer les 4 [INSTRUCTIONS], nous utiliserons les deux bits de plus haut poids qui définieront le MODE dans lequel nous serons.
Cette liste montre les 4 modes à implémenter:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Valeur immédiate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculer
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copier
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition logique

Ici [ANY] veut dire que l'ont peut avoir n'importe quelle valeur.

Déterminez le mode dans lequel nous sommes à partir de l'entrée et envoie [ON] vers la sortie correspondante.
$15440615199508* Condition logique
$12671132029272* Votre circuit à été sauvegardé dans l'atelier de composants.
$15105859227432* COPIER \n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$16785126425267* Calculer
$12068329066372 [b]ATTENTION: CETTE VERSION DU CIRCUIT EST OBSOLETE, IL FAUT CLIQUER SUR L'ICONE DE SAUVEGARDE ET CREER UNE NOUVELLE VERSION DE CE CIRCUIT[/b]
$11382827588408* Condition logique\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611* Valeur immédiate\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* Valeur immédiate


=== levels/bit_inverter ===

$15769391111364 Quand "Inverser" est [ON], tu dois sortir l'inverse de la valeur d'entrée. Sinon, copie l'entrée sur la sortie.
$15272914096446* Ce niveau est exactement comme le XOR que tu as résolu avant. N'oublie pas : la seule vérité se trouve dans la table de vérité.
$14944872827527 Malgré le drôle de contexte que nous t'avons donné, tu as réussi à voir qu'il ne s'agissait en réalité que d'une porte XOR déguisée. Bien joué !
$16125025706490 Hmm, peut-être que tu as étudié un peu trop les mémoires...
$13224963076378* Nous étudions comment les expériences passées influent les fonctions cognitives des humains.


=== levels/ram_block ===

$17142958857584* A OU B
$12901484249817 Pourras-tu mettre 4 octets de mémoire dans un espace aussi limité ?
$15908016538045* VALEUR
$14218335256117*
Dans notre civilisation avancée, forcer les prisonniers à faire des tâches complexes est de l'esclavage et est techniquement illégal.
    C'est pour cela que nous avons dit au stagiaire de faire une version 256 octets de votre composant.
$13765566466116* NE PAS SAUVEGARDER
$32676754026463* Sauvegarde {value} et charge
$30856781458049* Sauvegarde {value}
$12306130287676
Dans ce niveau tu devras construire un circuit qui pourra
[SAUVEGARDER] ou [CHARGER] 4 octets de mémoire différents. 

1 Bit sera donné pour [CHARGER] et un autre pour [SAUVEGARDER].
Enfin, 2 bits seront donnés pour l'adresse.

Avec 2 bits, tu auras 4 combinaisons possibles, une pour chaque octet de mémoire dans ce niveau.
[i][tip]Rassemble les fils au centre et utilise des angles droits, sinon ce sera le bazar ![/tip][/i]
[i][tip]La barre d'espace fait tourner les composants.[/tip][/i]
$18084166025569* Rien
$13082830776248* NE PAS SAUVEGARDER
$17473197268827* CHARGER
$13555908976270* 0 OU 1
$10311371309532* SAUVEGARDER
$16925432534232* CHARGER
$13644027370563* Charger
$12291627335021* SAUVEGARDER


=== main_scripts/overture_level ===

$27259865408750* Au prochain cycle la valeur du compteur sera {next}, on attend {expected}
$95030012922256* L'Entrée doit être activée seulement si nécessaire
$12873109232054* On attendait {expected} en sortie, pas {got}
$47188699762650* La Sortie devrait être activée et ce n'est pas le cas
$28026304798371* La Sortie ne devrait être activée que quand c'est nécessaire
$85260864781281* L'Entrée devrait être activée et ce n'est pas le cas
$96569633331621* Charge {value} dans le REG 0
$83829200305236* On attendait {expected} en sortie, pas {got}


=== levels/Further Delayed Lines ===

$17366913897135* Construis un circuit dont la sortie est identique à l'entrée avec un retard de 2 cycles.
$60989431641221*
Ce niveau présente le composant Ligne à Retard. Sa sortie est identique à l'entrée avec 1 cycle de décalage.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356
Nous avons besoin de valeurs négatives dans les octets. Le système que nous avons utilisé jusqu'ici représente tous les nombres de 0 à 255 avec un octet. Ce système est appelé "non signé", car il ne gère que les nombres positifs.

Nous avons besoin d'un système pour gérer les nombres négatifs, habituellement nommé représentation "signée".

De plus, cela simplifierait grandement les prochains circuits si la représentation fonctionnait avec l'additionneur que tu as déjà réalisé.
$17231048881956* Pour mesurer la différence entre deux valeurs, tu as besoin de la soustraction. Pour soustraire, tu as d'abord besoin des nombres négatifs.
$70755151984986* {a} devrait être {b}
$11067230116844* {number} n'a pas de représentation
$19118970740682*
[color=#dd6576]Modifie les valeurs[/color] pour chaque bit de façon à respecter les objectifs suivants :

[color=#e49f44]1[/color]: Tous les nombres de -127 à 127 doivent pouvoir être représentés
[color=#e49f44]2[/color]: Les Octets représentant les valeurs de 0 to 127 doivent être les mêmes qu'en non signé.
[color=#e49f44]3[/color]: Le nouveau système doit fonctionner avec l'additionneur (pour les résultats entre -127 et 127).
$15431436023571* Tu as deux façons de représenter 0\nCe qui conduit à 0 + 1 = 0
$28284583096369* 1 plus -1 n'est pas égal à 0\n  
$57604042654667* {number} n'a pas de représentation


=== levels/robot_race ===

$15403032472607 La course de robots est notre sport favori sur le vaisseau. Des robots programmés par différentes personnes vont essayer d'arriver à a fin de la course le plus rapidement possible. Le gagnant sera le programmeur dont le programme aura le moins de ligne.
$19966247197959 Cette fois-ci tu contrôleras FastBot : il ne peut pas voir ce qu'il y a devant lui, mais il peut tourner et avancer durant le même coup d'horloge. (Il porte aussi des baskets rouges pour aller plus vite).


=== levels/NAND Gate ===

$17420270098223 Dans ce niveau, le but sera de comprendre comment fonctionne une porte NAND. Sois [color=#dd6576]sur[/color] de savoir comment elle fonctionne avant de valider le niveau, sinon tu pourrais être bloqué dans le prochain!
$11034378482152 Correct ! Tu as débloqué la porte NAND. Avec ce composant tu pourras construire tout le reste de ton ordinateur!
$18270083417453* Vérifier
$19208664264770 [b]Consigne[/b]\nClique sur l'un des boutons de la dernière ligne du tableau.
$17923274216766 Nous en avons conclu que tu n'es probablement pas une plante.
$14777350869870 Nous sommes impressionnés par ta capacité à résoudre le dernier test !
$17994568832660 [b]Consigne[/b]\nLa porte NAND au milieu du circuit change son comportement.\nUtilises la barre sur la gauche pour expérimenter les effets qu'ont les entrées sur les sorties et compléte le tableau en conséquence.


=== components/Input 2 ===

$86870364449392* Entrée


=== components/Bidirectional8 ===

$18489033809282* Pattes sans mémoire tampon


=== misc/ide_control_link ===

$80788685813993* Contrôles du Robot


=== levels/Calibrating Laser Cannons ===

$11331851878040* Tu as aussi accès maintenant à la programmation en assembleur. Cela te permet d'utiliser des noms pour les instructions, tu peux par exemple taper "add" au lieu de saisir 68.
$11023157447564*
2×π×r

r est l'entrée.
Et tu peux approximer π avec 3.

Envoie la réponse en sortie quand elle a été calculée.
$15260627694444* Pour calibrer ce laser, nous te demandons de calculer la circonférence des astéroïdes en utilisant une équation avancée..
$12669851602178 [center]Calcule la circonférence des astéroïdes[/center]
$21601709632806* Combien fait 2π × {radius} ?
$16954408093587* Sur notre vaisseau nous détruisons naturellement les astéroïdes qui s'approchent avec des lasers...


=== levels/circular_dependency ===

$13880985462901* Réalise un circuit pour lequel l'entrée du composant dépend de sa propre sortie.
$18010308863615*
Crée une "dépendance circulaire". C'est un circuit pour lequel l'entrée du composant dépend de sa propre sortie. En cas de dépendance circulaire, il n'est pas possible de déterminer la sortie du composant, cela nécessiterait de connaître son entrée, qui dépend de sa sortie, et ainsi de suite, d'ou le "circulaire".

Ce cas n'est normalement pas accepté dans les autres niveaux, mais ici l'objectif est d'en créer un, afin de comprendre ce dont il s'agit avant de passer à la suite.
$13520037133129* Je ne suis pas sur que c'est utile aux étudiants, mais les profs adorent ça.
$11316928751185* Dans notre système éducatif nous enseignons traditionnellement en induisant les étudiants en erreur et en nous moquant d'eux.


=== levels/hex_racer ===

$92057009138253* Comment écrire {number} en binaire ?
$16009852370452*
Quand on manipule beaucoup de bits, le binaire commence à être difficile à lire. L'Hexadécimal (base 16) représente chaque combinaison de 4 bits par son propre caractère :
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

Voici un exemple de la meilleure lisibilité de l'hexadécimal, comparons les représentations du plus grand nombre de 16 bits :
[code]
Binaire :     1111111111111111
Décimal :     65535
Hexadécimal : FFFF
[/code]

Ce n'est pas facile de dire s'il manque un chiffre binaire ou s'il y a un décalage en décimal, mais l'hexadécimal est tout de suite clair (au moins une fois qu'on prend l'habitude).
$84691609525475* Ce niveau est mon deuxième passe-temps préféré. Convertir de l'hexadécimal au binaire en temps limité.
$45532697833519* Niveau {level} atteint !
$87016829502381* Très bien, tu as atteint le niveau {current_level}.
$43463538043782*
Modifie les bits du panneau pour atteindre le nombre hexadécimal demandé.

Tu dois finir le niveau 3 pour réussir.

(clique [color=#e63e5b][url=accessibility_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours)


=== ui/top_bar/scores ===

$56840961921536* SCORE NAND : \n SCORE DÉLAI :


=== levels/Water World ===

$13739681561355* Volume Total : 
$19185457941725* Bonne nouvelle, nous voulons transformer la Terre en un parc aquatique exotique !
$18940654086036* Nous avons besoin de ton aide pour trouver un bon emplacement pour le toboggan aquatique "Glissade du Pirate". En particulier nous cherchons un espace qui peut contenir un grand volume d'eau.
$14706805272652* Appuie sur Entrée pour montrer l'eau
$12881972193444*
Le terrain mesure 16 colonnes de large. Lis l'entrée 16 fois pour trouver la hauteur disponible pour chaque colonne de gauche à droite.
  
Envois alors en sortie comme réponse le volume total que le terrain peut contenir.


=== levels/Dancing Machine ===

$14975070588197
Nous aimons tous la façon dont le Robot bouge sur la piste de dance. C'est pourquoi nous le voulons à la tête de notre équipe de danceurs.
  
Le seul problème c'est de lui faire trouver des séries de mouvements originaux. Comment pourrait-on bien obtenir de la créativité à partir d'une logique déterministe ?

La solution a pour nom générateurs de nombres pseudoaléatoires.
$15955150920362*
Dans ce niveau tu n'as qu'une entrée, nous l'appellerons la graine initiale. La graine passe par les étapes suivantes pour produire un nombre pseudoaléatoire.

Dans l'algorithme ci-dessous, "shl 1" signifie un décalage à gauche,  "shl 2" signifie double décalage à gauche et "shr 1" un décalage à droite.

[b]8 bit xorshift RNG :[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Ensuite envoie en sortie next_seed mod 4 pour déplacer le robot. Enfin utilise next_seed (avant le mod 4) comme graine pour obtenir le nombre suivant pour la séquence de danse et ainsi de suite.

(Attention la graine initiale ne sera jamais 0)


=== components/Input 4 ===

$11447837612693* Entrée


=== misc/program_edit_signals ===

$98772447663910* Éditer les points d'observation


=== components/Output16z ===

$25071861608139* Sortie


=== misc/credits ===

$15234594767991* Crédits


=== levels/Add 5 ===

$11540713506719*
Tu es maintenant libre de modifier le programme de ton ordinateur.
Clique sur l'icône Editer du composant programme pour commencer à programmer.
$19281970848639* [center]Ajoute 5 à l'entrée.[/center]
$17770257567603* Donc pendant ce temps on te demandera d'aider un peu sur le vaisseau.
$19446152707984* Clique sur l'icône mémoire du composant programme pour commencer à programmer ton ordinateur. Ton ordinateur doit lire une entrée, y ajouter 5 et la renvoyer en sortie (on ne s'occupera pas du dépassement possible).
$80639633676917* Entrée :
$12078933051174* Mais comme tu ne sais pas encore le programmer, tu n'es pas encore vraiment prêt pour ça..
$11074247151096* Remarque que le composant registre rouge a été remplacé par un composant personnel dont l'usage est identique.
$18134632592542* Tu as construit ton ordinateur, mais pour gagner la compétition tu dois encore finir le labyrinthe.


=== main_scripts/levels ===

$64510812504271*
Certains composants utilisés ne sont pas supposés être disponibles dans ce niveau !
La solution n'obtient pas de score.


=== component_panels/Counter ===

$57936010210151* Incrementer de : {amount}


=== levels/1_decoder ===

$16057674753878* Réalise un composant qui peut aiguiller un signal entre deux pattes.


=== levels/byte_mux ===

$49305362057225* Ta réponse {your_answer}\nRéponse correcte {correct_answer} (Entrée {input})
$18296416014178* Quand le sélecteur de bit est [OFF], envoie en sortie l'Octet A, sinon envoie l'Octet B.
$17093993196554*
Même s'il a échoué à nos tests nous avons décidé de garder le chien. Contrairement à la plupart des terriens, il est affectueux et obéit bien aux ordres simples. 

Nous allons vous mettre tous les deux en équipe, vous êtes assez bien complémentaires.


=== misc/component_factory_toggle ===

$55499239951858* L'atelier de composants


=== components/Output8z ===

$86533851094807* Sortie


=== misc/reset ===

$39440928972984* Reset (Raccourci : F4)


=== levels/sandbox ===

$17054292175058* Bienvenue dans le bac à sable, ici tu es libre de t'amuser librement. Je t'ai donné des fils de 64 bits et quelques composants supplémentaires d'Entrées/Sorties (IO).
$10731996208080 Il y a également des versions 64 bit du programme, du compteur, du registre et de la RAM. Rappelle-toi que les lectures en RAM 64 bits prennent 1 cycle.
$72764802067974
Bienvenue dans le bac à sable. 

Les composants sont disponibles dans les menus du côté droit. Une fois placée, clique sur les pattes du composant et glisse pour les connecter au circuit. À gauche tu trouveras l'interface pour le contrôle de la simulation. Note que tu peux utiliser le clic droit sur le bouton "Vitesse d'Exécution" pour sélectionner la vitesse de ton choix.

Tu peux trouver plus d'information sur la simulation dans le manuel (bouton en haut à gauche). Les fonctions importantes à voir sont l'"atelier de composants" qui te permet de créer tes propres composants and le composant programme, qui te permet de définir ton propre langage assembleur.
$19454393978813* Le mini clavier te permet de contrôler ton ordinateur directement avec ton  clavier.
$14434122873489* Le générateur de forme d'onde (Waveform) te permet de générer des sons. Je vais probablement regretter de t'avoir donné celui-là.
$18405942066048* L'horloge donne l'heure UNIX courante en microsecondes.
$10451578314373 L'Écran Console te permet de dessiner des caractères sur un écran (voir caractères ASCII dans le manuel)


=== ui/toggles/race_condition ===

$75558678297830* Dépendance circulaire


=== misc/instr_clone ===

$69090690657232* Cloner


=== misc/program_edit_button ===

$38481453712356* Éditer la mémoire


=== levels/Crude Awakening ===

$12508086025944
Nous allons te tester.

Les règles sont simples, construis un ordinateur fonctionnel ou tu vas être mangé. Bonne chance !
$16321577947087 Félicitations, tu as été enlevé !
$19257730429557
Un signal se déplace toujours de composants "IN" vers des composants "OUT".
Dans le coin en haut à gauche en dessous de "IN" tu trouveras une icône verte, 
clique dessus pour changer son état.
$17675121574388* Le composant OUT s'est maintenant éteint, car aucun signal ne vient de l'entrée.\n


=== misc/wire_draw ===

$59836059268386* Nouveau fil (Raccourci : Alt & glisser)


=== components/Output64z ===

$23672623772864* Sortie


=== levels/byte_or ===

$10368115829346* En fait c'est OK car tu as eu une vie heureuse dans la nature et nous ne gâchons pas la bonne viande.
$15923734370936*
Applique OR sur chaque bit des octets en entrée et envoie le résultat en sortie.

Par exemple :
[code]
ENTRÉE 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
ENTRÉE 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
SORTIE  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]
$15226896485081* Est ce que tu penses que ce serait immoral de manger tous les terriens qui ne gagnent pas la compétition ?


=== levels/Conditionals ===

$10794262854382*
Ajoute des instructions si à ton circuit. Avec l'instruction si, les 2 arguments sont comparés et si la condition est vraie, le compteur est chargé avec une adresse de saut.

L'instruction précédente contient 4 octets qui représentent :  
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, RÉSULTAT[/color][/code]

Pour l'instruction si les octets représentent :
[code][color=#87a8c8]OPCODE, ARGUMENT\_1, ARGUMENT\_2, ADDRESSE\_SAUT[/color][/code]

En plus des copeops précédents, ajoute :
[code][color=#87a8c8]32 SI\_EGAL
33 SI\_NON\_EGAL
34 SI\_MOINS
35 SI\_MOINS\_OU\_EGAL
36 SI\_PLUS
37 SI\_PLUS\_OU\_EGAL[/color][/code]

Compare avec les composants pour nombres non signés.

Chaque opcode fait ce que son nom indique. Par exempie pour sauter à l'octet 16 si REG0 est inférieur à REG1 : 
[code][color=#87a8c8]SI\_MOINS REG0 REG1 16[/color][/code]
$18542005958715* Définis l'incrément du compteur à 4
$17133561664335* Félicitations, tu as terminé l'ordinateur [color=#e49f44]LEG[/color] !
$14973719570693* Ajoute un compteur au circuit
$12920514303805* Ajoute 6 registres au circuit
$14309211963063* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$16826220977157*
 [color=#b72d41][b]ASTUCE[/b][/color] 
 COPY est identique à ADD avec un second
 argument à 0
$14690660047411* [center]Implémente les opcodes conditionnels[/center]
$30132649789584* Le point d'Observation {number} doit pointer sur la sortie
$18994998239232* Je vais te montrer quelques évolutions que tu peux faire, afin d'implémenter les appels de fonction. Mais à partir de là tu devras t'occuper des détails, je ne te dirai plus quels opcodes utiliser, etc.
$12034111753799* Le point d'Observation {number} doit pointer sur le compteur
$36561706158040* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre


=== levels/byte_less ===

$11252365204151* Réalise un circuit dont la sortie est [ON] quand la première entrée est inférieure à la seconde. Les octets sont [color=#dd6576]NON SIGNES[/color].
$62766453128684* Est ce que {a} est inférieur à {b}?
$11632471752785* [center]Détermine si la première entrée est inférieure à la seconde.[/center]


=== misc/inst_new_rule ===

$41064305626707* Nouvelle règle


=== misc/multi_select ===

$85147529532131* Sélection multiple (Raccourci : SHIFT & glisser)


=== levels/always_on ===

$17712385236630* Réalise un circuit qui est toujours [ON].


=== levels/Logic Engine ===

$15865646260225*
 [color=#b72d41][b]PROVERBE[/b][/color] 
 La douleur est temporaire, la gloire est 
 éternelle.
$17594613477534*
Réalise un circuit qui peut effectuer les opérations OR, NAND, NOR et AND sur deux entrées. La troisième entrée sera l'[INSTRUCTION]. Une [INSTRUCTION] est juste le nom du nombre qui indique ce que l'on doit calculer.

Instructions :
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Enfin tu ne peux pas déplacer les composants rouges dans ce niveau, pour des raisons que l'on t'expliquera plus tard.


=== levels/binary_racer ===

$16076448195257 Ce niveau est mon passe-temps favori. Convertir du décimal au binaire en temps limité.
$37319690622142* Très bien, tu as atteint le niveau {current_level}.
$19111664765554*
Modifie les bits dans le panneau afin qu'ils représentent le nombre décimal demandé.

Tu dois atteindre le niveau 3 pour réussir.

(cliques [color=#e63e5b][url=accessibility\\_mode]ici[/url][/color] pour activer le mode accessible sans compte à rebours.)
$11176073682097* Combien fait {number} en binaire ?
$71866932309393* Tu as atteint le niveau {level} !


=== components/Bidirectional64 ===

$57762192431697* Patte sans tampon


=== levels/xor_gate ===

$14093358515620* Ceci est aussi appelé une porte XOR. Ce niveau est difficile, ne te décourage pas si tu ne trouves pas la réponse immédiatement.
$19182751521677* Dans le dernier niveau tu as réalisé un circuit qui était [ON] au second cycle. Ce niveau nécessite un circuit [ON] au second OU au troisième cycle.


=== levels/bit_adder ===

$13109388951000* Nous mesurons l'univers avec des nombres. Donc ta machine doit apprendre à compter.
$16564356062672
Considère que les entrées sont [ZERO] ou [ONE] en fonction de leur valeur [OFF] ou [ON]. Additionne-les-en binaire, de sorte que le résultat soit [ZERO] ou [ONE].

Comme avec l'addition habituelle, si le résultat ne peut être écrit avec un chiffre, mets la retenue à [ONE].


=== components/Output 3 ===

$96269858195218* Sortie


=== components/Output 1B ===

$77044600156969* Sortie


=== levels/double_number ===

$74261206899285* Ton résultat {input} × 2 = {your_answer}\nRésultat attendu {input} × 2 = {correct_answer}
$19766257822639*
L'entrée et la sortie de ce niveau utilisent des octets au lieu de bits. L'un des deux composants proposés prend un octet et l'éclate en 8 bits et l'autre fait l'inverse.

A l'aide de ces composants, trouve comment doubler le nombre en entrée (jusqu'à 127).


=== levels/counting_signals ===

$10724914203078*
Le composant sortie de ce niveau est un compteur binaire dont les 3 premières pattes correspondent à 1, 2 et 4.
Utilise le compteur binaire pour compter le nombre de signaux.

Regarde [color=#e63e5b][url=counting_signals]cet indice[/url][/color] si tu te retrouves coincé

[i][tip]La solution de ce niveau n'est pas très propre et nécessite pas mal de composants.[/tip][/i]
$10881918807029*
 [color=#b72d41][b]ASTUCE:[/b][/color] 
 Il n'y a pas de honte à utiliser
 une feuille et un stylo


=== levels/Spacial Invasion ===

$19967210826470 Attention : tu ne peux tirer avec le laser que lorsque les tir précédents ont disparus.
$16294185981398* Le soute du vaisseau est infesté de rats de l'espaces.
$11505369795084 Regarde [color=#e49f44][url=the\_robot]la page du robot[/url][/color] pour connaître les instructions pour le programmer. Tu peux aussi trouver un lien vers cette page dans l'éditeur de programmes.
$10515630949378 Nous avons connecté ton ordinateur à notre robot avancé et nous voulons que tu le programmes pour qu'il dératise la soute.


=== ui/state_ui/title_screen/exit ===

$12639868461113* Quitter


=== misc/button_next ===

$50213503063080* Prochain cycle (Raccourci : F5)


=== ui/toggles/level_map ===

$71951682957395* Carte des niveaux


=== levels/saving_bytes ===

$10633476398156
Créez un circuit qui pourra [SAUVEGARDER] ou [CHARGER] un octet.


Lorsque le premier bit est [ON], [CHARGER] la mémoire et envoyez la vers la sortie.
Lorsque le second bit est [ON], [SAUVEGARDER] l'octet en entrée.
$15510981129613* CHARGER
$13502950630653*
[color=#ff9800]Aucune
0
0[/color
$19109563882664* NE PAS CHARGER
$16372198430230* SAUVEGARDER
$11467279617581* SAUVEGARDER
$15498440508450* Ne rien faire
$10080722944246* NE PAS SAUVEGARDER
$18873598212433* CHARGER
$15582618410991* CHARGER ET SAUVEGARDER


=== misc/level_gate_component_icon ===

$83440578602427* Déverrouille des composants


=== levels/any_doubles ===

$16587030847545* Au vu de notre intelligence clairement supérieure, nous avons construit une machine pour plier nos chaussettes. Malheureusement, le fil qui détecte les paires de chaussettes est cassé sur cette machine.
$14373083988184
Ce niveau a 4 entrées. 
Sors [ON] quand 2 entrées ou plus sont [ON].

[tip]Ne te casse pas trop la tête sur ce niveau.[/tip]


=== levels/byte_constant ===

$12641789008694* Créez un système qui sortira toujours le nombre 164.


=== main_scripts/leg_level ===

$70383685548547* REG 
$85913831661289* SI\_INFERIEUR
$69956969985790* OUi
$53021804895845* ETi
$61412773713567* SOUSTRACTION
$52344899983501* SI\_INFERIEUR\_OU\_EGAL
$89945092889418* SOUSTRACTIONi
$71559031724238* SI_NON_EGAL
$71195301111400* ADDITIONi
$98178474649432* SI\_SUPERIEUR\_OU\_EGAL
$68187490877029* SI_EGAL
$44009845985661* ADDITION
$37810243909140* COMPTEUR
$50722296752142* ENTREE
$43723329256095* REGISTRE {nr}
$68666991962246* OU
$79492115258673* SI\_SUPERIEUR
$60997201855346* ADRESSE DE RESULTAT
$64519909700148* ET
$49810487048038* COMPTEUR
$18236360532765* SORTIE
$20950946171790* SAUTER VERS
$84307766381146* OPCODE (code d’opération)


=== levels/call_ret ===

$15840165316981*
Dans ce niveau tu as pour tâche d'implémenter les appels de fonctions et les retours avec les instructions [color=#e49f44]call[/color] et [color=#e49f44]ret[/color].

Fais attention au retour d'une fonction, tu dois sauter à l'adresse qui vient APRÈS l'instruction [color=#e49f44]call[/color], sinon tu te retrouveras avec un boucle infinie.
L'instruction [color=#e49f44]call[/color] doit réaliser les actions suivantes :
 [i]- Ajouter la longueur de l'instruction au compteur et [color=#e49f44]EMPILER[/color] cette longueur sur la pile[/i]
 [i]- Sauter à l'adresse de la fonction[/i]

L'instruction [color=#e49f44]ret[/color] doit réaliser les actions suivantes :
 [i]- [color=#e49f44]DÉPILER[/color] l'adresse de retour de la pile et sauter à cette adresse[/i]

Tu peux échanger de l'information avec et depuis une fonction en écrivant normalement les données dans des registres. Rappelle-toi quels registres sont écrasés par une fonction avant de l'appeler.
$19416009887091*
Parfois il est utile de réutiliser le même morceau de code. On appele ces morceaux des "fonctions". Pour pouvoir les utiliser, on pourrait utiliser le color=#e63e5b][url=termonology]jump[/url][/color] pour sauter au début de la fonction et pour en ressortir à la fin. On appele cette méthode "l'appel" d'une fonction et le retour au programme le "retour" de la fonction.

Mais pour que l'on puisse utiliser ce morceau de code plusieurs fois, on doit pouvoir sauter à des endroits différents lors du retour, dépendant de l'endroit dans le programme où on a appelé la fonction.

On pourrait sauvegarder la valeur du compteur dans un registre avant de sauter dans la foncton et utiliser cette valeur pour en resortir. Cependant, en faisant comme ça on pourrait écrire par dessus la valeur du registre si on appele une fonction depuis une autre fonction et on ne pourrait jamais revenir au programme principal.

Par exemple:
Disons que la fonction A appele la fonction B qui appele a son tour la fonction C. Quand on voudra revenir en arrière on aura besoin que de l'adresse de retour de la fonction B et une fois dans B on aura besoin que de l'adresse de retour de la fonction A. En général, indépendement du nombre d'appels de fonctions, la première adresse stocké sera toujours utilisé en dernier. Magiquement, c'est exactement le comportement du stack.
$19369640789869* Les coupes budgétaires ont conduit à réduire les salaires, et maintenant les assistants du labo sont en grève. Tu vas devoir t'autoévaluer dans ce test. Cela nous permettra d'évaluer ton niveau d'honnêteté et de maturité.
$15463931654475* [center]Ajoute les instructions "call" et "ret"[/center]


=== levels/odd_ticks ===

$18510295620397 Met la sortie à [OFF] pendant les cycles paires et [ON] pendant les cycles paires.
$16987046679863 Tu as appris précédemment que nous n'acceptons pas les dépendances circulaires. Il existe cependant une exception à la règle que tu vas voir maintenant.
$16037516781370*
Les pattes des composants carrés ne vont pas affecter la sortie du composant pendant le même cycle, c'est pour cela que l'on peut les utiliser pour les dépendances circulaire. 
  
  [img]dialogue/delay\_buffer.png[/img]
$17588119878416*
Le ligne de délais a le droit de dépendre de sa sortie, car son entrée ne va pas influencer le reste du circuit jusqu'au prochain cycle.
  
[img]dialogue/delay\_buffer.png[/img]


=== misc/solution_option ===

$21618236951146* Regarder la solution


=== components/Output 1 + 1B ===

$81929942356043* Sortie


=== ui/options/Robot Controls ===

$58799802152286* Contrôles du robot


=== misc/run_fast ===

$49363678936533* Augmenter la vitesse des cycles (clique droit: changer la vitesse)


=== levels/divide ===

$16412715945615* [center]Diviser deux nombres[/center]
$14525870461271*
Réalise la division entière des deux nombres pour calculer le quotient et le reste. Considérons la fraction 7/3. 7 contient deux fois 3 et encore 1. Dans ce cas on appelle 2 le [color=#e49f44]quotient[/color] et 1 le [color=#e49f44]reste[/color].
Dans cet exercice, tu reçois d'abord le numérateur (7 dans l'exemple) puis le dénominateur (3) et on attend en sortie le quotient (2) puis le reste (1).
$76454016047920* {numerator}/{denominator} = {quotient}, reste {remainder}


=== misc/instruction_expand ===

$44690074039467* Activer/Désactiver la définition des règles


=== components/Output 4 ===

$90190739202646* Sortie


=== misc/select_color ===

$97461374731210* Couleur de fil


=== levels/Delicious Order ===

$10160261151833* Commence par lire, une par une, les 15 notes des différents plats depuis l'entrée. Ton travail est de les envoyer triées sur la sortie, de la plus petite à la plus grande.
$16027225087666* Nous allons compléter l'encyclopédie galactique culinaire en ajoutant la nourriture humaine. Comme nous n'avons pas d'alphabet, les articles de l'encyclopédie sont rangés dans l'ordre de leur note.


=== components/Bidirectional16 ===

$56965384656153* Patte sans tampon


=== levels/push_pop ===

$78804623186243* SORTIE
$49526452710191 NE PAS DÉPILER
$58050047963238* VALEUR
$30926395960020* EMPILER
$19245209470436* Créer une pile
$12227209887733 A chaque cycle les entrées indiqueront soit EMPILER soit DÉPILER. Si c'est EMPILER, stocke la valeur en haut de la pile. Quand c'est DEPILER retire cette valeur de la pile et envoie-la en sortie.
$85171087236638* ACTIVER
$15662660252584* Ne rien faire
$23726790986805 DÉPILER
$62469306234943* NE PAS EMPILER
$65188797398656* EMPILER {value} sur la pile
$18761197388580 Pour raison d'économies, il a été décidé de gérer différemment les files d'attente dans les établissements publics pour réduire le nombre de demandes. Plus de premier arrivé, premier servi, maintenant la règle ce sera dernier arrivé, premier servi. Imagine une [color=#e49f44]pile[/color] de fiches numérotées o˘ les usagers peuvent called poser leur fiche au-dessus (action [color=#e49f44]EMPILER[/color]) et les fonctionnaires prennent la fiche du haut de la pile (action [color=#e49f44]DÉPILER[/color]). ¿ toi d'implémenter ce nouveau système.
$46948857059388* DÉPILER valeur {value} de la pile


=== levels/Tower of Radioactive Alloy ===

$13757925963562* Cette fois nous te demandons de déplacer des piles de disques radioactifs retirés d'un vieux réacteur. Fais juste attention à ne pas placer un disque plus grand sur un plus petit sinon tout le vaisseau va exploser.
$10750976989948*
Les 4 premières entrées te donneront dans l'ordre :
num\_disque - le numéro du disque en haut de la pile (de 2 à 4)
source - le numéro d'emplacement de départ
destination - le numéro d'emplacement cible
réserve - Le 3ème emplacement qui n'est ni la source ni la destination

Contrôle la grue en utilisant les valeurs suivantes en sortie :
0 - Place l'aimant à l'emplacement 0
1 - Place l'aimant à l'emplacement 1
2 - Place l'aimant à l'emplacement 2
5 - Active ou désactive l'aimant

Manipule l'aimant manuellement à l'aide des touches flèches et Enter pour activer/désactiver.
$19265994465686* Nous avons besoin de toi pour ranger le sous-sol.
$35120623183961* Déplacer de {source} vers {destination}
$15855497886737*
Implémente l'algorithme suivant :

Algorithme des tours de Hanoi[code][color=#87a8c8]
fonction déplacer(numdisque, source, destination, réserve):
  si num\_disque est 0:
    déplacer disque de source à dest
  sinon:
    déplacer(num\_disque - 1, source, réserve, destination)
    déplacer disque de source à dest
    déplacer(num\_disque - 1, réserve, destination, source)

déplacer(numdisque, source, destination, réserve)[/color][/code]

[tip]Empile les valeurs de registre pour les sauvegarder avant l'appel d'une fonction qui les modifie.[/tip]


=== levels/The Product of Nibbles ===

$14957949958941* Ce que tu as fait ici c'est en fait une multiplication de deux nombres de 4 bits. Le stagiaire s'est chargé de l'étendre aux octets.
$19136817138607* [center]Multiplie les nombres de 4 bits[/center]
$14533861483435* La multiplication de deux nombres de 4 bits donne un nombre de 8 bits. Réalise le schéma adapté.
$83694551809785* Multiplier {num1} et {num2}


=== components/Input 1 Byte ===

$40943344093513* Entrée


=== levels/byte_and ===

$15885763626223* Réalise un circuit qui applique la fonction AND logique (bit à bit) sur deux octets.


=== ui/toggles/level_log2 ===

$91515053618360* Manuel


=== main_scripts/functions ===

$11467644007149* Compteur {nr}
$72465734060414* Court-circuit sur le fil (valeurs en sortie  {values})
$10533010562232 SCORE DÉLAI : {delay}
$29169064199243* Sortie {nr}
$13327741293223* Entrée {nr}
$32508339206292* SCORE NAND : {nand}


=== levels/odd_number_of_signals ===

$16173829560311* En utilisant au maximum 3 composants, met la sortie à [ON] seulement lorsqu'un nombre pair d'entrées est [ON].
$85589489148198* Composants utilisés\n{nr} sur 3
$18288998816979* Ce niveau a un [color=#e63e5b][url=odd\_number]indice[/url][/color] que tu peux lire si tu es bloqué..


=== misc/wire_color ===

$78287906849040* Couleur de fil


=== levels/or_gate_3 ===

$15448906128695* Réalise une porte OR avec 3 entrées.


=== levels/3_decoder ===

$19231618567710* Avec 3 bits en entrée 8 combinaisons sont possibles. Réalise un circuit pour sélectionner une sortie pour chacune des 8 combinaisons. Un bit et un seul doit être [ON] à chaque instant.
$14293122338496* Nous avons fait ajouter au stagiaire un bit "désactivé" sur ce composant. Nous étions las de le voir tourner en rond et cherchions une nouvelle tâche inutile et ennuyeuse à lui donner.


=== levels/Storage cracker ===

$11910674853271*
La porte sécurisée de la réserve est défaillante et elle enferme régulièrement notre vieil homme de ménage.
La porte n'arrête pas de changer le code d'accès, nous avons besoin d'un programme qui peut le récupérer quand c'est nécessaire.
$17462419719036*
La façon la plus simple de trouver le code serait d'essayer toutes les combinaisons juqu'à ce que tu trouves la bonne.
Le mécanisme défectueux fait un bruit désagréable quand ton essai est trop grand, il doit être possible d'en tirer profit.
$11183892008673* Tu réussis ce niveau en envoyant en sortie le code correct, il n'est pas possible d'échouer avec une mauvaise sortie. De plus l'entrée sera à 1 après un essai trop grand et 0 sinon.


=== levels/constants ===

$17098439090371
Nous devons transférer directement les nombres de notre programme aux registres. Pour cela nous utilisons le mode immédiat (qui correspond aux deux bits supérieurs à [OFF][OFF]).

Avec le mode immédiat, tout l'octet est interprété comme un nombre à [SAUVER] dans le REG 0. Ça veut dire qu'on peut 
[SAUVER] des valeurs allant de 0 à 63.


=== components/Output16 ===

$37381472194529* Sortie


=== levels/program ===

$16693098943939
Le composant d'entrée [INSTRUCTION] a été supprimé. Il a été remplacé par un composant programme. À chaque cycle, utilise le compteur pour charger l'[INSTRUCTION] suivante de la mémoire du programme.
  
Tu dois utiliser le composant compteur que tu as déverrouillé dans un niveau précédent.
$19686277478479* Le programme envoie toujours la première instruction. As tu connecté un compteur ?


=== components/Input 3 ===

$70689623552857* Entrée


=== levels/Arithmetic Engine ===

$16434409050195*
Ajoute l'addition et la soustraction à ton circuit.

Instructions
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144*
Dans ce niveau, les entrées représentent les lettres dans une liste de noms de planète, encodés en ASCII (voir le manuel). Chaque nom est séparé par un espace qui a la valeur numérique 32. Remplace la première lettre de chaque mot avec la majuscule correspondante.
(Les caractères possibles en entrée sont les minuscules de a à z, l'espace, l'apostrophe et le tiret).
$13301617098810* A notre demande le stagiaire a saisi une liste de planètes en langue humaine. Malheureusement il a oublié de mettre les majuscules aux noms.
$11647445869837* Entrée : 
$11201813578269* Sortie : 


=== levels/byte_equal ===

$17156565273196* La sortie doit être [ON] quand les deux entrées sont identiques.


=== components/Output32z ===

$90826155624234* Sortie


=== components/InputQword ===

$31709565019284* Entrée


=== ui/options/General ===

$36195388998735* Général


=== levels/not_gate ===

$19085882338208 [b]Consigne[/b]\nFais un clique droit pour désélectionner
$14042842216181 Dans le dernier niveau, tu as construit le tableau à partir du circuit. Dans ce niveau tu devras créer un circuit qui correspondra au tableau.
$10042327259531 Maintenant que tu as déverrouillé la porte NAND, il est temps de créer ton propre circuit.
$10604720087324 [b]Consigne[/b]\nConstruis un circuit qui correspond au tableau.\nCliquez [i]?[/i] (Prochain Cycle) en haut à gauche pour tester chaque combinaison d'entrées.\Tu réussiras le niveau une fois que les deux combinaisons seront justes.
$19798729463813
En utilisant des portes NAND, contruis une porte NOT.

En utilisant : [b]porte NAND[/b]
[code]Entrée 1 : [OFF][ON][OFF][ON]
Entrée 2 : [OFF][OFF][ON][ON]
Sortie :  [ON][ON][ON][OFF][/code]

Construis : [b]porte NOT[/b]
[code]Entrée 1 : [ON][OFF]
Sortie :  [OFF][ON][/code]
$18442122157391 [b]Consigne[/b]\nDésélectionne le composant en cliquant sur l'arrière-plan
$12880883686501 [b]Consigne[/b]\nClique sur la porte NAND en haut à droite et placez là
$18780831606716 [b]Consigne[/b]\nMaintiens le clique gauche pour ajouter un fil


=== misc/factory ===

$53123649343022* L'atelier de composants


=== levels/registers ===

$10661964231175* J'ai forcé la position des composants rouges pour ce niveau, car tu t'embrouilles toujours en ne laissant pas assez de place. À partir d'ici tu ne repartiras plus de rien à chaque niveau, le désordre sera désormais sauvegardé d'un niveau à l'autre.
$10211777161405*
Voici les combinaisons de bits pour chaque [color=#c54d5e]source[/color] et [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  ENTREE 
[ON] [ON] [ON]  NON UTILISE

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  SORTIE
[ON] [ON] [ON]  NON UTILISE

Pour obtenir des explications plus intuitives des exigences clique sur l'icône [INSTRUCTION] dans le coin supérieur gauche.
$15888345020710*
Dans ce niveau tu dois créer un circuit pour copier d'une [color=#c54d5e]source[/color] vers une [color=#e49f44]destination[/color]. 

L'octet instruction indique ici la [color=#c54d5e]source[/color] et la [color=#e49f44]destination[/color]. 

Les bits 1, 2 et 3 indiquent la [color=#e49f44]destination[/color]. Les bits 4, 5 et 6 indiquent la [color=#c54d5e]source[/color].
$14823499195861* Ouvrir les "Instructions" dans la barre en haut
$14108238519744* Il est temps de créer ton chef d'oeuvre, en implémentant l'architecture informatique [color=#e49f44]OVERTURE[/color]. Ce sera un véritable système Turing Complet, un vrai ordinateur dans tous les sens du terme !
$14411286553593* Enfin les composants d'entrée et sortie ont maintenant une nouvelle patte. Met cette patte à [ON] pour lire depuis l'entrée ou copier vers la sortie.
$14041158687959*
Les [color=#c54d5e]Sources[/color] et les [color=#e49f44]destinations[/color] peuvent être un des 6 registres, nous les appellerons REG 0 jusqu'à REG 5. 
  
De plus cette carte a un composant d'entrée spécifique qui peut être la [color=#c54d5e]source[/color] et un composant de sortie qui peut être la [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755* Sortie


=== components/Input32 ===

$10677927084411* Entrée


=== misc/score_sync ===

$76911045833478* synchroniser le score


=== ui/top_bar/gate_score ===

$16224450605442* NAND SCORE:


=== misc/level_gate_unlocks_unknown ===

$76731326010721* Déverrouille quelque chose d'inconnu


=== misc/level_gate_manual_icon ===

$22002156022920* Déverrouille la page de manuel


=== levels/Masking Time ===

$19351773688761* Cycles restants : {ticks_left}  Entrée : {input}
$16810715868480 [center]Calcule le modulo 4 de l'entrée.[/center]
$17375862136921*
La durée de notre semaine est de 4 jours. On appelle les jours Jour Zéro, Jour Un, Jour Deux et Jour Trois. J'ai entendu que les humains ne savaient pas compter les jours correctement?

Ça ne me surprend pas vraiment.
$65431688078892*
Dans ce niveau on te donne un nombre n en entrée et tu dois retourner comme résultat ce nombre modulo 4.

La difficulté est que tu as seulement {ticks_per_test} cycles pour sortir le résultat attendu.

Attention, tu n'as pas besoin de modifier le circuit, tu dois trouver l'astuce pour calculer rapidement le modulo 4.
Regarde [color=#e63e5b][url=masking_time]l'indice[/url][/color] si tu es coincé.
$81055582534899 Enfin le nouvel an arrive et nous te demandons de calculer le jour de la semaine de naissance de tout le monde. Nous te donnerons la date et tout ce que tu as à faire c'est de retourner le jour de la semaine en {ticks_per_test} cycles maximum.


=== levels/byte_adder ===

$16888130664370
Si le résultat prends plus que 8 bits de place, met la sortie retenue à [ON] (tu peux l'utiliser comme un 9ème bit)

Il y a aussi une entrée retenue, elle sera utile pour additionner des octets à la suite. On additionne la retenue en entrée au résultat (0 [OFF] ou 1 [ON]).

Utilise [color=#e63e5b][url=byte\_adder]cet indice[/url][/color] si tu es coincé.
$18732877690173 Additione les deux octets en entrée. Chaque bit en sortie devra être le résultat de l'addition des bits d'entrées et potentiellement de la retenue. 


=== component_panels/FlexRam_1 ===

$87788654491792*
Ce type de RAM ajouterait un délai de 1024 au circuit, mais au lieu d'augmenter la durée des cycles, nous n'attendrons simplement pas la sortie.

En pratique cela signifie que la [color=#e49f44]lecture prend {ticks} cycles[/color] (car ton circuit a un délai de {delay}).


=== levels/saving_gracefully ===

$14295883660596* VALEUR
$14950983012226* SAUVEGARDER
$12474728041023
La Ligne à Retard nous permet d'utiliser une valeur un cycle plus tard.

Nous devons réaliser un composant qui nous permet d'utiliser une valeur dans le futur, quelque soit le nombre de cycles plus tard.
Nous appellerons cette valeur [color=#e49f44]sauvegarde[/color].
$13045361823397* NE PAS SAUVEGARDER
$13740696609075*
Ce niveau comporte deux entrées.
La valeur sauvegardée est modifiée seulement quand la première entrée est à [ON].
La seconde entrée est la nouvelle valeur de la [color=#e49f44]sauvegarde[/color].

Envois toujours en sortie la [color=#e49f44]sauvegarde[/color].


=== components/Output32 ===

$37476623180671* Sortie


=== misc/profile ===

$32835651830157* Profil


=== components/Bidirectional1 ===

$43779921858797* Patte sans tampon


=== components/Bidirectional32 ===

$30284920151373* Patte sans tampon


=== misc/delete ===

$53448014080434* Supprimer (Raccourci : Clic droit)


=== misc/controls2 ===

$38773676077206* Éditer les instructions


=== components/Input1_1B ===

$10517158300617* Entrée


=== misc/factory_back ===

$98930461722118* Revenir au niveau


=== levels/unseen_fruit ===

$13023474026617*
Les fruits sont la découverte la plus remarquable sur votre planète. Ils sont très savoureux.

C'est pourquoi nous organisons une dégustation de fruits dans cette cantine.
$14259900563789* Surveille régulièrement le tapis roulant sur lequel les fruits arrivent. Si tu vois le même type de fruit pour la seconde fois, active et tourne le panneau de contrôle.
$17070232883226* Mais nous voulons être sur de ne pas avoir deux fois le même fruit, car cela serait trop embarrassant.


=== ui/toggles/negative_numbers ===

$50924073287410* Choix du format de nombre


=== levels/conditions ===

$12951779797594
Dans ce niveau il y a en entrée une valeur et 3 bits de condition.

Les 3 bits déterminent la condition comme indiqué ci-dessous. Évalue la valeur en fonction de la condition et envoie [ON] si elle est vérifiée et [OFF] sinon.

Code condition       Sortir [ON] si [code]
[OFF] [OFF] [OFF]    Jamais
[OFF] [OFF] [ON]    Si valeur = 0
[OFF] [ON] [OFF]    Si valeur < 0
[OFF] [ON] [ON]    Si valeur ≤ 0
[ON] [OFF] [OFF]    Toujours
[ON] [OFF] [ON]    Si valeur ≠ 0
[ON] [ON] [OFF]    Si valeur ≥ 0
[ON] [ON] [ON]    Si valeur > 0[/code]
$16407231803964* Si VALEUR < 0 sortie [img]dialogue/on.png[/img]
$16742265812068* Quelquesoit la VALEUR output [img]dialogue/on.png[/img]
$17616699231679* Si VALEUR > 0 sortie [img]dialogue/on.png[/img]
$16632557438774* Si VALEUR ≠ 0 sortie [img]dialogue/on.png[/img]
$18234235689107* Si VALEUR ≥ 0 sortie [img]dialogue/on.png[/img]
$12429396872036* Quelquesoit la VALEUR output [img]dialogue/off.png[/img]
$19014698800906* Si VALEUR = 0 sortie [img]dialogue/on.png[/img]
$13680487623452* Si VALEUR ≤ 0 sortie [img]dialogue/on.png[/img]
$12706881725738* Votre circuit a été enregistré dans l'atelier de composants.


=== misc/factory_back_inner ===

$12211557416281* Revenir au niveau


=== levels/full_adder ===

$17063157033479*
Dans le niveau précédent, nous avons additionné 2 entrées, cette fois ce sera 3. Encore une fois, ajoute toutes les entrées en binaire, de façon à ce que le résultat soit [ZERO] ou [ONE].

Comme avec l'addition normale, si le résultat ne peut être représenté avec un chiffre, met la retenue à [ONE].


=== levels/or_gate ===

$12749704931323* Tu devrais être heureux de pouvoir participer à nos tests prestigieux.
$11472059692644* Tu as la chance de communiquer avec des gens très avancés de la civilisation galactique..


=== levels/and_gate ===

$15232844525838*
Réalise le circuit qui correspond au tableau.
  
[tip]Double-clique sur un composant pour le déplacer avec son groupe de fils connectés directement.[/tip]
$15231724707514 Je ne veux pas te décourager, mais je pense que l'éléphant va gagner la compétition. Sans vouloir t'offenser, ton cerveau est tout petit en comparaison.


=== ui/toggles/level_log ===

$38557550573896* Présentation du niveau


=== misc/change_schematic ===

$79554853897000* Changer de schéma


=== levels/sr_latch ===

$11150103897185*
Dans ce niveau, les composants peuvent dépendre d'eux-mêmes ou former des boucles contenant 2 composants. Malgré ces dépendances certains de ces circuits ont des sorties stables, au moins pour certaines valeurs en entrée.

Le circuit que l'on te demande de construire ici a une dépendance circulaire. Le circuit a aussi 2 "états stables" pour la plupart des entrées. Un état stable signifie ici que les sorties de chaque composant sont en accord avec leurs entrées. Par exemple, une porte OR avec une entrée déconnectée et l'autre connectée à sa propre sortie est stable. Si la sortie est [OFF], les 2 entrées sont [OFF], ce qui est acceptable pour la porte OR. Si la sortie est [ON] alors l'une des entrée l'est aussi. Par contre, une porte NOT connectée à sa propre entrée n'est pas stable. Si la sortie est [ON], alors l'entrée l'est aussi. Cela fait que la porte NOT essaie de changer sa sortie en [OFF]. Le circuit va osciller entre ces deux états indéfiniment et il n'est donc pas stable.
$18165461234561 Les lignes à retard sont simples à comprendre et peuvent être utilisées pour construire n'importe quelle architecture d'ordinateur. Pourtant le matériel moderne ne les utilise plus comme base des mémoires.
$15754153332116
Ce niveau présente le concept de bascule. Ce dispositif n'est pas utilisé ailleurs dans le jeu. Néanmoins ce niveau existe pour une raison d'exhaustivité.
  
Si tu n'as aucune expérience en électronique, il est recommandé de sauter ce niveau. Tu pourras toujours revenir plus tard.
$15213907597666 Avec 2 portes NOR, construisez le circuit qui correspond à la table. Tu auras besoin d'une bascule.
$19448398663695
Pour déterminer quels composants contrôlent la sortie dans une dépendance circulaire, il est impossible de fixer un composant de départ. À la place nous utilisons les valeurs des fils du cycle précédent. Cela s'explique par le fait que les électrons ne se déplacent pas instantanément dans la réalité. En fonction du câble, le circuit oscille entre [ON] et [OFF], ou se fixe dans un état stable.
  
Quand un circuit peut se fixer dans 2 états stables distincts, tu as la base pour une mémoire. L'état suivant dépendra des valeurs sur les fils du cycle précédent. De tels circuits sont appelés "bascules".


=== levels/byte_xor ===

$19636386696963* Réalise un circuit qui applique XOR bit à bit sur deux octets.


=== misc/menu ===

$56916384895438* Menu Général


=== levels/Immediate Values ===

$64348543296709* Le point d'Observation {value} doit pointer sur la sortie
$14060810229477* Ajoute 6 registres dans le circuit
$79667526283284* Le point d'Observation {value} doit pointer sur le compteur
$14960344494328*
Parfois il est utile de charger une valeur directement depuis le programme que d'un registre. Cela s'appelle charger une valeur immédiate. Pour l'architecture [color=#e49f44]LEG[/color] l'opcode indique directement que nous voulons faire cela. C'est possible de la façon suivante :

Quand le 8ème bit de l'opcode est [ON], utilise l'argument 1 comme une valeur immédiate et non comme une adresse de registre.
Quand le 7ème bit de l'opcode est [ON], utilise l'argument 2 comme une valeur immédiate et non comme une adresse de registre.
	
		[img]dialogue/leg_diagram.png[/img]
$10788301006338* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19338533633006* Définis l'incrément du compteur à 4
$15197362332657* Crée un nouveau schéma et ajoute un programme avec une sortie de 4 octets
$18004215603701* Ajoute un compteur au circuit
$10141611261952* [center]Implémente les valeurs immédiates[/center]


=== levels/xor ===

$11589029892097* XOR les bits des entrées {a} et {b}
$12758156517177* En utilisant les instructions implémentées par ton ordinateur, lit deux fois l'entrée et effectue un XOR sur les deux valeurs
$16047615798435* [center]Lit deux fois l'entrée et effectue un XOR sur les bits des deux entrées[/center]


=== levels/Wire Spaghetti ===

$29329105515650* Ajoute un registre de plus au circuit
$17106892574116* Ajoute un compteur au circuit
$50177586789991* Ajoute {nr} registres de plus au circuit
$15754373587500* Définis l'incrément du compteur à 4
$56024330661504* Le point d'Observation {nr} doit pointer sur un registre ou un composant personnel contenant un registre
$19099471819164*
Voici les premières choses à faire pour résoudre ce niveau :
    
[b]1.[/b] Clique l'icône schéma ([b][i]?[/i][/b]) et crée une nouvelle architecture.
[b]2.[/b] Ajoute un bloc de programme avec 4 sorties.
[b]3.[/b] Ajoute un compteur, définis son incrément à 4 et connecte-le au bloc de programme.
[b]4.[/b] Ajoute 6 registres (ou 6 composants personnels contenant un registre)
[b]5.[/b] Clique "Editer point d'observation" sur le composant programme et connecter les registres aux points 0 à 5. Connecte le compteur au 6 et la sortie au 7.
$18860645759682*
L'architecture [color=#e49f44]LEG[/color] est un ordinateur qui lit 4 octets de programme par cycle. 

Le premier octet correspond à l'opération (called the [color=#e49f44]OPCODE[/color]).

Comme beaucoup d'opérations prennent 2 arguments (ADD, OR etc.), les second et troisième octets servent pour les arguments.

Et comme la plupart des opérations retourne 1 résultat, le quatrième octet est pour le résultat.
  
  [img]dialogue/leg\_diagram\_1.png[/img]
$11377431500625* Ajoute 6 registres au circuit
$14051336765362* Enfin c'est maintenant que tu commences à construire l'architecture [color=#e49f44]LEG[/color] !
$13268807052125* (Tu pourras additionner 7+7, mais ici 7 signifie lire depuis l'entrée et l'entrée a pour valeur 8)
$30006055126224* Le point d'Observation {output} doit pointer sur la sortie
$19066122929275* [center]Met en place les registres et implémente l'opcode ADD [/center]
$10912834168905
Enfin, pour ce niveau l'[color=#e49f44]OPCODE[/color] est toujours 0. Cela veut dire qu'il faut additionner les arguments 1 2 et envoyer le résultat sur la destination.

Les valeurs utilisées pour les arguments ou la destination sont les suivantes :
[code]
[color=#e49f44]0[/color]: Registre 0
[color=#e49f44]1[/color]: Registre 1
[color=#e49f44]2[/color]: Registre 2
[color=#e49f44]3[/color]: Registre 3
[color=#e49f44]4[/color]: Registre 4
[color=#e49f44]5[/color]: Registre 5
[color=#e49f44]6[/color]: Compteur
[color=#e49f44]7[/color]: Entrée/Sortie
[/code]

Dans le niveau suivant tu implémenteras d'autres [color=#e49f44]OPCODES[/color], ce qui nécessitera une nouvelle ALU différente de celle d'[color=#e49f44]OVERTURE[/color].
$10922418807673* L'argument 7 nécessite de lire sur l'entrée, mais l'entrée n'est pas active.
$62258842382434* Le point d'Observation {counter} doit pointer sur le compteur
$18769284297247* Créé un nouveau schéma et ajoute un programme avec une sortie sur 4 octets.


=== components/InputConditions ===

$75386511637758* Entrée


=== levels/the_bus ===

$72472660427162* [center]Copie la valeur de l'entrée {input_nr} vers la sortie {output_nr}[/center]
$85140574084420* [center]Copie la valeur de la bonne entrée vers la bonne sortie[/center]


=== levels/and_gate_3 ===

$14788981567936 Crée une porte NAND avec 3 entrées.


=== components/Output8zLevel ===

$49513138880387* Sortie


=== components/OutputQword ===

$43552728118031* Sortie

